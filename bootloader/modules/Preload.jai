/*
    Minimal code the compiler needs to compile user source code. Volatile!

    This file should only contain things the compiler needs in order
    to successfully compile user-level code. (For example, things for which
    it needs pointers at various stages in the compilation process).

    This file cannot contain any varargs
    procedures, because those would need to use the type of Any, but they might
    compile before Any. We could make dependencies on Any every time there's a
    varargs, but that seems like an unnecessary complication that would
    incur a runtime performance penalty.

                             -- jblow, 15 May 2015.

    Addendum: We can't use type_info() here! Really it is best if there is no imperative code at all.

*/

Operating_System_Tag :: enum u32 {
    NONE      :: 0;
    KRAMPOS   :: 1;  // The Krampus Operating System.
    WINDOWS   :: 2;  // Any flavor of Microsoft Windows.
    LINUX     :: 3;  // Any flavor of Linux, except Android I guess.
    ANDROID   :: 4;
    IOS       :: 5;
    MACOS     :: 6;  // MacOsX, OS/X, macOS, or whatever they are calling it this year.
    NN_SWITCH :: 7;  // The Nintendo Switch.
    PS4       :: 8;
    PS5       :: 9;
    XBOX      :: 10; // Xbox One, Xbox Two, whatever. Like Windows but different.
}

CPU_Tag :: enum u32 {
    UNINITIALIZED :: 0;
    KRAMPU        :: 1;  // The Krampus CPU.
    CUSTOM        :: 2;
    X64           :: 3;
    ARM64         :: 4;
}

Type_Info_Tag :: enum u32 {
    INTEGER              :: 0;
    FLOAT                :: 1;
    BOOL                 :: 2;
    STRING               :: 3;
    POINTER              :: 4;
    PROCEDURE            :: 5;
    VOID                 :: 6;
    STRUCT               :: 7;
    ARRAY                :: 8;
    OVERLOAD_SET         :: 9;
    ANY                  :: 10;
    ENUM                 :: 11;
    POLYMORPHIC_VARIABLE :: 12;
    TYPE                 :: 13;
    CODE                 :: 14;

//    UNARY_DEREFERENCE :: 15;
//    UNARY_LITERAL :: 16;
    VARIANT              :: 18;
}


// The Type_Infos all need to be here because when you say
// type_info(x), we downcast to the most specific Type_Info.
// This is useful. But requires more in the preload. Sigh!

Type_Info :: struct {
    type: Type_Info_Tag;
    runtime_size:    s64;  // WARNING: runtime_size may be unset for structs at compile-time if compilation is not finished. (It will be -1 in this case.) It can also be -1 if the type is polymorphic.
}

Type_Info_Integer :: struct {
    using #as info: Type_Info;
    signed: bool;
}

Type_Info_Float :: struct {
    using #as info: Type_Info;
}

// There is no Type_Info_Bool.

// Type_Info_String is currently useless; we may get rid of it eventually.
Type_Info_String :: struct {
    using #as info: Type_Info;
}

Type_Info_Pointer :: struct {
    using #as info: Type_Info;

    pointer_to: *Type_Info;
}

Type_Info_Procedure :: struct {
    using #as info: Type_Info;

    argument_types: [] *Type_Info;
    return_types:   [] *Type_Info;

    procedure_flags: Flags;

    Flags :: enum_flags u32 {
        IS_ELSEWHERE    :: 0x1;
        IS_COMPILE_TIME :: 0x2;
        IS_POLYMORPHIC  :: 0x4;
        HAS_NO_CONTEXT  :: 0x8;
        IS_C_CALL       :: 0x20;
        IS_INTRINSIC    :: 0x80;
        IS_SYMMETRIC    :: 0x100;

        IS_CPP_METHOD   :: 0x1000_0000;
        HAS_CPP_NON_POD_RETURN_TYPE :: 0x2000_0000;
    }
}

// There is no Type_Info_Void.

Struct_Nontextual_Flags :: enum_flags u32 { // These are things not written by the user, but that get generated by the compiler.
    NOT_INSTANTIABLE          :: 0x4;
    ALL_MEMBERS_UNINITIALIZED :: 0x40;
    POLYMORPHIC               :: 0x100;
}

Struct_Textual_Flags :: enum u32 {
    FOREIGN                                :: 0x1;
    UNION                                  :: 0x2;
    NO_PADDING                             :: 0x4;
    TYPE_INFO_NONE                         :: 0x8;
    TYPE_INFO_NO_SIZE_COMPLAINT            :: 0x10;
    TYPE_INFO_PROCEDURES_ARE_VOID_POINTERS :: 0x20;
}

Struct_Status_Flags :: enum_flags u32 {
    INCOMPLETE :: 0x1;
    LOCAL      :: 0x4;
}

Type_Info_Struct :: struct {
    using #as info: Type_Info;

    name: string;

    specified_parameters: [] Type_Info_Struct_Member;
    members:              [] Type_Info_Struct_Member;

    status_flags:     Struct_Status_Flags;
    nontextual_flags: Struct_Nontextual_Flags;
    textual_flags:    Struct_Textual_Flags;

    polymorph_source_struct: *Type_Info_Struct;

    initializer: (*void);

    constant_storage: [] u8;
    notes: [] string;
}

Type_Info_Struct_Member :: struct {
    name: string;
    type: *Type_Info;
    offset_in_bytes: s64;

    flags: Flags;

    notes: [] string;

    offset_into_constant_storage: s64 = -1;  // -1 if this is not in constant storage; >=0 otherwise.

    Flags :: enum_flags u32 {
        CONSTANT                              :: 0x1;
        IMPORTED                              :: 0x2;
        USING                                 :: 0x4;
        PROCEDURE_WITH_VOID_POINTER_TYPE_INFO :: 0x8;
        AS                                    :: 0x10;
    }
}

Type_Info_Array :: struct {
    using #as info: Type_Info;

    element_type: *Type_Info;

    array_type:            Array_Type;
    // (hole)

    array_count:           s64;        // -1 unless this array is is of a known compile-time size, i.e. array_type is FIXED.

    Array_Type :: enum u16 {
        FIXED     :: 0;
        VIEW      :: 1;
        RESIZABLE :: 2;
    }
}

// There is no Type_Info_Any.

Enum_Status_Flags :: enum_flags u16 {
    INCOMPLETE :: 0x1;
}

Enum_Type_Flags :: enum_flags u16 {
    FLAGS     :: 0x1;  // This means it's declared as an enum_flags, not an enum. Confusing because we are in an enum that itself is called Flags, that has nothing to do with this.
    COMPLETE  :: 0x2;  // Enum is marked as #complete.
    SPECIFIED :: 0x4;  // Enum is marked as #specified.
}

Type_Info_Enum :: struct {
    using #as info: Type_Info;

    name: string;
    internal_type: *Type_Info_Integer;

    names:         [] string;
    values:        [] s64;

    status_flags:    Enum_Status_Flags;
    enum_type_flags: Enum_Type_Flags;
}

Type_Info_Variant_Flags :: enum_flags u32 {
    DISTINCT :: 0x1;
    ISA      :: 0x2;
}

Type_Info_Variant :: struct {
    using #as info: Type_Info;

    name:          string;
    variant_of:    *Type_Info;
    variant_flags: Type_Info_Variant_Flags;
}

// There is no Type_Info_Polymorphic_Variable.
// There is no Type_Info_Type.

Any_Struct :: struct {  // This is what an Any looks like.
    type: *Type_Info;
    value_pointer: *void;
}

__reg :: #type,distinct u16;

Workspace :: s64;

Allocator_Proc :: #type (mode: Allocator_Mode, size: s64, old_size: s64, old_memory: *void, allocator_data: *void) -> *void;
Allocator :: struct {
    proc: Allocator_Proc;
    data: *void;
}

Allocator_Mode :: enum {  // @Volatile: If you change these, the bytecode has to change!
    ALLOCATE  :: 0;
    RESIZE    :: 1;
    FREE      :: 2;
    STARTUP   :: 3;  // The allocator has never been used and is being started up for the first time. The return value will be allocator_data for the first heap.
    SHUTDOWN  :: 4;  // The allocator is being shut down and should clean up everything. After this no allocator call is legal until a new STARTUP.
    THREAD_START  :: 5;
    THREAD_STOP   :: 6;
    CREATE_HEAP   :: 7;
    DESTROY_HEAP  :: 8;
    IS_THIS_YOURS :: 9;
    CAPS          :: 10;
}

Allocator_Caps :: enum_flags u32 {
    MULTIPLE_THREADS :: 0x1;
    CREATE_HEAP      :: 0x2;
    FREE             :: 0x4;
    ACTUALLY_RESIZE  :: 0x8;
    IS_THIS_YOURS    :: 0x10;

    HINT_I_AM_A_FAST_BUMP_ALLOCATOR       :: 0x0100_0000;
    HINT_I_AM_A_GENERAL_HEAP_ALLOCATOR    :: 0x0200_0000;
    HINT_I_AM_PER_FRAME_TEMPORARY_STORAGE :: 0x0400_0000;
    HINT_I_AM_A_DEBUG_ALLOCATOR           :: 0x0800_0000;
}

Logger    :: #type (message: string, data: *void, info: Log_Info);

Log_Info :: struct {
    source_identifier:   u64;            // Identifier of the module or program sending this log message. This is entirely optional. 0 means it's unset. If you set it, maybe you pick a unique ID or a hash to use for the module.
    location:     Source_Code_Location;  // The code that logged the message.
    common_flags: Log_Flags;             // Standard flags, with a commonly-understood meaning, that the logging entity may set or ignore.
    user_flags:   u32;                   // Any application-specific or module-specific flags you want to use.
    section:      *Log_Section;
}

Log_Level :: enum u8 {
    NORMAL       :: 0;
    VERBOSE      :: 1;
    VERY_VERBOSE :: 2;
}

Log_Flags :: enum_flags u32 {
    NONE              :: 0x0;
    ERROR             :: 0x1;
    WARNING           :: 0x2;
    CONTENT           :: 0x4;   // This notification is more likely relevant to content people than programmers.
    TO_FILE_ONLY      :: 0x8;   // Log this information to non-visible targets like log files, but don't display interactively.
    VERBOSE_ONLY      :: 0x10;  // This message is VERBOSE logging output. (e.g. it can be hidden by the user in an interactive log viewer that allows the user to select log levels).
    VERY_VERBOSE_ONLY :: 0x20;  // This message is VERY_VERBOSE logging output. (e.g. it can be hidden by the user in an interactive log viewer that allows the user to select log levels).
    TOPIC_ONLY        :: 0x40;  // This message should show up in topic panel only, not on other panels
}

Log_Section :: struct {
    name:       string;
}

Stack_Trace_Procedure_Info :: struct {
    name:      string;
    location:  Source_Code_Location;

    procedure_address: *void;

    // @Incomplete: We may wish to provide the procedure type here?
    // procedure_type:    *Type_Info_Procedure;
}

Stack_Trace_Node :: struct {  // @Volatile: Must match the layout built into the compiler.
    next:        *Stack_Trace_Node;
    info:        *Stack_Trace_Procedure_Info;
    hash:        u64;
    call_depth:  u32;
    line_number: u32;
}

Dynamic_Context_Entry :: struct {
    type: Type;
    data: *void;
}

// @Volatile: Context_Base must match internal compiler settings in general.h
Context_Base :: struct {
    context_info:  *Type_Info_Struct; // Allow libs or DLLs to see what context we are passing them.

    thread_index   : u32;

    allocator      := Allocator.{__default_allocator_proc, null};

    logger         := default_logger;
    logger_data    :  *void;
    log_source_identifier: u64;      // Arbitrary identifier; settable by the main program.
    log_level      :  Log_Level;     // Settable by the main program to inform anyone who logs.

    temporary_storage: *Temporary_Storage;

    // So that we don't worry about leaking when popping a context,
    // for now we have a fixed amount of storage for Dynamic_Context.
    // This is an experimental feature for now, so we'll see how
    // it evolves.
    // Update, 15 February 2023: We would like to get rid of Dynamic_Context
    // since it probably won't be necessary for DLLs, and is generally annoying.
    // However, we still need it because otherwise plugins cannot call add_context
    // at compile-time (because the time for add_context has passed).
    // Relevant issues to modify in the compiler are: * size_of(Context) not being constant
    // until backend? Declaring Context on stack how -- is there a secret max size, or do we
    // disallow it (if the latter, the way we currently use push_context is no good?)
    // Or do we use an alloca for it? The problem is we may need to call the same function
    // several times as we add stuff. Do we rebuild the bytecode? (ugh... but we could).
    // What about type_info(Context), do we change that incrementally or just block
    // that query until later, or ... ???
    dynamic_entries: [16] Dynamic_Context_Entry;
    num_dynamic_entries: s32;

    // Note: We don't #if this out right now when _STACK_TRACE is false, because
    // _STACK_TRACE gets added after the Preload is loaded, for implementation detail
    // reasons. We could change this eventually, but in the meantime, you just can't
    // use _STACK_TRACE in the Preload at all. So if _STACK_TRACE is false, this pointer
    // will still exist in the context, but it will stay null.
    stack_trace: *Stack_Trace_Node;

    assertion_failed := default_assertion_failed;
    handling_assertion_failure := false;  // Used to avoid assert() infinite loops. Do not mess with this value.

    // Constants that don't take up any space, but may be useful to your program:
    default_logger           :: (message: string, data: *void, info: Log_Info) { runtime_support_default_logger :: (message: string, data: *void, info: Log_Info) #runtime_support; runtime_support_default_logger(message, data, info); }  // We'd like to just put default logger here, but can't because string dereference is not set up yet!

    default_assertion_failed :: (loc: Source_Code_Location, message: string) { runtime_support_assertion_failed :: (loc: Source_Code_Location, message: string) #runtime_support; runtime_support_assertion_failed(loc, message); } // @Cleanup ... can I not just go default_assertion_failed :: runtime_support_assertion_failed?
    default_allocator        :: Allocator.{__default_allocator_proc, null};
}

#add_context using base: Context_Base;

__default_allocator_proc :: (mode: Allocator_Mode, size: s64, old_size: s64, old_memory_pointer: *void, allocator_data: *void) -> *void {
    // @Temporary: This bridge is just here to deal with some problem involving #runtime_support procedure pointers not being handled
    // correctly by the backends. Once that is fixed, this can be removed.
    // :RuntimeSupportCleanup
    runtime_support_default_allocator_proc :: (mode: Allocator_Mode, size: s64, old_size: s64, old_memory_pointer: *void, allocator_data: *void) -> *void #runtime_support;
    return runtime_support_default_allocator_proc(mode, size, old_size, old_memory_pointer, allocator_data);
}

Temporary_Storage :: struct {  // @Volatile: Must match general.h
    data:     *u8;
    size:     s64;
    current_page_bytes_occupied: s64;
    total_bytes_occupied: s64;
    high_water_mark: s64;
    last_set_mark_location: Source_Code_Location;

    overflow_allocator := Allocator.{__default_allocator_proc, null};

    overflow_pages: *Overflow_Page;
    original_data: *u8;  // Data to restore after clearing overflow pages. @Simplify: Maybe could be an Overflow_Page, but maybe we want to be able to assert on overflow_pages==null to ensure performance.
    original_size: s64;

    Overflow_Page :: struct {
        next: *Overflow_Page;
        allocator: Allocator;
        size: s64;
    }
}

set_initial_data :: (ts: *Temporary_Storage, count: s64, data: *u8) #no_context {
    ts.data = data;
    ts.size = count;

    ts.original_data = data;
    ts.original_size = count;
}

__command_line_arguments: [] *u8;
__runtime_support_disable_stack_trace := false;  // If set to true, the exception handlers in Runtime_Support_* will not do anything; use this if you are doing a controlled exit that already reports what's going on, such as an assertion failure. You can then call abort() or whatever and not get a redundant stack trace.

Source_Code_Location :: struct {
    fully_pathed_filename:  string;
    line_number:            s64;
    character_number:       s64;
}

Source_Code_Range :: struct {
    fully_pathed_filename:  string;
    line_number_start:      s64;
    line_number_end:        s64;
    character_number_start: s64;
    character_number_end:   s64;
}

get_current_workspace :: () -> Workspace #compiler {
    // If calling this at runtime, we just return 0.
    // You might think we want to assert, but stuff
    // like thread_create calls this and doesn't think
    // about whether it's compile-time or not, and maybe
    // that is more convenient.

    return cast(Workspace) 0;
}

memcpy :: (dest: *void, source: *void, count: s64) #intrinsic;
// memcmp :: (a: *void, b: *void, count: s64) -> s16  #intrinsic;  // @Incomplete: Do we want to tell people how many bytes in the first difference is?  // @Incomplete: The C spec for this routine sucks; we should probably return the actual byte difference. But the bytecode_runner version uses the C library version which just returns <=>0. I don't really want to inherit this ill-defined version. Unless we think it really doesn't matter. I dunno.
memset :: (dest: *void, value: u8, count: s64)     #intrinsic;

compile_time_debug_break :: () #compiler #no_context;  // For now this needs to be at global scope so the compiler can find it. Later we could look at making it local.

debug_break :: () #expand #no_context #no_debug {
    if #compile_time {
        compile_time_debug_break();
    } else {
        // Break into the debugger, or stop the running process.
        #if OS == .PS5 {
            #asm { int 0x41; }
        } else #if CPU == .X64 {
            #asm { int3; }
        } else {
            trap :: () #intrinsic "llvm.trap"; // @ToDo: Maybe use debugtrap?
            trap();
        }
    }
}


write_string  :: (s: string, to_standard_error := false)         #runtime_support #no_context;
write_strings :: (strings: ..string, to_standard_error := false) #runtime_support #no_context;

write_number  :: (n: s64, base := 10, to_standard_error := false)            #runtime_support #no_context;
write_nonnegative_number :: (n: u64, base := 10, to_standard_error := false) #runtime_support #no_context;

to_string :: (c_string: *u8) -> string #runtime_support #no_context;
c_style_strlen :: (x: *u8) -> s64 #runtime_support #no_context;

// For_Flags is used in for_expansions.
For_Flags :: enum_flags u8 {
    POINTER :: 0x1;
    REVERSE :: 0x2;
}


// Rather than declaring these structs here, we could have the compiler
// do its own hardcoded thing internally so it doesn't require these declarations.
// I dunno man!

Procedure_With_Data :: struct {
    proc      : *void;
    data      : *void;
}

Newstring    :: struct {
    count     : s64;  // Signed so that if we do for 0..count-1 it works...
    data      : *u8;
}

Array_View_64 :: struct {
    count     : s64;  // Signed so that if we do for 0..count-1 it works...
    data      : *u8;
}

// Resizable_Array is used by the compiler internally.
// Print in modules/Basic also uses this definition,
// because hey, while it's here, why not.
Resizable_Array :: struct {
    count      : s64;  // Signed so that if we do for 0..count-1 it works...
    data       : *void;
    allocated  : s64;

    allocator  : Allocator;  // This contains two pointers, .proc and .data, for a total of 16 bytes.
}

Name_Mapper :: #type ([] string);

// The below routines are ony here because Runtime_Support is not visible to name searches.
// We probably should export some stuff from there, and then these can go back into Runtime_Support.
one_time_init :: (synch_value: *s32, to_insert: Code) #expand {
    // A routine to run the code in 'to_insert' only once, even if
    // there are multiple threads. <<synch_value should be 0 at startup.

    // The values of <<synch_value:
    // 0 = uninitialized, 1 = in progress init, 2 = initialized.

    // Courtesy of Jeff Roberts.

    while 1 {
        // @Warning: Apparently this read may not work on ARM, we need to look into it.
        // The goal here is just to avoid the overhead of spamming the compare_and_swap.
        if (<< synch_value) == 2  break;

        old := preload_compare_and_swap(synch_value, 0, 1);
        if old == {
          case 0;
            #insert to_insert;

            if preload_compare_and_swap(synch_value, 1, 2) != 1  debug_break();  // Should not happen!
          case 1;
            // Maybe some exponential fall offy thing here?
            for 1..4 #asm { pause; pause; pause; pause; pause; }
          case 2;
        }
    }
}

// We don't want to take a dependency on Atomics, so here is a simple one that just does s32.
preload_compare_and_swap :: (dest: *s32, old: s32, new: s32) -> (actual_old_value: s32) #no_context {
    #asm {
        old === a;
        lock_cmpxchg.d old, [dest], new;
    }

    return old;
}

