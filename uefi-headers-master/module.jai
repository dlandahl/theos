//
// This file was auto-generated using the following command:
//
// jai generate.jai
//



MAX_BIT :: 0x8000000000000000;

MAX_2_BITS :: 0xC000000000000000;

MAX_ADDRESS :: 0xFFFFFFFFFFFFFFFF;

MAX_INTN :: cast(INTN)0x7FFFFFFFFFFFFFFF;
MAX_UINTN :: cast(UINTN)0xFFFFFFFFFFFFFFFF;

MIN_INTN :: (cast,trunc(INTN)-9223372036854775807) - 1;

CPU_STACK_ALIGNMENT :: 16;

DEFAULT_PAGE_ALLOCATION_GRANULARITY :: 0x1000;
RUNTIME_PAGE_ALLOCATION_GRANULARITY :: 0x1000;

TRUE :: cast(BOOLEAN)(1==1);

FALSE :: cast(BOOLEAN)(0==1);

CHAR_NULL :: 0x0000;

MAX_INT8 :: cast(s8)0x7F;
MAX_UINT8 :: cast(u8)0xFF;
MAX_INT16 :: cast(s16)0x7FFF;
MAX_UINT16 :: cast(u16)0xFFFF;
MAX_INT32 :: cast(s32)0x7FFFFFFF;
MAX_UINT32 :: cast(u32)0xFFFFFFFF;
MAX_INT64 :: cast(s64)0x7FFFFFFFFFFFFFFF;
MAX_UINT64 :: cast(u64)0xFFFFFFFFFFFFFFFF;

MIN_INT8 :: (cast,trunc(s8) -127) - 1;
MIN_INT16 :: (cast,trunc(s16) -32767) - 1;
MIN_INT32 :: (cast,trunc(s32) -2147483647) - 1;
MIN_INT64 :: (cast,trunc(s64) -9223372036854775807) - 1;

BIT0 :: 0x00000001;
BIT1 :: 0x00000002;
BIT2 :: 0x00000004;
BIT3 :: 0x00000008;
BIT4 :: 0x00000010;
BIT5 :: 0x00000020;
BIT6 :: 0x00000040;
BIT7 :: 0x00000080;
BIT8 :: 0x00000100;
BIT9 :: 0x00000200;
BIT10 :: 0x00000400;
BIT11 :: 0x00000800;
BIT12 :: 0x00001000;
BIT13 :: 0x00002000;
BIT14 :: 0x00004000;
BIT15 :: 0x00008000;
BIT16 :: 0x00010000;
BIT17 :: 0x00020000;
BIT18 :: 0x00040000;
BIT19 :: 0x00080000;
BIT20 :: 0x00100000;
BIT21 :: 0x00200000;
BIT22 :: 0x00400000;
BIT23 :: 0x00800000;
BIT24 :: 0x01000000;
BIT25 :: 0x02000000;
BIT26 :: 0x04000000;
BIT27 :: 0x08000000;
BIT28 :: 0x10000000;
BIT29 :: 0x20000000;
BIT30 :: 0x40000000;
BIT31 :: 0x80000000;
BIT32 :: 0x0000000100000000;
BIT33 :: 0x0000000200000000;
BIT34 :: 0x0000000400000000;
BIT35 :: 0x0000000800000000;
BIT36 :: 0x0000001000000000;
BIT37 :: 0x0000002000000000;
BIT38 :: 0x0000004000000000;
BIT39 :: 0x0000008000000000;
BIT40 :: 0x0000010000000000;
BIT41 :: 0x0000020000000000;
BIT42 :: 0x0000040000000000;
BIT43 :: 0x0000080000000000;
BIT44 :: 0x0000100000000000;
BIT45 :: 0x0000200000000000;
BIT46 :: 0x0000400000000000;
BIT47 :: 0x0000800000000000;
BIT48 :: 0x0001000000000000;
BIT49 :: 0x0002000000000000;
BIT50 :: 0x0004000000000000;
BIT51 :: 0x0008000000000000;
BIT52 :: 0x0010000000000000;
BIT53 :: 0x0020000000000000;
BIT54 :: 0x0040000000000000;
BIT55 :: 0x0080000000000000;
BIT56 :: 0x0100000000000000;
BIT57 :: 0x0200000000000000;
BIT58 :: 0x0400000000000000;
BIT59 :: 0x0800000000000000;
BIT60 :: 0x1000000000000000;
BIT61 :: 0x2000000000000000;
BIT62 :: 0x4000000000000000;
BIT63 :: 0x8000000000000000;

SIZE_1KB :: 0x00000400;
SIZE_2KB :: 0x00000800;
SIZE_4KB :: 0x00001000;
SIZE_8KB :: 0x00002000;
SIZE_16KB :: 0x00004000;
SIZE_32KB :: 0x00008000;
SIZE_64KB :: 0x00010000;
SIZE_128KB :: 0x00020000;
SIZE_256KB :: 0x00040000;
SIZE_512KB :: 0x00080000;
SIZE_1MB :: 0x00100000;
SIZE_2MB :: 0x00200000;
SIZE_4MB :: 0x00400000;
SIZE_8MB :: 0x00800000;
SIZE_16MB :: 0x01000000;
SIZE_32MB :: 0x02000000;
SIZE_64MB :: 0x04000000;
SIZE_128MB :: 0x08000000;
SIZE_256MB :: 0x10000000;
SIZE_512MB :: 0x20000000;
SIZE_1GB :: 0x40000000;
SIZE_2GB :: 0x80000000;
SIZE_4GB :: 0x0000000100000000;
SIZE_8GB :: 0x0000000200000000;
SIZE_16GB :: 0x0000000400000000;
SIZE_32GB :: 0x0000000800000000;
SIZE_64GB :: 0x0000001000000000;
SIZE_128GB :: 0x0000002000000000;
SIZE_256GB :: 0x0000004000000000;
SIZE_512GB :: 0x0000008000000000;
SIZE_1TB :: 0x0000010000000000;
SIZE_2TB :: 0x0000020000000000;
SIZE_4TB :: 0x0000040000000000;
SIZE_8TB :: 0x0000080000000000;
SIZE_16TB :: 0x0000100000000000;
SIZE_32TB :: 0x0000200000000000;
SIZE_64TB :: 0x0000400000000000;
SIZE_128TB :: 0x0000800000000000;
SIZE_256TB :: 0x0001000000000000;
SIZE_512TB :: 0x0002000000000000;
SIZE_1PB :: 0x0004000000000000;
SIZE_2PB :: 0x0008000000000000;
SIZE_4PB :: 0x0010000000000000;
SIZE_8PB :: 0x0020000000000000;
SIZE_16PB :: 0x0040000000000000;
SIZE_32PB :: 0x0080000000000000;
SIZE_64PB :: 0x0100000000000000;
SIZE_128PB :: 0x0200000000000000;
SIZE_256PB :: 0x0400000000000000;
SIZE_512PB :: 0x0800000000000000;
SIZE_1EB :: 0x1000000000000000;
SIZE_2EB :: 0x2000000000000000;
SIZE_4EB :: 0x4000000000000000;
SIZE_8EB :: 0x8000000000000000;

BASE_1KB :: 0x00000400;
BASE_2KB :: 0x00000800;
BASE_4KB :: 0x00001000;
BASE_8KB :: 0x00002000;
BASE_16KB :: 0x00004000;
BASE_32KB :: 0x00008000;
BASE_64KB :: 0x00010000;
BASE_128KB :: 0x00020000;
BASE_256KB :: 0x00040000;
BASE_512KB :: 0x00080000;
BASE_1MB :: 0x00100000;
BASE_2MB :: 0x00200000;
BASE_4MB :: 0x00400000;
BASE_8MB :: 0x00800000;
BASE_16MB :: 0x01000000;
BASE_32MB :: 0x02000000;
BASE_64MB :: 0x04000000;
BASE_128MB :: 0x08000000;
BASE_256MB :: 0x10000000;
BASE_512MB :: 0x20000000;
BASE_1GB :: 0x40000000;
BASE_2GB :: 0x80000000;
BASE_4GB :: 0x0000000100000000;
BASE_8GB :: 0x0000000200000000;
BASE_16GB :: 0x0000000400000000;
BASE_32GB :: 0x0000000800000000;
BASE_64GB :: 0x0000001000000000;
BASE_128GB :: 0x0000002000000000;
BASE_256GB :: 0x0000004000000000;
BASE_512GB :: 0x0000008000000000;
BASE_1TB :: 0x0000010000000000;
BASE_2TB :: 0x0000020000000000;
BASE_4TB :: 0x0000040000000000;
BASE_8TB :: 0x0000080000000000;
BASE_16TB :: 0x0000100000000000;
BASE_32TB :: 0x0000200000000000;
BASE_64TB :: 0x0000400000000000;
BASE_128TB :: 0x0000800000000000;
BASE_256TB :: 0x0001000000000000;
BASE_512TB :: 0x0002000000000000;
BASE_1PB :: 0x0004000000000000;
BASE_2PB :: 0x0008000000000000;
BASE_4PB :: 0x0010000000000000;
BASE_8PB :: 0x0020000000000000;
BASE_16PB :: 0x0040000000000000;
BASE_32PB :: 0x0080000000000000;
BASE_64PB :: 0x0100000000000000;
BASE_128PB :: 0x0200000000000000;
BASE_256PB :: 0x0400000000000000;
BASE_512PB :: 0x0800000000000000;
BASE_1EB :: 0x1000000000000000;
BASE_2EB :: 0x2000000000000000;
BASE_4EB :: 0x4000000000000000;
BASE_8EB :: 0x8000000000000000;

RETURN_SUCCESS :: 0;

EFI_SUCCESS :: RETURN_SUCCESS;

EFI_PAGE_SIZE :: SIZE_4KB;
EFI_PAGE_MASK :: 0xFFF;
EFI_PAGE_SHIFT :: 12;

EFI_IMAGE_MACHINE_IA32 :: 0x014C;

EFI_IMAGE_MACHINE_IA64 :: 0x0200;

EFI_IMAGE_MACHINE_EBC :: 0x0EBC;

EFI_IMAGE_MACHINE_X64 :: 0x8664;

EFI_IMAGE_MACHINE_ARMTHUMB_MIXED :: 0x01C2;

EFI_IMAGE_MACHINE_AARCH64 :: 0xAA64;

EFI_VARIABLE_NON_VOLATILE :: 0x00000001;
EFI_VARIABLE_BOOTSERVICE_ACCESS :: 0x00000002;
EFI_VARIABLE_RUNTIME_ACCESS :: 0x00000004;

EFI_VARIABLE_HARDWARE_ERROR_RECORD :: 0x00000008;

EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS :: 0x00000020;
EFI_VARIABLE_APPEND_WRITE :: 0x00000040;

EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS :: 0x00000010;

WIN_CERT_TYPE_PKCS_SIGNED_DATA :: 0x0002;
WIN_CERT_TYPE_EFI_PKCS115 :: 0x0EF0;
WIN_CERT_TYPE_EFI_GUID :: 0x0EF1;

BLUETOOTH_HCI_COMMAND_LOCAL_READABLE_NAME_MAX_SIZE :: 248;

BLUETOOTH_HCI_LINK_KEY_SIZE :: 16;

AML_ZERO_OP :: 0x00;
AML_ONE_OP :: 0x01;
AML_ALIAS_OP :: 0x06;
AML_NAME_OP :: 0x08;
AML_BYTE_PREFIX :: 0x0a;
AML_WORD_PREFIX :: 0x0b;
AML_DWORD_PREFIX :: 0x0c;
AML_STRING_PREFIX :: 0x0d;
AML_QWORD_PREFIX :: 0x0e;
AML_SCOPE_OP :: 0x10;
AML_BUFFER_OP :: 0x11;
AML_PACKAGE_OP :: 0x12;
AML_VAR_PACKAGE_OP :: 0x13;
AML_METHOD_OP :: 0x14;
AML_DUAL_NAME_PREFIX :: 0x2e;
AML_MULTI_NAME_PREFIX :: 0x2f;
AML_NAME_CHAR_A :: 0x41;
AML_NAME_CHAR_B :: 0x42;
AML_NAME_CHAR_C :: 0x43;
AML_NAME_CHAR_D :: 0x44;
AML_NAME_CHAR_E :: 0x45;
AML_NAME_CHAR_F :: 0x46;
AML_NAME_CHAR_G :: 0x47;
AML_NAME_CHAR_H :: 0x48;
AML_NAME_CHAR_I :: 0x49;
AML_NAME_CHAR_J :: 0x4a;
AML_NAME_CHAR_K :: 0x4b;
AML_NAME_CHAR_L :: 0x4c;
AML_NAME_CHAR_M :: 0x4d;
AML_NAME_CHAR_N :: 0x4e;
AML_NAME_CHAR_O :: 0x4f;
AML_NAME_CHAR_P :: 0x50;
AML_NAME_CHAR_Q :: 0x51;
AML_NAME_CHAR_R :: 0x52;
AML_NAME_CHAR_S :: 0x53;
AML_NAME_CHAR_T :: 0x54;
AML_NAME_CHAR_U :: 0x55;
AML_NAME_CHAR_V :: 0x56;
AML_NAME_CHAR_W :: 0x57;
AML_NAME_CHAR_X :: 0x58;
AML_NAME_CHAR_Y :: 0x59;
AML_NAME_CHAR_Z :: 0x5a;
AML_ROOT_CHAR :: 0x5c;
AML_PARENT_PREFIX_CHAR :: 0x5e;
AML_NAME_CHAR__ :: 0x5f;
AML_LOCAL0 :: 0x60;
AML_LOCAL1 :: 0x61;
AML_LOCAL2 :: 0x62;
AML_LOCAL3 :: 0x63;
AML_LOCAL4 :: 0x64;
AML_LOCAL5 :: 0x65;
AML_LOCAL6 :: 0x66;
AML_LOCAL7 :: 0x67;
AML_ARG0 :: 0x68;
AML_ARG1 :: 0x69;
AML_ARG2 :: 0x6a;
AML_ARG3 :: 0x6b;
AML_ARG4 :: 0x6c;
AML_ARG5 :: 0x6d;
AML_ARG6 :: 0x6e;
AML_STORE_OP :: 0x70;
AML_REF_OF_OP :: 0x71;
AML_ADD_OP :: 0x72;
AML_CONCAT_OP :: 0x73;
AML_SUBTRACT_OP :: 0x74;
AML_INCREMENT_OP :: 0x75;
AML_DECREMENT_OP :: 0x76;
AML_MULTIPLY_OP :: 0x77;
AML_DIVIDE_OP :: 0x78;
AML_SHIFT_LEFT_OP :: 0x79;
AML_SHIFT_RIGHT_OP :: 0x7a;
AML_AND_OP :: 0x7b;
AML_NAND_OP :: 0x7c;
AML_OR_OP :: 0x7d;
AML_NOR_OP :: 0x7e;
AML_XOR_OP :: 0x7f;
AML_NOT_OP :: 0x80;
AML_FIND_SET_LEFT_BIT_OP :: 0x81;
AML_FIND_SET_RIGHT_BIT_OP :: 0x82;
AML_DEREF_OF_OP :: 0x83;
AML_CONCAT_RES_OP :: 0x84;
AML_MOD_OP :: 0x85;
AML_NOTIFY_OP :: 0x86;
AML_SIZE_OF_OP :: 0x87;
AML_INDEX_OP :: 0x88;
AML_MATCH_OP :: 0x89;
AML_CREATE_DWORD_FIELD_OP :: 0x8a;
AML_CREATE_WORD_FIELD_OP :: 0x8b;
AML_CREATE_BYTE_FIELD_OP :: 0x8c;
AML_CREATE_BIT_FIELD_OP :: 0x8d;
AML_OBJECT_TYPE_OP :: 0x8e;
AML_CREATE_QWORD_FIELD_OP :: 0x8f;
AML_LAND_OP :: 0x90;
AML_LOR_OP :: 0x91;
AML_LNOT_OP :: 0x92;
AML_LEQUAL_OP :: 0x93;
AML_LGREATER_OP :: 0x94;
AML_LLESS_OP :: 0x95;
AML_TO_BUFFER_OP :: 0x96;
AML_TO_DEC_STRING_OP :: 0x97;
AML_TO_HEX_STRING_OP :: 0x98;
AML_TO_INTEGER_OP :: 0x99;
AML_TO_STRING_OP :: 0x9c;
AML_COPY_OBJECT_OP :: 0x9d;
AML_MID_OP :: 0x9e;
AML_CONTINUE_OP :: 0x9f;
AML_IF_OP :: 0xa0;
AML_ELSE_OP :: 0xa1;
AML_WHILE_OP :: 0xa2;
AML_NOOP_OP :: 0xa3;
AML_RETURN_OP :: 0xa4;
AML_BREAK_OP :: 0xa5;
AML_BREAK_POINT_OP :: 0xcc;
AML_ONES_OP :: 0xff;

AML_EXT_OP :: 0x5b;

AML_EXT_MUTEX_OP :: 0x01;
AML_EXT_EVENT_OP :: 0x02;
AML_EXT_COND_REF_OF_OP :: 0x12;
AML_EXT_CREATE_FIELD_OP :: 0x13;
AML_EXT_LOAD_TABLE_OP :: 0x1f;
AML_EXT_LOAD_OP :: 0x20;
AML_EXT_STALL_OP :: 0x21;
AML_EXT_SLEEP_OP :: 0x22;
AML_EXT_ACQUIRE_OP :: 0x23;
AML_EXT_SIGNAL_OP :: 0x24;
AML_EXT_WAIT_OP :: 0x25;
AML_EXT_RESET_OP :: 0x26;
AML_EXT_RELEASE_OP :: 0x27;
AML_EXT_FROM_BCD_OP :: 0x28;
AML_EXT_TO_BCD_OP :: 0x29;
AML_EXT_UNLOAD_OP :: 0x2a;
AML_EXT_REVISION_OP :: 0x30;
AML_EXT_DEBUG_OP :: 0x31;
AML_EXT_FATAL_OP :: 0x32;
AML_EXT_TIMER_OP :: 0x33;
AML_EXT_REGION_OP :: 0x80;
AML_EXT_FIELD_OP :: 0x81;
AML_EXT_DEVICE_OP :: 0x82;
AML_EXT_PROCESSOR_OP :: 0x83;
AML_EXT_POWER_RES_OP :: 0x84;
AML_EXT_THERMAL_ZONE_OP :: 0x85;
AML_EXT_INDEX_FIELD_OP :: 0x86;
AML_EXT_BANK_FIELD_OP :: 0x87;
AML_EXT_DATA_REGION_OP :: 0x88;

ACPI_SMALL_ITEM_FLAG :: 0x00;
ACPI_LARGE_ITEM_FLAG :: 0x01;

ACPI_SMALL_IRQ_DESCRIPTOR_NAME :: 0x04;
ACPI_SMALL_DMA_DESCRIPTOR_NAME :: 0x05;
ACPI_SMALL_START_DEPENDENT_DESCRIPTOR_NAME :: 0x06;
ACPI_SMALL_END_DEPENDENT_DESCRIPTOR_NAME :: 0x07;
ACPI_SMALL_IO_PORT_DESCRIPTOR_NAME :: 0x08;
ACPI_SMALL_FIXED_IO_PORT_DESCRIPTOR_NAME :: 0x09;
ACPI_SMALL_VENDOR_DEFINED_DESCRIPTOR_NAME :: 0x0E;
ACPI_SMALL_END_TAG_DESCRIPTOR_NAME :: 0x0F;

ACPI_LARGE_24_BIT_MEMORY_RANGE_DESCRIPTOR_NAME :: 0x01;
ACPI_LARGE_VENDOR_DEFINED_DESCRIPTOR_NAME :: 0x04;
ACPI_LARGE_32_BIT_MEMORY_RANGE_DESCRIPTOR_NAME :: 0x05;
ACPI_LARGE_32_BIT_FIXED_MEMORY_RANGE_DESCRIPTOR_NAME :: 0x06;
ACPI_LARGE_DWORD_ADDRESS_SPACE_DESCRIPTOR_NAME :: 0x07;
ACPI_LARGE_WORD_ADDRESS_SPACE_DESCRIPTOR_NAME :: 0x08;
ACPI_LARGE_EXTENDED_IRQ_DESCRIPTOR_NAME :: 0x09;
ACPI_LARGE_QWORD_ADDRESS_SPACE_DESCRIPTOR_NAME :: 0x0A;

ACPI_IRQ_NOFLAG_DESCRIPTOR :: 0x22;
ACPI_IRQ_DESCRIPTOR :: 0x23;
ACPI_DMA_DESCRIPTOR :: 0x2A;
ACPI_START_DEPENDENT_DESCRIPTOR :: 0x30;
ACPI_START_DEPENDENT_EX_DESCRIPTOR :: 0x31;
ACPI_END_DEPENDENT_DESCRIPTOR :: 0x38;
ACPI_IO_PORT_DESCRIPTOR :: 0x47;
ACPI_FIXED_LOCATION_IO_PORT_DESCRIPTOR :: 0x4B;
ACPI_END_TAG_DESCRIPTOR :: 0x79;

ACPI_24_BIT_MEMORY_RANGE_DESCRIPTOR :: 0x81;
ACPI_32_BIT_MEMORY_RANGE_DESCRIPTOR :: 0x85;
ACPI_32_BIT_FIXED_MEMORY_RANGE_DESCRIPTOR :: 0x86;
ACPI_DWORD_ADDRESS_SPACE_DESCRIPTOR :: 0x87;
ACPI_WORD_ADDRESS_SPACE_DESCRIPTOR :: 0x88;
ACPI_EXTENDED_INTERRUPT_DESCRIPTOR :: 0x89;
ACPI_QWORD_ADDRESS_SPACE_DESCRIPTOR :: 0x8A;
ACPI_ADDRESS_SPACE_DESCRIPTOR :: 0x8A;

ACPI_ADDRESS_SPACE_TYPE_MEM :: 0x00;
ACPI_ADDRESS_SPACE_TYPE_IO :: 0x01;
ACPI_ADDRESS_SPACE_TYPE_BUS :: 0x02;

ACPI_TIMER_FREQUENCY :: 3579545;

EFI_ACPI_RESERVED_BYTE :: 0x00;
EFI_ACPI_RESERVED_WORD :: 0x0000;
EFI_ACPI_RESERVED_DWORD :: 0x00000000;
EFI_ACPI_RESERVED_QWORD :: 0x0000000000000000;

EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_READ_WRITE :: 1 << 0;
EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_READ_ONLY :: 0 << 0;

EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_NON_CACHEABLE :: 0 << 1;
EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_CACHEABLE :: 1 << 1;
EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_CACHEABLE_WRITE_COMBINING :: 2 << 1;
EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_CACHEABLE_PREFETCHABLE :: 3 << 1;

EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_MEMORY :: 0 << 3;
EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_RESERVED :: 1 << 3;
EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_ACPI :: 2 << 3;
EFI_APCI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_NVS :: 3 << 3;

EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_TYPE_TRANSLATION :: 1 << 5;
EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_TYPE_STATIC :: 0 << 5;

EFI_ACPI_IRQ_SHARABLE_MASK :: 0x10;
EFI_ACPI_IRQ_SHARABLE :: 0x10;

EFI_ACPI_IRQ_POLARITY_MASK :: 0x08;
EFI_ACPI_IRQ_HIGH_TRUE :: 0x00;
EFI_ACPI_IRQ_LOW_FALSE :: 0x08;

EFI_ACPI_IRQ_MODE :: 0x01;
EFI_ACPI_IRQ_LEVEL_TRIGGERED :: 0x00;
EFI_ACPI_IRQ_EDGE_TRIGGERED :: 0x01;

EFI_ACPI_DMA_SPEED_TYPE_MASK :: 0x60;
EFI_ACPI_DMA_SPEED_TYPE_COMPATIBILITY :: 0x00;
EFI_ACPI_DMA_SPEED_TYPE_A :: 0x20;
EFI_ACPI_DMA_SPEED_TYPE_B :: 0x40;
EFI_ACPI_DMA_SPEED_TYPE_F :: 0x60;

EFI_ACPI_DMA_BUS_MASTER_MASK :: 0x04;
EFI_ACPI_DMA_BUS_MASTER :: 0x04;

EFI_ACPI_DMA_TRANSFER_TYPE_MASK :: 0x03;
EFI_ACPI_DMA_TRANSFER_TYPE_8_BIT :: 0x00;
EFI_ACPI_DMA_TRANSFER_TYPE_8_BIT_AND_16_BIT :: 0x01;
EFI_ACPI_DMA_TRANSFER_TYPE_16_BIT :: 0x10;

EFI_ACPI_IO_DECODE_MASK :: 0x01;
EFI_ACPI_IO_DECODE_16_BIT :: 0x01;
EFI_ACPI_IO_DECODE_10_BIT :: 0x00;

EFI_ACPI_MEMORY_WRITE_STATUS_MASK :: 0x01;
EFI_ACPI_MEMORY_WRITABLE :: 0x01;
EFI_ACPI_MEMORY_NON_WRITABLE :: 0x00;

EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_1_0_INT_MODE_DUAL_PIC :: 0;
EFI_ACPI_1_0_INT_MODE_MULTIPLE_APIC :: 1;

EFI_ACPI_1_0_WBINVD :: BIT0;
EFI_ACPI_1_0_WBINVD_FLUSH :: BIT1;
EFI_ACPI_1_0_PROC_C1 :: BIT2;
EFI_ACPI_1_0_P_LVL2_UP :: BIT3;
EFI_ACPI_1_0_PWR_BUTTON :: BIT4;
EFI_ACPI_1_0_SLP_BUTTON :: BIT5;
EFI_ACPI_1_0_FIX_RTC :: BIT6;
EFI_ACPI_1_0_RTC_S4 :: BIT7;
EFI_ACPI_1_0_TMR_VAL_EXT :: BIT8;
EFI_ACPI_1_0_DCK_CAP :: BIT9;

EFI_ACPI_1_0_S4BIOS_F :: BIT0;

EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_1_0_PCAT_COMPAT :: BIT0;

EFI_ACPI_1_0_PROCESSOR_LOCAL_APIC :: 0x00;
EFI_ACPI_1_0_IO_APIC :: 0x01;
EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE :: 0x02;
EFI_ACPI_1_0_NON_MASKABLE_INTERRUPT_SOURCE :: 0x03;
EFI_ACPI_1_0_LOCAL_APIC_NMI :: 0x04;

EFI_ACPI_1_0_LOCAL_APIC_ENABLED :: BIT0;

ACPI_LARGE_GENERIC_REGISTER_DESCRIPTOR_NAME :: 0x02;

ACPI_GENERIC_REGISTER_DESCRIPTOR :: 0x82;

EFI_ACPI_2_0_SYSTEM_MEMORY :: 0;
EFI_ACPI_2_0_SYSTEM_IO :: 1;
EFI_ACPI_2_0_PCI_CONFIGURATION_SPACE :: 2;
EFI_ACPI_2_0_EMBEDDED_CONTROLLER :: 3;
EFI_ACPI_2_0_SMBUS :: 4;
EFI_ACPI_2_0_FUNCTIONAL_FIXED_HARDWARE :: 0x7F;

EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION :: 0x02;

EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_2_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION :: 0x03;

EFI_ACPI_2_0_PM_PROFILE_UNSPECIFIED :: 0;
EFI_ACPI_2_0_PM_PROFILE_DESKTOP :: 1;
EFI_ACPI_2_0_PM_PROFILE_MOBILE :: 2;
EFI_ACPI_2_0_PM_PROFILE_WORKSTATION :: 3;
EFI_ACPI_2_0_PM_PROFILE_ENTERPRISE_SERVER :: 4;
EFI_ACPI_2_0_PM_PROFILE_SOHO_SERVER :: 5;
EFI_ACPI_2_0_PM_PROFILE_APPLIANCE_PC :: 6;

EFI_ACPI_2_0_LEGACY_DEVICES :: BIT0;
EFI_ACPI_2_0_8042 :: BIT1;

EFI_ACPI_2_0_WBINVD :: BIT0;
EFI_ACPI_2_0_WBINVD_FLUSH :: BIT1;
EFI_ACPI_2_0_PROC_C1 :: BIT2;
EFI_ACPI_2_0_P_LVL2_UP :: BIT3;
EFI_ACPI_2_0_PWR_BUTTON :: BIT4;
EFI_ACPI_2_0_SLP_BUTTON :: BIT5;
EFI_ACPI_2_0_FIX_RTC :: BIT6;
EFI_ACPI_2_0_RTC_S4 :: BIT7;
EFI_ACPI_2_0_TMR_VAL_EXT :: BIT8;
EFI_ACPI_2_0_DCK_CAP :: BIT9;
EFI_ACPI_2_0_RESET_REG_SUP :: BIT10;
EFI_ACPI_2_0_SEALED_CASE :: BIT11;
EFI_ACPI_2_0_HEADLESS :: BIT12;
EFI_ACPI_2_0_CPU_SW_SLP :: BIT13;

EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION :: 0x01;

EFI_ACPI_2_0_S4BIOS_F :: BIT0;

EFI_ACPI_2_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_2_0_PCAT_COMPAT :: BIT0;

EFI_ACPI_2_0_PROCESSOR_LOCAL_APIC :: 0x00;
EFI_ACPI_2_0_IO_APIC :: 0x01;
EFI_ACPI_2_0_INTERRUPT_SOURCE_OVERRIDE :: 0x02;
EFI_ACPI_2_0_NON_MASKABLE_INTERRUPT_SOURCE :: 0x03;
EFI_ACPI_2_0_LOCAL_APIC_NMI :: 0x04;
EFI_ACPI_2_0_LOCAL_APIC_ADDRESS_OVERRIDE :: 0x05;
EFI_ACPI_2_0_IO_SAPIC :: 0x06;
EFI_ACPI_2_0_PROCESSOR_LOCAL_SAPIC :: 0x07;
EFI_ACPI_2_0_PLATFORM_INTERRUPT_SOURCES :: 0x08;

EFI_ACPI_2_0_LOCAL_APIC_ENABLED :: BIT0;

EFI_ACPI_2_0_SMART_BATTERY_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_2_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION :: 0x01;

ACPI_LARGE_EXTENDED_ADDRESS_SPACE_DESCRIPTOR_NAME :: 0x0B;

ACPI_EXTENDED_ADDRESS_SPACE_DESCRIPTOR :: 0x8B;

EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_UC :: 0x0000000000000001;
EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_WC :: 0x0000000000000002;
EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_WT :: 0x0000000000000004;
EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_WB :: 0x0000000000000008;
EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_UCE :: 0x0000000000000010;
EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_NV :: 0x0000000000008000;

EFI_ACPI_3_0_SYSTEM_MEMORY :: 0;
EFI_ACPI_3_0_SYSTEM_IO :: 1;
EFI_ACPI_3_0_PCI_CONFIGURATION_SPACE :: 2;
EFI_ACPI_3_0_EMBEDDED_CONTROLLER :: 3;
EFI_ACPI_3_0_SMBUS :: 4;
EFI_ACPI_3_0_FUNCTIONAL_FIXED_HARDWARE :: 0x7F;

EFI_ACPI_3_0_UNDEFINED :: 0;
EFI_ACPI_3_0_BYTE :: 1;
EFI_ACPI_3_0_WORD :: 2;
EFI_ACPI_3_0_DWORD :: 3;
EFI_ACPI_3_0_QWORD :: 4;

EFI_ACPI_3_0_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION :: 0x02;

EFI_ACPI_3_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_3_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_3_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION :: 0x04;

EFI_ACPI_3_0_PM_PROFILE_UNSPECIFIED :: 0;
EFI_ACPI_3_0_PM_PROFILE_DESKTOP :: 1;
EFI_ACPI_3_0_PM_PROFILE_MOBILE :: 2;
EFI_ACPI_3_0_PM_PROFILE_WORKSTATION :: 3;
EFI_ACPI_3_0_PM_PROFILE_ENTERPRISE_SERVER :: 4;
EFI_ACPI_3_0_PM_PROFILE_SOHO_SERVER :: 5;
EFI_ACPI_3_0_PM_PROFILE_APPLIANCE_PC :: 6;
EFI_ACPI_3_0_PM_PROFILE_PERFORMANCE_SERVER :: 7;

EFI_ACPI_3_0_LEGACY_DEVICES :: BIT0;
EFI_ACPI_3_0_8042 :: BIT1;
EFI_ACPI_3_0_VGA_NOT_PRESENT :: BIT2;
EFI_ACPI_3_0_MSI_NOT_SUPPORTED :: BIT3;
EFI_ACPI_3_0_PCIE_ASPM_CONTROLS :: BIT4;

EFI_ACPI_3_0_WBINVD :: BIT0;
EFI_ACPI_3_0_WBINVD_FLUSH :: BIT1;
EFI_ACPI_3_0_PROC_C1 :: BIT2;
EFI_ACPI_3_0_P_LVL2_UP :: BIT3;
EFI_ACPI_3_0_PWR_BUTTON :: BIT4;
EFI_ACPI_3_0_SLP_BUTTON :: BIT5;
EFI_ACPI_3_0_FIX_RTC :: BIT6;
EFI_ACPI_3_0_RTC_S4 :: BIT7;
EFI_ACPI_3_0_TMR_VAL_EXT :: BIT8;
EFI_ACPI_3_0_DCK_CAP :: BIT9;
EFI_ACPI_3_0_RESET_REG_SUP :: BIT10;
EFI_ACPI_3_0_SEALED_CASE :: BIT11;
EFI_ACPI_3_0_HEADLESS :: BIT12;
EFI_ACPI_3_0_CPU_SW_SLP :: BIT13;
EFI_ACPI_3_0_PCI_EXP_WAK :: BIT14;
EFI_ACPI_3_0_USE_PLATFORM_CLOCK :: BIT15;
EFI_ACPI_3_0_S4_RTC_STS_VALID :: BIT16;
EFI_ACPI_3_0_REMOTE_POWER_ON_CAPABLE :: BIT17;
EFI_ACPI_3_0_FORCE_APIC_CLUSTER_MODEL :: BIT18;
EFI_ACPI_3_0_FORCE_APIC_PHYSICAL_DESTINATION_MODE :: BIT19;

EFI_ACPI_3_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION :: 0x01;

EFI_ACPI_3_0_S4BIOS_F :: BIT0;

EFI_ACPI_3_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x02;
EFI_ACPI_3_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x02;

EFI_ACPI_3_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION :: 0x02;

EFI_ACPI_3_0_PCAT_COMPAT :: BIT0;

EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC :: 0x00;
EFI_ACPI_3_0_IO_APIC :: 0x01;
EFI_ACPI_3_0_INTERRUPT_SOURCE_OVERRIDE :: 0x02;
EFI_ACPI_3_0_NON_MASKABLE_INTERRUPT_SOURCE :: 0x03;
EFI_ACPI_3_0_LOCAL_APIC_NMI :: 0x04;
EFI_ACPI_3_0_LOCAL_APIC_ADDRESS_OVERRIDE :: 0x05;
EFI_ACPI_3_0_IO_SAPIC :: 0x06;
EFI_ACPI_3_0_LOCAL_SAPIC :: 0x07;
EFI_ACPI_3_0_PLATFORM_INTERRUPT_SOURCES :: 0x08;

EFI_ACPI_3_0_LOCAL_APIC_ENABLED :: BIT0;

EFI_ACPI_3_0_POLARITY :: 3 << 0;
EFI_ACPI_3_0_TRIGGER_MODE :: 3 << 2;

EFI_ACPI_3_0_CPEI_PROCESSOR_OVERRIDE :: BIT0;

EFI_ACPI_3_0_SMART_BATTERY_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_3_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION :: 0x01;

EFI_ACPI_3_0_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION :: 0x02;

EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY :: 0x00;
EFI_ACPI_3_0_MEMORY_AFFINITY :: 0x01;

EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED :: 1 << 0;

EFI_ACPI_3_0_MEMORY_ENABLED :: 1 << 0;
EFI_ACPI_3_0_MEMORY_HOT_PLUGGABLE :: 1 << 1;
EFI_ACPI_3_0_MEMORY_NONVOLATILE :: 1 << 2;

EFI_ACPI_3_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_SYSTEM_MEMORY :: 0;
EFI_ACPI_4_0_SYSTEM_IO :: 1;
EFI_ACPI_4_0_PCI_CONFIGURATION_SPACE :: 2;
EFI_ACPI_4_0_EMBEDDED_CONTROLLER :: 3;
EFI_ACPI_4_0_SMBUS :: 4;
EFI_ACPI_4_0_FUNCTIONAL_FIXED_HARDWARE :: 0x7F;

EFI_ACPI_4_0_UNDEFINED :: 0;
EFI_ACPI_4_0_BYTE :: 1;
EFI_ACPI_4_0_WORD :: 2;
EFI_ACPI_4_0_DWORD :: 3;
EFI_ACPI_4_0_QWORD :: 4;

EFI_ACPI_4_0_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION :: 0x02;

EFI_ACPI_4_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION :: 0x04;

EFI_ACPI_4_0_PM_PROFILE_UNSPECIFIED :: 0;
EFI_ACPI_4_0_PM_PROFILE_DESKTOP :: 1;
EFI_ACPI_4_0_PM_PROFILE_MOBILE :: 2;
EFI_ACPI_4_0_PM_PROFILE_WORKSTATION :: 3;
EFI_ACPI_4_0_PM_PROFILE_ENTERPRISE_SERVER :: 4;
EFI_ACPI_4_0_PM_PROFILE_SOHO_SERVER :: 5;
EFI_ACPI_4_0_PM_PROFILE_APPLIANCE_PC :: 6;
EFI_ACPI_4_0_PM_PROFILE_PERFORMANCE_SERVER :: 7;

EFI_ACPI_4_0_LEGACY_DEVICES :: BIT0;
EFI_ACPI_4_0_8042 :: BIT1;
EFI_ACPI_4_0_VGA_NOT_PRESENT :: BIT2;
EFI_ACPI_4_0_MSI_NOT_SUPPORTED :: BIT3;
EFI_ACPI_4_0_PCIE_ASPM_CONTROLS :: BIT4;

EFI_ACPI_4_0_WBINVD :: BIT0;
EFI_ACPI_4_0_WBINVD_FLUSH :: BIT1;
EFI_ACPI_4_0_PROC_C1 :: BIT2;
EFI_ACPI_4_0_P_LVL2_UP :: BIT3;
EFI_ACPI_4_0_PWR_BUTTON :: BIT4;
EFI_ACPI_4_0_SLP_BUTTON :: BIT5;
EFI_ACPI_4_0_FIX_RTC :: BIT6;
EFI_ACPI_4_0_RTC_S4 :: BIT7;
EFI_ACPI_4_0_TMR_VAL_EXT :: BIT8;
EFI_ACPI_4_0_DCK_CAP :: BIT9;
EFI_ACPI_4_0_RESET_REG_SUP :: BIT10;
EFI_ACPI_4_0_SEALED_CASE :: BIT11;
EFI_ACPI_4_0_HEADLESS :: BIT12;
EFI_ACPI_4_0_CPU_SW_SLP :: BIT13;
EFI_ACPI_4_0_PCI_EXP_WAK :: BIT14;
EFI_ACPI_4_0_USE_PLATFORM_CLOCK :: BIT15;
EFI_ACPI_4_0_S4_RTC_STS_VALID :: BIT16;
EFI_ACPI_4_0_REMOTE_POWER_ON_CAPABLE :: BIT17;
EFI_ACPI_4_0_FORCE_APIC_CLUSTER_MODEL :: BIT18;
EFI_ACPI_4_0_FORCE_APIC_PHYSICAL_DESTINATION_MODE :: BIT19;

EFI_ACPI_4_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION :: 0x02;

EFI_ACPI_4_0_S4BIOS_F :: BIT0;
EFI_ACPI_4_0_64BIT_WAKE_SUPPORTED_F :: BIT1;

EFI_ACPI_4_0_OSPM_64BIT_WAKE__F :: BIT0;

EFI_ACPI_4_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x02;
EFI_ACPI_4_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x02;

EFI_ACPI_4_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION :: 0x03;

EFI_ACPI_4_0_PCAT_COMPAT :: BIT0;

EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC :: 0x00;
EFI_ACPI_4_0_IO_APIC :: 0x01;
EFI_ACPI_4_0_INTERRUPT_SOURCE_OVERRIDE :: 0x02;
EFI_ACPI_4_0_NON_MASKABLE_INTERRUPT_SOURCE :: 0x03;
EFI_ACPI_4_0_LOCAL_APIC_NMI :: 0x04;
EFI_ACPI_4_0_LOCAL_APIC_ADDRESS_OVERRIDE :: 0x05;
EFI_ACPI_4_0_IO_SAPIC :: 0x06;
EFI_ACPI_4_0_LOCAL_SAPIC :: 0x07;
EFI_ACPI_4_0_PLATFORM_INTERRUPT_SOURCES :: 0x08;
EFI_ACPI_4_0_PROCESSOR_LOCAL_X2APIC :: 0x09;
EFI_ACPI_4_0_LOCAL_X2APIC_NMI :: 0x0A;

EFI_ACPI_4_0_LOCAL_APIC_ENABLED :: BIT0;

EFI_ACPI_4_0_POLARITY :: 3 << 0;
EFI_ACPI_4_0_TRIGGER_MODE :: 3 << 2;

EFI_ACPI_4_0_CPEI_PROCESSOR_OVERRIDE :: BIT0;

EFI_ACPI_4_0_SMART_BATTERY_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION :: 0x03;

EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY :: 0x00;
EFI_ACPI_4_0_MEMORY_AFFINITY :: 0x01;
EFI_ACPI_4_0_PROCESSOR_LOCAL_X2APIC_AFFINITY :: 0x02;

EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED :: 1 << 0;

EFI_ACPI_4_0_MEMORY_ENABLED :: 1 << 0;
EFI_ACPI_4_0_MEMORY_HOT_PLUGGABLE :: 1 << 1;
EFI_ACPI_4_0_MEMORY_NONVOLATILE :: 1 << 2;

EFI_ACPI_4_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_CPEP_PROCESSOR_APIC_SAPIC :: 0x00;

EFI_ACPI_4_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_BOOT_ERROR_RECORD_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_ERROR_SEVERITY_CORRECTABLE :: 0x00;
EFI_ACPI_4_0_ERROR_SEVERITY_FATAL :: 0x01;
EFI_ACPI_4_0_ERROR_SEVERITY_CORRECTED :: 0x02;
EFI_ACPI_4_0_ERROR_SEVERITY_NONE :: 0x03;

EFI_ACPI_4_0_GENERIC_ERROR_DATA_ENTRY_REVISION :: 0x0201;

EFI_ACPI_4_0_HARDWARE_ERROR_SOURCE_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION :: 0x00;
EFI_ACPI_4_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK :: 0x01;
EFI_ACPI_4_0_IA32_ARCHITECTURE_NMI_ERROR :: 0x02;
EFI_ACPI_4_0_PCI_EXPRESS_ROOT_PORT_AER :: 0x06;
EFI_ACPI_4_0_PCI_EXPRESS_DEVICE_AER :: 0x07;
EFI_ACPI_4_0_PCI_EXPRESS_BRIDGE_AER :: 0x08;
EFI_ACPI_4_0_GENERIC_HARDWARE_ERROR :: 0x09;

EFI_ACPI_4_0_ERROR_SOURCE_FLAG_FIRMWARE_FIRST :: 1 << 0;
EFI_ACPI_4_0_ERROR_SOURCE_FLAG_GLOBAL :: 1 << 1;

EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32 :: 0x00;
EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64 :: 0x01;
EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64 :: 0x02;

EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_POLLED :: 0x00;
EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT :: 0x01;
EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT :: 0x02;
EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_SCI :: 0x03;
EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_NMI :: 0x04;

EFI_ACPI_4_0_ERROR_RECORD_SERIALIZATION_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_ERST_BEGIN_WRITE_OPERATION :: 0x00;
EFI_ACPI_4_0_ERST_BEGIN_READ_OPERATION :: 0x01;
EFI_ACPI_4_0_ERST_BEGIN_CLEAR_OPERATION :: 0x02;
EFI_ACPI_4_0_ERST_END_OPERATION :: 0x03;
EFI_ACPI_4_0_ERST_SET_RECORD_OFFSET :: 0x04;
EFI_ACPI_4_0_ERST_EXECUTE_OPERATION :: 0x05;
EFI_ACPI_4_0_ERST_CHECK_BUSY_STATUS :: 0x06;
EFI_ACPI_4_0_ERST_GET_COMMAND_STATUS :: 0x07;
EFI_ACPI_4_0_ERST_GET_RECORD_IDENTIFIER :: 0x08;
EFI_ACPI_4_0_ERST_SET_RECORD_IDENTIFIER :: 0x09;
EFI_ACPI_4_0_ERST_GET_RECORD_COUNT :: 0x0A;
EFI_ACPI_4_0_ERST_BEGIN_DUMMY_WRITE_OPERATION :: 0x0B;
EFI_ACPI_4_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE :: 0x0D;
EFI_ACPI_4_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH :: 0x0E;
EFI_ACPI_4_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES :: 0x0F;

EFI_ACPI_4_0_EINJ_STATUS_SUCCESS :: 0x00;
EFI_ACPI_4_0_EINJ_STATUS_NOT_ENOUGH_SPACE :: 0x01;
EFI_ACPI_4_0_EINJ_STATUS_HARDWARE_NOT_AVAILABLE :: 0x02;
EFI_ACPI_4_0_EINJ_STATUS_FAILED :: 0x03;
EFI_ACPI_4_0_EINJ_STATUS_RECORD_STORE_EMPTY :: 0x04;
EFI_ACPI_4_0_EINJ_STATUS_RECORD_NOT_FOUND :: 0x05;

EFI_ACPI_4_0_ERST_READ_REGISTER :: 0x00;
EFI_ACPI_4_0_ERST_READ_REGISTER_VALUE :: 0x01;
EFI_ACPI_4_0_ERST_WRITE_REGISTER :: 0x02;
EFI_ACPI_4_0_ERST_WRITE_REGISTER_VALUE :: 0x03;
EFI_ACPI_4_0_ERST_NOOP :: 0x04;
EFI_ACPI_4_0_ERST_LOAD_VAR1 :: 0x05;
EFI_ACPI_4_0_ERST_LOAD_VAR2 :: 0x06;
EFI_ACPI_4_0_ERST_STORE_VAR1 :: 0x07;
EFI_ACPI_4_0_ERST_ADD :: 0x08;
EFI_ACPI_4_0_ERST_SUBTRACT :: 0x09;
EFI_ACPI_4_0_ERST_ADD_VALUE :: 0x0A;
EFI_ACPI_4_0_ERST_SUBTRACT_VALUE :: 0x0B;
EFI_ACPI_4_0_ERST_STALL :: 0x0C;
EFI_ACPI_4_0_ERST_STALL_WHILE_TRUE :: 0x0D;
EFI_ACPI_4_0_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE :: 0x0E;
EFI_ACPI_4_0_ERST_GOTO :: 0x0F;
EFI_ACPI_4_0_ERST_SET_SRC_ADDRESS_BASE :: 0x10;
EFI_ACPI_4_0_ERST_SET_DST_ADDRESS_BASE :: 0x11;
EFI_ACPI_4_0_ERST_MOVE_DATA :: 0x12;

EFI_ACPI_4_0_ERST_PRESERVE_REGISTER :: 0x01;

EFI_ACPI_4_0_ERROR_INJECTION_TABLE_REVISION :: 0x01;

EFI_ACPI_4_0_EINJ_BEGIN_INJECTION_OPERATION :: 0x00;
EFI_ACPI_4_0_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE :: 0x01;
EFI_ACPI_4_0_EINJ_SET_ERROR_TYPE :: 0x02;
EFI_ACPI_4_0_EINJ_GET_ERROR_TYPE :: 0x03;
EFI_ACPI_4_0_EINJ_END_OPERATION :: 0x04;
EFI_ACPI_4_0_EINJ_EXECUTE_OPERATION :: 0x05;
EFI_ACPI_4_0_EINJ_CHECK_BUSY_STATUS :: 0x06;
EFI_ACPI_4_0_EINJ_GET_COMMAND_STATUS :: 0x07;
EFI_ACPI_4_0_EINJ_TRIGGER_ERROR :: 0xFF;

EFI_ACPI_4_0_EINJ_STATUS_UNKNOWN_FAILURE :: 0x01;
EFI_ACPI_4_0_EINJ_STATUS_INVALID_ACCESS :: 0x02;

EFI_ACPI_4_0_EINJ_ERROR_PROCESSOR_CORRECTABLE :: 1 << 0;
EFI_ACPI_4_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL :: 1 << 1;
EFI_ACPI_4_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL :: 1 << 2;
EFI_ACPI_4_0_EINJ_ERROR_MEMORY_CORRECTABLE :: 1 << 3;
EFI_ACPI_4_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL :: 1 << 4;
EFI_ACPI_4_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL :: 1 << 5;
EFI_ACPI_4_0_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE :: 1 << 6;
EFI_ACPI_4_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL :: 1 << 7;
EFI_ACPI_4_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL :: 1 << 8;
EFI_ACPI_4_0_EINJ_ERROR_PLATFORM_CORRECTABLE :: 1 << 9;
EFI_ACPI_4_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL :: 1 << 10;
EFI_ACPI_4_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL :: 1 << 11;

EFI_ACPI_4_0_EINJ_READ_REGISTER :: 0x00;
EFI_ACPI_4_0_EINJ_READ_REGISTER_VALUE :: 0x01;
EFI_ACPI_4_0_EINJ_WRITE_REGISTER :: 0x02;
EFI_ACPI_4_0_EINJ_WRITE_REGISTER_VALUE :: 0x03;
EFI_ACPI_4_0_EINJ_NOOP :: 0x04;

EFI_ACPI_4_0_EINJ_PRESERVE_REGISTER :: 0x01;

ACPI_SMALL_FIXED_DMA_DESCRIPTOR_NAME :: 0x0A;
ACPI_LARGE_GPIO_CONNECTION_DESCRIPTOR_NAME :: 0x0C;
ACPI_LARGE_GENERIC_SERIAL_BUS_CONNECTION_DESCRIPTOR_NAME :: 0x0E;

ACPI_FIXED_DMA_DESCRIPTOR :: 0x55;
ACPI_GPIO_CONNECTION_DESCRIPTOR :: 0x8C;
ACPI_GENERIC_SERIAL_BUS_CONNECTION_DESCRIPTOR :: 0x8E;

EFI_ACPI_GPIO_CONNECTION_TYPE_INTERRUPT :: 0x0;
EFI_ACPI_GPIO_CONNECTION_TYPE_IO :: 0x1;

EFI_ACPI_SERIAL_BUS_RESOURCE_TYPE_I2C :: 0x1;
EFI_ACPI_SERIAL_BUS_RESOURCE_TYPE_SPI :: 0x2;
EFI_ACPI_SERIAL_BUS_RESOURCE_TYPE_UART :: 0x3;

EFI_ACPI_5_0_SYSTEM_MEMORY :: 0;
EFI_ACPI_5_0_SYSTEM_IO :: 1;
EFI_ACPI_5_0_PCI_CONFIGURATION_SPACE :: 2;
EFI_ACPI_5_0_EMBEDDED_CONTROLLER :: 3;
EFI_ACPI_5_0_SMBUS :: 4;
EFI_ACPI_5_0_PLATFORM_COMMUNICATION_CHANNEL :: 0x0A;
EFI_ACPI_5_0_FUNCTIONAL_FIXED_HARDWARE :: 0x7F;

EFI_ACPI_5_0_UNDEFINED :: 0;
EFI_ACPI_5_0_BYTE :: 1;
EFI_ACPI_5_0_WORD :: 2;
EFI_ACPI_5_0_DWORD :: 3;
EFI_ACPI_5_0_QWORD :: 4;

EFI_ACPI_5_0_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION :: 0x02;

EFI_ACPI_5_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION :: 0x05;

EFI_ACPI_5_0_PM_PROFILE_UNSPECIFIED :: 0;
EFI_ACPI_5_0_PM_PROFILE_DESKTOP :: 1;
EFI_ACPI_5_0_PM_PROFILE_MOBILE :: 2;
EFI_ACPI_5_0_PM_PROFILE_WORKSTATION :: 3;
EFI_ACPI_5_0_PM_PROFILE_ENTERPRISE_SERVER :: 4;
EFI_ACPI_5_0_PM_PROFILE_SOHO_SERVER :: 5;
EFI_ACPI_5_0_PM_PROFILE_APPLIANCE_PC :: 6;
EFI_ACPI_5_0_PM_PROFILE_PERFORMANCE_SERVER :: 7;
EFI_ACPI_5_0_PM_PROFILE_TABLET :: 8;

EFI_ACPI_5_0_LEGACY_DEVICES :: BIT0;
EFI_ACPI_5_0_8042 :: BIT1;
EFI_ACPI_5_0_VGA_NOT_PRESENT :: BIT2;
EFI_ACPI_5_0_MSI_NOT_SUPPORTED :: BIT3;
EFI_ACPI_5_0_PCIE_ASPM_CONTROLS :: BIT4;
EFI_ACPI_5_0_CMOS_RTC_NOT_PRESENT :: BIT5;

EFI_ACPI_5_0_WBINVD :: BIT0;
EFI_ACPI_5_0_WBINVD_FLUSH :: BIT1;
EFI_ACPI_5_0_PROC_C1 :: BIT2;
EFI_ACPI_5_0_P_LVL2_UP :: BIT3;
EFI_ACPI_5_0_PWR_BUTTON :: BIT4;
EFI_ACPI_5_0_SLP_BUTTON :: BIT5;
EFI_ACPI_5_0_FIX_RTC :: BIT6;
EFI_ACPI_5_0_RTC_S4 :: BIT7;
EFI_ACPI_5_0_TMR_VAL_EXT :: BIT8;
EFI_ACPI_5_0_DCK_CAP :: BIT9;
EFI_ACPI_5_0_RESET_REG_SUP :: BIT10;
EFI_ACPI_5_0_SEALED_CASE :: BIT11;
EFI_ACPI_5_0_HEADLESS :: BIT12;
EFI_ACPI_5_0_CPU_SW_SLP :: BIT13;
EFI_ACPI_5_0_PCI_EXP_WAK :: BIT14;
EFI_ACPI_5_0_USE_PLATFORM_CLOCK :: BIT15;
EFI_ACPI_5_0_S4_RTC_STS_VALID :: BIT16;
EFI_ACPI_5_0_REMOTE_POWER_ON_CAPABLE :: BIT17;
EFI_ACPI_5_0_FORCE_APIC_CLUSTER_MODEL :: BIT18;
EFI_ACPI_5_0_FORCE_APIC_PHYSICAL_DESTINATION_MODE :: BIT19;
EFI_ACPI_5_0_HW_REDUCED_ACPI :: BIT20;
EFI_ACPI_5_0_LOW_POWER_S0_IDLE_CAPABLE :: BIT21;

EFI_ACPI_5_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION :: 0x02;

EFI_ACPI_5_0_S4BIOS_F :: BIT0;
EFI_ACPI_5_0_64BIT_WAKE_SUPPORTED_F :: BIT1;

EFI_ACPI_5_0_OSPM_64BIT_WAKE_F :: BIT0;

EFI_ACPI_5_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x02;
EFI_ACPI_5_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x02;

EFI_ACPI_5_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION :: 0x03;

EFI_ACPI_5_0_PCAT_COMPAT :: BIT0;

EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC :: 0x00;
EFI_ACPI_5_0_IO_APIC :: 0x01;
EFI_ACPI_5_0_INTERRUPT_SOURCE_OVERRIDE :: 0x02;
EFI_ACPI_5_0_NON_MASKABLE_INTERRUPT_SOURCE :: 0x03;
EFI_ACPI_5_0_LOCAL_APIC_NMI :: 0x04;
EFI_ACPI_5_0_LOCAL_APIC_ADDRESS_OVERRIDE :: 0x05;
EFI_ACPI_5_0_IO_SAPIC :: 0x06;
EFI_ACPI_5_0_LOCAL_SAPIC :: 0x07;
EFI_ACPI_5_0_PLATFORM_INTERRUPT_SOURCES :: 0x08;
EFI_ACPI_5_0_PROCESSOR_LOCAL_X2APIC :: 0x09;
EFI_ACPI_5_0_LOCAL_X2APIC_NMI :: 0x0A;
EFI_ACPI_5_0_GIC :: 0x0B;
EFI_ACPI_5_0_GICD :: 0x0C;

EFI_ACPI_5_0_LOCAL_APIC_ENABLED :: BIT0;

EFI_ACPI_5_0_POLARITY :: 3 << 0;
EFI_ACPI_5_0_TRIGGER_MODE :: 3 << 2;

EFI_ACPI_5_0_CPEI_PROCESSOR_OVERRIDE :: BIT0;

EFI_ACPI_5_0_GIC_ENABLED :: BIT0;
EFI_ACPI_5_0_PERFORMANCE_INTERRUPT_MODEL :: BIT1;

EFI_ACPI_5_0_SMART_BATTERY_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION :: 0x03;

EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY :: 0x00;
EFI_ACPI_5_0_MEMORY_AFFINITY :: 0x01;
EFI_ACPI_5_0_PROCESSOR_LOCAL_X2APIC_AFFINITY :: 0x02;

EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED :: 1 << 0;

EFI_ACPI_5_0_MEMORY_ENABLED :: 1 << 0;
EFI_ACPI_5_0_MEMORY_HOT_PLUGGABLE :: 1 << 1;
EFI_ACPI_5_0_MEMORY_NONVOLATILE :: 1 << 2;

EFI_ACPI_5_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_CPEP_PROCESSOR_APIC_SAPIC :: 0x00;

EFI_ACPI_5_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_RAS_FEATURE_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_RASF_PCC_COMMAND_CODE_EXECUTE_RASF_COMMAND :: 0x01;

EFI_ACPI_5_0_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED :: 0x01;
EFI_ACPI_5_0_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED_AND_EXPOSED_TO_SOFTWARE :: 0x02;

EFI_ACPI_5_0_RASF_PATROL_SCRUB_COMMAND_GET_PATROL_PARAMETERS :: 0x01;
EFI_ACPI_5_0_RASF_PATROL_SCRUB_COMMAND_START_PATROL_SCRUBBER :: 0x02;
EFI_ACPI_5_0_RASF_PATROL_SCRUB_COMMAND_STOP_PATROL_SCRUBBER :: 0x03;

EFI_ACPI_5_0_MEMORY_POWER_STATE_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_MPST_PCC_COMMAND_CODE_EXECUTE_MPST_COMMAND :: 0x03;

EFI_ACPI_5_0_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_POWER_STATE :: 0x01;
EFI_ACPI_5_0_MPST_MEMORY_POWER_COMMAND_SET_MEMORY_POWER_STATE :: 0x02;
EFI_ACPI_5_0_MPST_MEMORY_POWER_COMMAND_GET_AVERAGE_POWER_CONSUMED :: 0x03;
EFI_ACPI_5_0_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_ENERGY_CONSUMED :: 0x04;

EFI_ACPI_5_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_ENABLE :: 0x01;
EFI_ACPI_5_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_POWER_MANAGED :: 0x02;
EFI_ACPI_5_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_HOT_PLUGGABLE :: 0x04;

EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_MEMORY_CONTENT_PRESERVED :: 0x01;
EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_ENTRY :: 0x02;
EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_EXIT :: 0x04;

EFI_ACPI_5_0_MEMORY_TOPOLOGY_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_SOCKET :: 0x1;
EFI_ACPI_5_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_MEMORY_CONTROLLER :: 0x2;
EFI_ACPI_5_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_DIMM :: 0x3;

EFI_ACPI_5_0_BOOT_GRAPHICS_RESOURCE_TABLE_REVISION :: 1;

EFI_ACPI_5_0_BGRT_VERSION :: 0x01;

EFI_ACPI_5_0_BGRT_STATUS_NOT_DISPLAYED :: 0x00;
EFI_ACPI_5_0_BGRT_STATUS_DISPLAYED :: 0x01;
EFI_ACPI_5_0_BGRT_STATUS_INVALID :: EFI_ACPI_5_0_BGRT_STATUS_NOT_DISPLAYED;
EFI_ACPI_5_0_BGRT_STATUS_VALID :: EFI_ACPI_5_0_BGRT_STATUS_DISPLAYED;

EFI_ACPI_5_0_BGRT_IMAGE_TYPE_BMP :: 0x00;

EFI_ACPI_5_0_FIRMWARE_PERFORMANCE_DATA_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_FPDT_RECORD_TYPE_FIRMWARE_BASIC_BOOT_POINTER :: 0x0000;
EFI_ACPI_5_0_FPDT_RECORD_TYPE_S3_PERFORMANCE_TABLE_POINTER :: 0x0001;

EFI_ACPI_5_0_FPDT_RECORD_REVISION_FIRMWARE_BASIC_BOOT_POINTER :: 0x01;
EFI_ACPI_5_0_FPDT_RECORD_REVISION_S3_PERFORMANCE_TABLE_POINTER :: 0x01;

EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_TYPE_S3_RESUME :: 0x0000;
EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_TYPE_S3_SUSPEND :: 0x0001;
EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_TYPE_FIRMWARE_BASIC_BOOT :: 0x0002;

EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_REVISION_S3_RESUME :: 0x01;
EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_REVISION_S3_SUSPEND :: 0x01;
EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_REVISION_FIRMWARE_BASIC_BOOT :: 0x02;

EFI_ACPI_5_0_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_GTDT_GLOBAL_FLAG_MEMORY_MAPPED_BLOCK_PRESENT :: BIT0;
EFI_ACPI_5_0_GTDT_GLOBAL_FLAG_INTERRUPT_MODE :: BIT1;

EFI_ACPI_5_0_GTDT_TIMER_FLAG_TIMER_INTERRUPT_MODE :: BIT0;
EFI_ACPI_5_0_GTDT_TIMER_FLAG_TIMER_INTERRUPT_POLARITY :: BIT1;

EFI_ACPI_5_0_BOOT_ERROR_RECORD_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_ERROR_SEVERITY_CORRECTABLE :: 0x00;
EFI_ACPI_5_0_ERROR_SEVERITY_FATAL :: 0x01;
EFI_ACPI_5_0_ERROR_SEVERITY_CORRECTED :: 0x02;
EFI_ACPI_5_0_ERROR_SEVERITY_NONE :: 0x03;

EFI_ACPI_5_0_GENERIC_ERROR_DATA_ENTRY_REVISION :: 0x0201;

EFI_ACPI_5_0_HARDWARE_ERROR_SOURCE_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION :: 0x00;
EFI_ACPI_5_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK :: 0x01;
EFI_ACPI_5_0_IA32_ARCHITECTURE_NMI_ERROR :: 0x02;
EFI_ACPI_5_0_PCI_EXPRESS_ROOT_PORT_AER :: 0x06;
EFI_ACPI_5_0_PCI_EXPRESS_DEVICE_AER :: 0x07;
EFI_ACPI_5_0_PCI_EXPRESS_BRIDGE_AER :: 0x08;
EFI_ACPI_5_0_GENERIC_HARDWARE_ERROR :: 0x09;

EFI_ACPI_5_0_ERROR_SOURCE_FLAG_FIRMWARE_FIRST :: 1 << 0;
EFI_ACPI_5_0_ERROR_SOURCE_FLAG_GLOBAL :: 1 << 1;

EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32 :: 0x00;
EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64 :: 0x01;
EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64 :: 0x02;

EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_POLLED :: 0x00;
EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT :: 0x01;
EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT :: 0x02;
EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_SCI :: 0x03;
EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_NMI :: 0x04;

EFI_ACPI_5_0_ERROR_RECORD_SERIALIZATION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_ERST_BEGIN_WRITE_OPERATION :: 0x00;
EFI_ACPI_5_0_ERST_BEGIN_READ_OPERATION :: 0x01;
EFI_ACPI_5_0_ERST_BEGIN_CLEAR_OPERATION :: 0x02;
EFI_ACPI_5_0_ERST_END_OPERATION :: 0x03;
EFI_ACPI_5_0_ERST_SET_RECORD_OFFSET :: 0x04;
EFI_ACPI_5_0_ERST_EXECUTE_OPERATION :: 0x05;
EFI_ACPI_5_0_ERST_CHECK_BUSY_STATUS :: 0x06;
EFI_ACPI_5_0_ERST_GET_COMMAND_STATUS :: 0x07;
EFI_ACPI_5_0_ERST_GET_RECORD_IDENTIFIER :: 0x08;
EFI_ACPI_5_0_ERST_SET_RECORD_IDENTIFIER :: 0x09;
EFI_ACPI_5_0_ERST_GET_RECORD_COUNT :: 0x0A;
EFI_ACPI_5_0_ERST_BEGIN_DUMMY_WRITE_OPERATION :: 0x0B;
EFI_ACPI_5_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE :: 0x0D;
EFI_ACPI_5_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH :: 0x0E;
EFI_ACPI_5_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES :: 0x0F;

EFI_ACPI_5_0_ERST_STATUS_SUCCESS :: 0x00;
EFI_ACPI_5_0_ERST_STATUS_NOT_ENOUGH_SPACE :: 0x01;
EFI_ACPI_5_0_ERST_STATUS_HARDWARE_NOT_AVAILABLE :: 0x02;
EFI_ACPI_5_0_ERST_STATUS_FAILED :: 0x03;
EFI_ACPI_5_0_ERST_STATUS_RECORD_STORE_EMPTY :: 0x04;
EFI_ACPI_5_0_ERST_STATUS_RECORD_NOT_FOUND :: 0x05;

EFI_ACPI_5_0_ERST_READ_REGISTER :: 0x00;
EFI_ACPI_5_0_ERST_READ_REGISTER_VALUE :: 0x01;
EFI_ACPI_5_0_ERST_WRITE_REGISTER :: 0x02;
EFI_ACPI_5_0_ERST_WRITE_REGISTER_VALUE :: 0x03;
EFI_ACPI_5_0_ERST_NOOP :: 0x04;
EFI_ACPI_5_0_ERST_LOAD_VAR1 :: 0x05;
EFI_ACPI_5_0_ERST_LOAD_VAR2 :: 0x06;
EFI_ACPI_5_0_ERST_STORE_VAR1 :: 0x07;
EFI_ACPI_5_0_ERST_ADD :: 0x08;
EFI_ACPI_5_0_ERST_SUBTRACT :: 0x09;
EFI_ACPI_5_0_ERST_ADD_VALUE :: 0x0A;
EFI_ACPI_5_0_ERST_SUBTRACT_VALUE :: 0x0B;
EFI_ACPI_5_0_ERST_STALL :: 0x0C;
EFI_ACPI_5_0_ERST_STALL_WHILE_TRUE :: 0x0D;
EFI_ACPI_5_0_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE :: 0x0E;
EFI_ACPI_5_0_ERST_GOTO :: 0x0F;
EFI_ACPI_5_0_ERST_SET_SRC_ADDRESS_BASE :: 0x10;
EFI_ACPI_5_0_ERST_SET_DST_ADDRESS_BASE :: 0x11;
EFI_ACPI_5_0_ERST_MOVE_DATA :: 0x12;

EFI_ACPI_5_0_ERST_PRESERVE_REGISTER :: 0x01;

EFI_ACPI_5_0_ERROR_INJECTION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_EINJ_BEGIN_INJECTION_OPERATION :: 0x00;
EFI_ACPI_5_0_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE :: 0x01;
EFI_ACPI_5_0_EINJ_SET_ERROR_TYPE :: 0x02;
EFI_ACPI_5_0_EINJ_GET_ERROR_TYPE :: 0x03;
EFI_ACPI_5_0_EINJ_END_OPERATION :: 0x04;
EFI_ACPI_5_0_EINJ_EXECUTE_OPERATION :: 0x05;
EFI_ACPI_5_0_EINJ_CHECK_BUSY_STATUS :: 0x06;
EFI_ACPI_5_0_EINJ_GET_COMMAND_STATUS :: 0x07;
EFI_ACPI_5_0_EINJ_TRIGGER_ERROR :: 0xFF;

EFI_ACPI_5_0_EINJ_STATUS_SUCCESS :: 0x00;
EFI_ACPI_5_0_EINJ_STATUS_UNKNOWN_FAILURE :: 0x01;
EFI_ACPI_5_0_EINJ_STATUS_INVALID_ACCESS :: 0x02;

EFI_ACPI_5_0_EINJ_ERROR_PROCESSOR_CORRECTABLE :: 1 << 0;
EFI_ACPI_5_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL :: 1 << 1;
EFI_ACPI_5_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL :: 1 << 2;
EFI_ACPI_5_0_EINJ_ERROR_MEMORY_CORRECTABLE :: 1 << 3;
EFI_ACPI_5_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL :: 1 << 4;
EFI_ACPI_5_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL :: 1 << 5;
EFI_ACPI_5_0_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE :: 1 << 6;
EFI_ACPI_5_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL :: 1 << 7;
EFI_ACPI_5_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL :: 1 << 8;
EFI_ACPI_5_0_EINJ_ERROR_PLATFORM_CORRECTABLE :: 1 << 9;
EFI_ACPI_5_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL :: 1 << 10;
EFI_ACPI_5_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL :: 1 << 11;

EFI_ACPI_5_0_EINJ_READ_REGISTER :: 0x00;
EFI_ACPI_5_0_EINJ_READ_REGISTER_VALUE :: 0x01;
EFI_ACPI_5_0_EINJ_WRITE_REGISTER :: 0x02;
EFI_ACPI_5_0_EINJ_WRITE_REGISTER_VALUE :: 0x03;
EFI_ACPI_5_0_EINJ_NOOP :: 0x04;

EFI_ACPI_5_0_EINJ_PRESERVE_REGISTER :: 0x01;

EFI_ACPI_5_0_PLATFORM_COMMUNICATION_CHANNEL_TABLE_REVISION :: 0x01;

EFI_ACPI_5_0_PCCT_FLAGS_SCI_DOORBELL :: BIT0;

EFI_ACPI_5_0_PCCT_SUBSPACE_TYPE_GENERIC :: 0x00;

EFI_ACPI_5_1_SYSTEM_MEMORY :: 0;
EFI_ACPI_5_1_SYSTEM_IO :: 1;
EFI_ACPI_5_1_PCI_CONFIGURATION_SPACE :: 2;
EFI_ACPI_5_1_EMBEDDED_CONTROLLER :: 3;
EFI_ACPI_5_1_SMBUS :: 4;
EFI_ACPI_5_1_PLATFORM_COMMUNICATION_CHANNEL :: 0x0A;
EFI_ACPI_5_1_FUNCTIONAL_FIXED_HARDWARE :: 0x7F;

EFI_ACPI_5_1_UNDEFINED :: 0;
EFI_ACPI_5_1_BYTE :: 1;
EFI_ACPI_5_1_WORD :: 2;
EFI_ACPI_5_1_DWORD :: 3;
EFI_ACPI_5_1_QWORD :: 4;

EFI_ACPI_5_1_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION :: 0x02;

EFI_ACPI_5_1_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_FIXED_ACPI_DESCRIPTION_TABLE_REVISION :: 0x05;
EFI_ACPI_5_1_FIXED_ACPI_DESCRIPTION_TABLE_MINOR_REVISION :: 0x01;

EFI_ACPI_5_1_PM_PROFILE_UNSPECIFIED :: 0;
EFI_ACPI_5_1_PM_PROFILE_DESKTOP :: 1;
EFI_ACPI_5_1_PM_PROFILE_MOBILE :: 2;
EFI_ACPI_5_1_PM_PROFILE_WORKSTATION :: 3;
EFI_ACPI_5_1_PM_PROFILE_ENTERPRISE_SERVER :: 4;
EFI_ACPI_5_1_PM_PROFILE_SOHO_SERVER :: 5;
EFI_ACPI_5_1_PM_PROFILE_APPLIANCE_PC :: 6;
EFI_ACPI_5_1_PM_PROFILE_PERFORMANCE_SERVER :: 7;
EFI_ACPI_5_1_PM_PROFILE_TABLET :: 8;

EFI_ACPI_5_1_LEGACY_DEVICES :: BIT0;
EFI_ACPI_5_1_8042 :: BIT1;
EFI_ACPI_5_1_VGA_NOT_PRESENT :: BIT2;
EFI_ACPI_5_1_MSI_NOT_SUPPORTED :: BIT3;
EFI_ACPI_5_1_PCIE_ASPM_CONTROLS :: BIT4;
EFI_ACPI_5_1_CMOS_RTC_NOT_PRESENT :: BIT5;

EFI_ACPI_5_1_ARM_PSCI_COMPLIANT :: BIT0;
EFI_ACPI_5_1_ARM_PSCI_USE_HVC :: BIT1;

EFI_ACPI_5_1_WBINVD :: BIT0;
EFI_ACPI_5_1_WBINVD_FLUSH :: BIT1;
EFI_ACPI_5_1_PROC_C1 :: BIT2;
EFI_ACPI_5_1_P_LVL2_UP :: BIT3;
EFI_ACPI_5_1_PWR_BUTTON :: BIT4;
EFI_ACPI_5_1_SLP_BUTTON :: BIT5;
EFI_ACPI_5_1_FIX_RTC :: BIT6;
EFI_ACPI_5_1_RTC_S4 :: BIT7;
EFI_ACPI_5_1_TMR_VAL_EXT :: BIT8;
EFI_ACPI_5_1_DCK_CAP :: BIT9;
EFI_ACPI_5_1_RESET_REG_SUP :: BIT10;
EFI_ACPI_5_1_SEALED_CASE :: BIT11;
EFI_ACPI_5_1_HEADLESS :: BIT12;
EFI_ACPI_5_1_CPU_SW_SLP :: BIT13;
EFI_ACPI_5_1_PCI_EXP_WAK :: BIT14;
EFI_ACPI_5_1_USE_PLATFORM_CLOCK :: BIT15;
EFI_ACPI_5_1_S4_RTC_STS_VALID :: BIT16;
EFI_ACPI_5_1_REMOTE_POWER_ON_CAPABLE :: BIT17;
EFI_ACPI_5_1_FORCE_APIC_CLUSTER_MODEL :: BIT18;
EFI_ACPI_5_1_FORCE_APIC_PHYSICAL_DESTINATION_MODE :: BIT19;
EFI_ACPI_5_1_HW_REDUCED_ACPI :: BIT20;
EFI_ACPI_5_1_LOW_POWER_S0_IDLE_CAPABLE :: BIT21;

EFI_ACPI_5_1_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION :: 0x02;

EFI_ACPI_5_1_S4BIOS_F :: BIT0;
EFI_ACPI_5_1_64BIT_WAKE_SUPPORTED_F :: BIT1;

EFI_ACPI_5_1_OSPM_64BIT_WAKE_F :: BIT0;

EFI_ACPI_5_1_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x02;
EFI_ACPI_5_1_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x02;

EFI_ACPI_5_1_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION :: 0x03;

EFI_ACPI_5_1_PCAT_COMPAT :: BIT0;

EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC :: 0x00;
EFI_ACPI_5_1_IO_APIC :: 0x01;
EFI_ACPI_5_1_INTERRUPT_SOURCE_OVERRIDE :: 0x02;
EFI_ACPI_5_1_NON_MASKABLE_INTERRUPT_SOURCE :: 0x03;
EFI_ACPI_5_1_LOCAL_APIC_NMI :: 0x04;
EFI_ACPI_5_1_LOCAL_APIC_ADDRESS_OVERRIDE :: 0x05;
EFI_ACPI_5_1_IO_SAPIC :: 0x06;
EFI_ACPI_5_1_LOCAL_SAPIC :: 0x07;
EFI_ACPI_5_1_PLATFORM_INTERRUPT_SOURCES :: 0x08;
EFI_ACPI_5_1_PROCESSOR_LOCAL_X2APIC :: 0x09;
EFI_ACPI_5_1_LOCAL_X2APIC_NMI :: 0x0A;
EFI_ACPI_5_1_GIC :: 0x0B;
EFI_ACPI_5_1_GICD :: 0x0C;
EFI_ACPI_5_1_GIC_MSI_FRAME :: 0x0D;
EFI_ACPI_5_1_GICR :: 0x0E;

EFI_ACPI_5_1_LOCAL_APIC_ENABLED :: BIT0;

EFI_ACPI_5_1_POLARITY :: 3 << 0;
EFI_ACPI_5_1_TRIGGER_MODE :: 3 << 2;

EFI_ACPI_5_1_CPEI_PROCESSOR_OVERRIDE :: BIT0;

EFI_ACPI_5_1_GIC_ENABLED :: BIT0;
EFI_ACPI_5_1_PERFORMANCE_INTERRUPT_MODEL :: BIT1;
EFI_ACPI_5_1_VGIC_MAINTENANCE_INTERRUPT_MODE_FLAGS :: BIT2;

EFI_ACPI_5_1_GIC_V1 :: 0x01;
EFI_ACPI_5_1_GIC_V2 :: 0x02;
EFI_ACPI_5_1_GIC_V3 :: 0x03;
EFI_ACPI_5_1_GIC_V4 :: 0x04;

EFI_ACPI_5_1_SPI_COUNT_BASE_SELECT :: BIT0;

EFI_ACPI_5_1_SMART_BATTERY_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION :: 0x03;

EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY :: 0x00;
EFI_ACPI_5_1_MEMORY_AFFINITY :: 0x01;
EFI_ACPI_5_1_PROCESSOR_LOCAL_X2APIC_AFFINITY :: 0x02;
EFI_ACPI_5_1_GICC_AFFINITY :: 0x03;

EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED :: 1 << 0;

EFI_ACPI_5_1_MEMORY_ENABLED :: 1 << 0;
EFI_ACPI_5_1_MEMORY_HOT_PLUGGABLE :: 1 << 1;
EFI_ACPI_5_1_MEMORY_NONVOLATILE :: 1 << 2;

EFI_ACPI_5_1_GICC_ENABLED :: 1 << 0;

EFI_ACPI_5_1_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_CPEP_PROCESSOR_APIC_SAPIC :: 0x00;

EFI_ACPI_5_1_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_RAS_FEATURE_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_RASF_PCC_COMMAND_CODE_EXECUTE_RASF_COMMAND :: 0x01;

EFI_ACPI_5_1_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED :: 0x01;
EFI_ACPI_5_1_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED_AND_EXPOSED_TO_SOFTWARE :: 0x02;

EFI_ACPI_5_1_RASF_PATROL_SCRUB_COMMAND_GET_PATROL_PARAMETERS :: 0x01;
EFI_ACPI_5_1_RASF_PATROL_SCRUB_COMMAND_START_PATROL_SCRUBBER :: 0x02;
EFI_ACPI_5_1_RASF_PATROL_SCRUB_COMMAND_STOP_PATROL_SCRUBBER :: 0x03;

EFI_ACPI_5_1_MEMORY_POWER_STATE_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_MPST_PCC_COMMAND_CODE_EXECUTE_MPST_COMMAND :: 0x03;

EFI_ACPI_5_1_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_POWER_STATE :: 0x01;
EFI_ACPI_5_1_MPST_MEMORY_POWER_COMMAND_SET_MEMORY_POWER_STATE :: 0x02;
EFI_ACPI_5_1_MPST_MEMORY_POWER_COMMAND_GET_AVERAGE_POWER_CONSUMED :: 0x03;
EFI_ACPI_5_1_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_ENERGY_CONSUMED :: 0x04;

EFI_ACPI_5_1_MPST_MEMORY_POWER_STRUCTURE_FLAG_ENABLE :: 0x01;
EFI_ACPI_5_1_MPST_MEMORY_POWER_STRUCTURE_FLAG_POWER_MANAGED :: 0x02;
EFI_ACPI_5_1_MPST_MEMORY_POWER_STRUCTURE_FLAG_HOT_PLUGGABLE :: 0x04;

EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_MEMORY_CONTENT_PRESERVED :: 0x01;
EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_ENTRY :: 0x02;
EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_EXIT :: 0x04;

EFI_ACPI_5_1_MEMORY_TOPOLOGY_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_SOCKET :: 0x1;
EFI_ACPI_5_1_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_MEMORY_CONTROLLER :: 0x2;
EFI_ACPI_5_1_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_DIMM :: 0x3;

EFI_ACPI_5_1_BOOT_GRAPHICS_RESOURCE_TABLE_REVISION :: 1;

EFI_ACPI_5_1_BGRT_VERSION :: 0x01;

EFI_ACPI_5_1_BGRT_STATUS_NOT_DISPLAYED :: 0x00;
EFI_ACPI_5_1_BGRT_STATUS_DISPLAYED :: 0x01;

EFI_ACPI_5_1_BGRT_IMAGE_TYPE_BMP :: 0x00;

EFI_ACPI_5_1_FIRMWARE_PERFORMANCE_DATA_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_FPDT_RECORD_TYPE_FIRMWARE_BASIC_BOOT_POINTER :: 0x0000;
EFI_ACPI_5_1_FPDT_RECORD_TYPE_S3_PERFORMANCE_TABLE_POINTER :: 0x0001;

EFI_ACPI_5_1_FPDT_RECORD_REVISION_FIRMWARE_BASIC_BOOT_POINTER :: 0x01;
EFI_ACPI_5_1_FPDT_RECORD_REVISION_S3_PERFORMANCE_TABLE_POINTER :: 0x01;

EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_TYPE_S3_RESUME :: 0x0000;
EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_TYPE_S3_SUSPEND :: 0x0001;
EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_TYPE_FIRMWARE_BASIC_BOOT :: 0x0002;

EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_REVISION_S3_RESUME :: 0x01;
EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_REVISION_S3_SUSPEND :: 0x01;
EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_REVISION_FIRMWARE_BASIC_BOOT :: 0x02;

EFI_ACPI_5_1_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION :: 0x02;

EFI_ACPI_5_1_GTDT_TIMER_FLAG_TIMER_INTERRUPT_MODE :: BIT0;
EFI_ACPI_5_1_GTDT_TIMER_FLAG_TIMER_INTERRUPT_POLARITY :: BIT1;
EFI_ACPI_5_1_GTDT_TIMER_FLAG_ALWAYS_ON_CAPABILITY :: BIT2;

EFI_ACPI_5_1_GTDT_GT_BLOCK :: 0;
EFI_ACPI_5_1_GTDT_SBSA_GENERIC_WATCHDOG :: 1;

EFI_ACPI_5_1_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_MODE :: BIT0;
EFI_ACPI_5_1_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_POLARITY :: BIT1;

EFI_ACPI_5_1_GTDT_GT_BLOCK_COMMON_FLAG_SECURE_TIMER :: BIT0;
EFI_ACPI_5_1_GTDT_GT_BLOCK_COMMON_FLAG_ALWAYS_ON_CAPABILITY :: BIT1;

EFI_ACPI_5_1_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_MODE :: BIT0;
EFI_ACPI_5_1_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_POLARITY :: BIT1;
EFI_ACPI_5_1_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_SECURE_TIMER :: BIT2;

EFI_ACPI_5_1_BOOT_ERROR_RECORD_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_ERROR_SEVERITY_CORRECTABLE :: 0x00;
EFI_ACPI_5_1_ERROR_SEVERITY_FATAL :: 0x01;
EFI_ACPI_5_1_ERROR_SEVERITY_CORRECTED :: 0x02;
EFI_ACPI_5_1_ERROR_SEVERITY_NONE :: 0x03;

EFI_ACPI_5_1_GENERIC_ERROR_DATA_ENTRY_REVISION :: 0x0201;

EFI_ACPI_5_1_HARDWARE_ERROR_SOURCE_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION :: 0x00;
EFI_ACPI_5_1_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK :: 0x01;
EFI_ACPI_5_1_IA32_ARCHITECTURE_NMI_ERROR :: 0x02;
EFI_ACPI_5_1_PCI_EXPRESS_ROOT_PORT_AER :: 0x06;
EFI_ACPI_5_1_PCI_EXPRESS_DEVICE_AER :: 0x07;
EFI_ACPI_5_1_PCI_EXPRESS_BRIDGE_AER :: 0x08;
EFI_ACPI_5_1_GENERIC_HARDWARE_ERROR :: 0x09;

EFI_ACPI_5_1_ERROR_SOURCE_FLAG_FIRMWARE_FIRST :: 1 << 0;
EFI_ACPI_5_1_ERROR_SOURCE_FLAG_GLOBAL :: 1 << 1;

EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32 :: 0x00;
EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64 :: 0x01;
EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64 :: 0x02;

EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_POLLED :: 0x00;
EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT :: 0x01;
EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT :: 0x02;
EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_SCI :: 0x03;
EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_NMI :: 0x04;

EFI_ACPI_5_1_ERROR_RECORD_SERIALIZATION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_ERST_BEGIN_WRITE_OPERATION :: 0x00;
EFI_ACPI_5_1_ERST_BEGIN_READ_OPERATION :: 0x01;
EFI_ACPI_5_1_ERST_BEGIN_CLEAR_OPERATION :: 0x02;
EFI_ACPI_5_1_ERST_END_OPERATION :: 0x03;
EFI_ACPI_5_1_ERST_SET_RECORD_OFFSET :: 0x04;
EFI_ACPI_5_1_ERST_EXECUTE_OPERATION :: 0x05;
EFI_ACPI_5_1_ERST_CHECK_BUSY_STATUS :: 0x06;
EFI_ACPI_5_1_ERST_GET_COMMAND_STATUS :: 0x07;
EFI_ACPI_5_1_ERST_GET_RECORD_IDENTIFIER :: 0x08;
EFI_ACPI_5_1_ERST_SET_RECORD_IDENTIFIER :: 0x09;
EFI_ACPI_5_1_ERST_GET_RECORD_COUNT :: 0x0A;
EFI_ACPI_5_1_ERST_BEGIN_DUMMY_WRITE_OPERATION :: 0x0B;
EFI_ACPI_5_1_ERST_GET_ERROR_LOG_ADDRESS_RANGE :: 0x0D;
EFI_ACPI_5_1_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH :: 0x0E;
EFI_ACPI_5_1_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES :: 0x0F;

EFI_ACPI_5_1_ERST_STATUS_SUCCESS :: 0x00;
EFI_ACPI_5_1_ERST_STATUS_NOT_ENOUGH_SPACE :: 0x01;
EFI_ACPI_5_1_ERST_STATUS_HARDWARE_NOT_AVAILABLE :: 0x02;
EFI_ACPI_5_1_ERST_STATUS_FAILED :: 0x03;
EFI_ACPI_5_1_ERST_STATUS_RECORD_STORE_EMPTY :: 0x04;
EFI_ACPI_5_1_ERST_STATUS_RECORD_NOT_FOUND :: 0x05;

EFI_ACPI_5_1_ERST_READ_REGISTER :: 0x00;
EFI_ACPI_5_1_ERST_READ_REGISTER_VALUE :: 0x01;
EFI_ACPI_5_1_ERST_WRITE_REGISTER :: 0x02;
EFI_ACPI_5_1_ERST_WRITE_REGISTER_VALUE :: 0x03;
EFI_ACPI_5_1_ERST_NOOP :: 0x04;
EFI_ACPI_5_1_ERST_LOAD_VAR1 :: 0x05;
EFI_ACPI_5_1_ERST_LOAD_VAR2 :: 0x06;
EFI_ACPI_5_1_ERST_STORE_VAR1 :: 0x07;
EFI_ACPI_5_1_ERST_ADD :: 0x08;
EFI_ACPI_5_1_ERST_SUBTRACT :: 0x09;
EFI_ACPI_5_1_ERST_ADD_VALUE :: 0x0A;
EFI_ACPI_5_1_ERST_SUBTRACT_VALUE :: 0x0B;
EFI_ACPI_5_1_ERST_STALL :: 0x0C;
EFI_ACPI_5_1_ERST_STALL_WHILE_TRUE :: 0x0D;
EFI_ACPI_5_1_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE :: 0x0E;
EFI_ACPI_5_1_ERST_GOTO :: 0x0F;
EFI_ACPI_5_1_ERST_SET_SRC_ADDRESS_BASE :: 0x10;
EFI_ACPI_5_1_ERST_SET_DST_ADDRESS_BASE :: 0x11;
EFI_ACPI_5_1_ERST_MOVE_DATA :: 0x12;

EFI_ACPI_5_1_ERST_PRESERVE_REGISTER :: 0x01;

EFI_ACPI_5_1_ERROR_INJECTION_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_EINJ_BEGIN_INJECTION_OPERATION :: 0x00;
EFI_ACPI_5_1_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE :: 0x01;
EFI_ACPI_5_1_EINJ_SET_ERROR_TYPE :: 0x02;
EFI_ACPI_5_1_EINJ_GET_ERROR_TYPE :: 0x03;
EFI_ACPI_5_1_EINJ_END_OPERATION :: 0x04;
EFI_ACPI_5_1_EINJ_EXECUTE_OPERATION :: 0x05;
EFI_ACPI_5_1_EINJ_CHECK_BUSY_STATUS :: 0x06;
EFI_ACPI_5_1_EINJ_GET_COMMAND_STATUS :: 0x07;
EFI_ACPI_5_1_EINJ_TRIGGER_ERROR :: 0xFF;

EFI_ACPI_5_1_EINJ_STATUS_SUCCESS :: 0x00;
EFI_ACPI_5_1_EINJ_STATUS_UNKNOWN_FAILURE :: 0x01;
EFI_ACPI_5_1_EINJ_STATUS_INVALID_ACCESS :: 0x02;

EFI_ACPI_5_1_EINJ_ERROR_PROCESSOR_CORRECTABLE :: 1 << 0;
EFI_ACPI_5_1_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL :: 1 << 1;
EFI_ACPI_5_1_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL :: 1 << 2;
EFI_ACPI_5_1_EINJ_ERROR_MEMORY_CORRECTABLE :: 1 << 3;
EFI_ACPI_5_1_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL :: 1 << 4;
EFI_ACPI_5_1_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL :: 1 << 5;
EFI_ACPI_5_1_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE :: 1 << 6;
EFI_ACPI_5_1_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL :: 1 << 7;
EFI_ACPI_5_1_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL :: 1 << 8;
EFI_ACPI_5_1_EINJ_ERROR_PLATFORM_CORRECTABLE :: 1 << 9;
EFI_ACPI_5_1_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL :: 1 << 10;
EFI_ACPI_5_1_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL :: 1 << 11;

EFI_ACPI_5_1_EINJ_READ_REGISTER :: 0x00;
EFI_ACPI_5_1_EINJ_READ_REGISTER_VALUE :: 0x01;
EFI_ACPI_5_1_EINJ_WRITE_REGISTER :: 0x02;
EFI_ACPI_5_1_EINJ_WRITE_REGISTER_VALUE :: 0x03;
EFI_ACPI_5_1_EINJ_NOOP :: 0x04;

EFI_ACPI_5_1_EINJ_PRESERVE_REGISTER :: 0x01;

EFI_ACPI_5_1_PLATFORM_COMMUNICATION_CHANNEL_TABLE_REVISION :: 0x01;

EFI_ACPI_5_1_PCCT_FLAGS_SCI_DOORBELL :: BIT0;

EFI_ACPI_5_1_PCCT_SUBSPACE_TYPE_GENERIC :: 0x00;

EFI_ACPI_6_0_SYSTEM_MEMORY :: 0;
EFI_ACPI_6_0_SYSTEM_IO :: 1;
EFI_ACPI_6_0_PCI_CONFIGURATION_SPACE :: 2;
EFI_ACPI_6_0_EMBEDDED_CONTROLLER :: 3;
EFI_ACPI_6_0_SMBUS :: 4;
EFI_ACPI_6_0_PLATFORM_COMMUNICATION_CHANNEL :: 0x0A;
EFI_ACPI_6_0_FUNCTIONAL_FIXED_HARDWARE :: 0x7F;

EFI_ACPI_6_0_UNDEFINED :: 0;
EFI_ACPI_6_0_BYTE :: 1;
EFI_ACPI_6_0_WORD :: 2;
EFI_ACPI_6_0_DWORD :: 3;
EFI_ACPI_6_0_QWORD :: 4;

EFI_ACPI_6_0_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION :: 0x02;

EFI_ACPI_6_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION :: 0x06;
EFI_ACPI_6_0_FIXED_ACPI_DESCRIPTION_TABLE_MINOR_REVISION :: 0x00;

EFI_ACPI_6_0_PM_PROFILE_UNSPECIFIED :: 0;
EFI_ACPI_6_0_PM_PROFILE_DESKTOP :: 1;
EFI_ACPI_6_0_PM_PROFILE_MOBILE :: 2;
EFI_ACPI_6_0_PM_PROFILE_WORKSTATION :: 3;
EFI_ACPI_6_0_PM_PROFILE_ENTERPRISE_SERVER :: 4;
EFI_ACPI_6_0_PM_PROFILE_SOHO_SERVER :: 5;
EFI_ACPI_6_0_PM_PROFILE_APPLIANCE_PC :: 6;
EFI_ACPI_6_0_PM_PROFILE_PERFORMANCE_SERVER :: 7;
EFI_ACPI_6_0_PM_PROFILE_TABLET :: 8;

EFI_ACPI_6_0_LEGACY_DEVICES :: BIT0;
EFI_ACPI_6_0_8042 :: BIT1;
EFI_ACPI_6_0_VGA_NOT_PRESENT :: BIT2;
EFI_ACPI_6_0_MSI_NOT_SUPPORTED :: BIT3;
EFI_ACPI_6_0_PCIE_ASPM_CONTROLS :: BIT4;
EFI_ACPI_6_0_CMOS_RTC_NOT_PRESENT :: BIT5;

EFI_ACPI_6_0_ARM_PSCI_COMPLIANT :: BIT0;
EFI_ACPI_6_0_ARM_PSCI_USE_HVC :: BIT1;

EFI_ACPI_6_0_WBINVD :: BIT0;
EFI_ACPI_6_0_WBINVD_FLUSH :: BIT1;
EFI_ACPI_6_0_PROC_C1 :: BIT2;
EFI_ACPI_6_0_P_LVL2_UP :: BIT3;
EFI_ACPI_6_0_PWR_BUTTON :: BIT4;
EFI_ACPI_6_0_SLP_BUTTON :: BIT5;
EFI_ACPI_6_0_FIX_RTC :: BIT6;
EFI_ACPI_6_0_RTC_S4 :: BIT7;
EFI_ACPI_6_0_TMR_VAL_EXT :: BIT8;
EFI_ACPI_6_0_DCK_CAP :: BIT9;
EFI_ACPI_6_0_RESET_REG_SUP :: BIT10;
EFI_ACPI_6_0_SEALED_CASE :: BIT11;
EFI_ACPI_6_0_HEADLESS :: BIT12;
EFI_ACPI_6_0_CPU_SW_SLP :: BIT13;
EFI_ACPI_6_0_PCI_EXP_WAK :: BIT14;
EFI_ACPI_6_0_USE_PLATFORM_CLOCK :: BIT15;
EFI_ACPI_6_0_S4_RTC_STS_VALID :: BIT16;
EFI_ACPI_6_0_REMOTE_POWER_ON_CAPABLE :: BIT17;
EFI_ACPI_6_0_FORCE_APIC_CLUSTER_MODEL :: BIT18;
EFI_ACPI_6_0_FORCE_APIC_PHYSICAL_DESTINATION_MODE :: BIT19;
EFI_ACPI_6_0_HW_REDUCED_ACPI :: BIT20;
EFI_ACPI_6_0_LOW_POWER_S0_IDLE_CAPABLE :: BIT21;

EFI_ACPI_6_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION :: 0x02;

EFI_ACPI_6_0_S4BIOS_F :: BIT0;
EFI_ACPI_6_0_64BIT_WAKE_SUPPORTED_F :: BIT1;

EFI_ACPI_6_0_OSPM_64BIT_WAKE_F :: BIT0;

EFI_ACPI_6_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x02;
EFI_ACPI_6_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION :: 0x02;

EFI_ACPI_6_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION :: 0x04;

EFI_ACPI_6_0_PCAT_COMPAT :: BIT0;

EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC :: 0x00;
EFI_ACPI_6_0_IO_APIC :: 0x01;
EFI_ACPI_6_0_INTERRUPT_SOURCE_OVERRIDE :: 0x02;
EFI_ACPI_6_0_NON_MASKABLE_INTERRUPT_SOURCE :: 0x03;
EFI_ACPI_6_0_LOCAL_APIC_NMI :: 0x04;
EFI_ACPI_6_0_LOCAL_APIC_ADDRESS_OVERRIDE :: 0x05;
EFI_ACPI_6_0_IO_SAPIC :: 0x06;
EFI_ACPI_6_0_LOCAL_SAPIC :: 0x07;
EFI_ACPI_6_0_PLATFORM_INTERRUPT_SOURCES :: 0x08;
EFI_ACPI_6_0_PROCESSOR_LOCAL_X2APIC :: 0x09;
EFI_ACPI_6_0_LOCAL_X2APIC_NMI :: 0x0A;
EFI_ACPI_6_0_GIC :: 0x0B;
EFI_ACPI_6_0_GICD :: 0x0C;
EFI_ACPI_6_0_GIC_MSI_FRAME :: 0x0D;
EFI_ACPI_6_0_GICR :: 0x0E;
EFI_ACPI_6_0_GIC_ITS :: 0x0F;

EFI_ACPI_6_0_LOCAL_APIC_ENABLED :: BIT0;

EFI_ACPI_6_0_POLARITY :: 3 << 0;
EFI_ACPI_6_0_TRIGGER_MODE :: 3 << 2;

EFI_ACPI_6_0_CPEI_PROCESSOR_OVERRIDE :: BIT0;

EFI_ACPI_6_0_GIC_ENABLED :: BIT0;
EFI_ACPI_6_0_PERFORMANCE_INTERRUPT_MODEL :: BIT1;
EFI_ACPI_6_0_VGIC_MAINTENANCE_INTERRUPT_MODE_FLAGS :: BIT2;

EFI_ACPI_6_0_GIC_V1 :: 0x01;
EFI_ACPI_6_0_GIC_V2 :: 0x02;
EFI_ACPI_6_0_GIC_V3 :: 0x03;
EFI_ACPI_6_0_GIC_V4 :: 0x04;

EFI_ACPI_6_0_SPI_COUNT_BASE_SELECT :: BIT0;

EFI_ACPI_6_0_SMART_BATTERY_DESCRIPTION_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION :: 0x03;

EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY :: 0x00;
EFI_ACPI_6_0_MEMORY_AFFINITY :: 0x01;
EFI_ACPI_6_0_PROCESSOR_LOCAL_X2APIC_AFFINITY :: 0x02;
EFI_ACPI_6_0_GICC_AFFINITY :: 0x03;

EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED :: 1 << 0;

EFI_ACPI_6_0_MEMORY_ENABLED :: 1 << 0;
EFI_ACPI_6_0_MEMORY_HOT_PLUGGABLE :: 1 << 1;
EFI_ACPI_6_0_MEMORY_NONVOLATILE :: 1 << 2;

EFI_ACPI_6_0_GICC_ENABLED :: 1 << 0;

EFI_ACPI_6_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_CPEP_PROCESSOR_APIC_SAPIC :: 0x00;

EFI_ACPI_6_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_RAS_FEATURE_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_RASF_PCC_COMMAND_CODE_EXECUTE_RASF_COMMAND :: 0x01;

EFI_ACPI_6_0_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED :: 0x01;
EFI_ACPI_6_0_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED_AND_EXPOSED_TO_SOFTWARE :: 0x02;

EFI_ACPI_6_0_RASF_PATROL_SCRUB_COMMAND_GET_PATROL_PARAMETERS :: 0x01;
EFI_ACPI_6_0_RASF_PATROL_SCRUB_COMMAND_START_PATROL_SCRUBBER :: 0x02;
EFI_ACPI_6_0_RASF_PATROL_SCRUB_COMMAND_STOP_PATROL_SCRUBBER :: 0x03;

EFI_ACPI_6_0_MEMORY_POWER_STATE_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_MPST_PCC_COMMAND_CODE_EXECUTE_MPST_COMMAND :: 0x03;

EFI_ACPI_6_0_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_POWER_STATE :: 0x01;
EFI_ACPI_6_0_MPST_MEMORY_POWER_COMMAND_SET_MEMORY_POWER_STATE :: 0x02;
EFI_ACPI_6_0_MPST_MEMORY_POWER_COMMAND_GET_AVERAGE_POWER_CONSUMED :: 0x03;
EFI_ACPI_6_0_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_ENERGY_CONSUMED :: 0x04;

EFI_ACPI_6_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_ENABLE :: 0x01;
EFI_ACPI_6_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_POWER_MANAGED :: 0x02;
EFI_ACPI_6_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_HOT_PLUGGABLE :: 0x04;

EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_MEMORY_CONTENT_PRESERVED :: 0x01;
EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_ENTRY :: 0x02;
EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_EXIT :: 0x04;

EFI_ACPI_6_0_MEMORY_TOPOLOGY_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_SOCKET :: 0x1;
EFI_ACPI_6_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_MEMORY_CONTROLLER :: 0x2;
EFI_ACPI_6_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_DIMM :: 0x3;

EFI_ACPI_6_0_BOOT_GRAPHICS_RESOURCE_TABLE_REVISION :: 1;

EFI_ACPI_6_0_BGRT_VERSION :: 0x01;

EFI_ACPI_6_0_BGRT_STATUS_NOT_DISPLAYED :: 0x00;
EFI_ACPI_6_0_BGRT_STATUS_DISPLAYED :: 0x01;

EFI_ACPI_6_0_BGRT_IMAGE_TYPE_BMP :: 0x00;

EFI_ACPI_6_0_FIRMWARE_PERFORMANCE_DATA_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_FPDT_RECORD_TYPE_FIRMWARE_BASIC_BOOT_POINTER :: 0x0000;
EFI_ACPI_6_0_FPDT_RECORD_TYPE_S3_PERFORMANCE_TABLE_POINTER :: 0x0001;

EFI_ACPI_6_0_FPDT_RECORD_REVISION_FIRMWARE_BASIC_BOOT_POINTER :: 0x01;
EFI_ACPI_6_0_FPDT_RECORD_REVISION_S3_PERFORMANCE_TABLE_POINTER :: 0x01;

EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_TYPE_S3_RESUME :: 0x0000;
EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_TYPE_S3_SUSPEND :: 0x0001;
EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_TYPE_FIRMWARE_BASIC_BOOT :: 0x0002;

EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_REVISION_S3_RESUME :: 0x01;
EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_REVISION_S3_SUSPEND :: 0x01;
EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_REVISION_FIRMWARE_BASIC_BOOT :: 0x02;

EFI_ACPI_6_0_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION :: 0x02;

EFI_ACPI_6_0_GTDT_TIMER_FLAG_TIMER_INTERRUPT_MODE :: BIT0;
EFI_ACPI_6_0_GTDT_TIMER_FLAG_TIMER_INTERRUPT_POLARITY :: BIT1;
EFI_ACPI_6_0_GTDT_TIMER_FLAG_ALWAYS_ON_CAPABILITY :: BIT2;

EFI_ACPI_6_0_GTDT_GT_BLOCK :: 0;
EFI_ACPI_6_0_GTDT_SBSA_GENERIC_WATCHDOG :: 1;

EFI_ACPI_6_0_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_MODE :: BIT0;
EFI_ACPI_6_0_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_POLARITY :: BIT1;

EFI_ACPI_6_0_GTDT_GT_BLOCK_COMMON_FLAG_SECURE_TIMER :: BIT0;
EFI_ACPI_6_0_GTDT_GT_BLOCK_COMMON_FLAG_ALWAYS_ON_CAPABILITY :: BIT1;

EFI_ACPI_6_0_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_MODE :: BIT0;
EFI_ACPI_6_0_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_POLARITY :: BIT1;
EFI_ACPI_6_0_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_SECURE_TIMER :: BIT2;

EFI_ACPI_6_0_NVDIMM_FIRMWARE_INTERFACE_TABLE_REVISION :: 0x1;

EFI_ACPI_6_0_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE_TYPE :: 0;
EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_TO_SYSTEM_ADDRESS_RANGE_MAP_STRUCTURE_TYPE :: 1;
EFI_ACPI_6_0_NFIT_INTERLEAVE_STRUCTURE_TYPE :: 2;
EFI_ACPI_6_0_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE_TYPE :: 3;
EFI_ACPI_6_0_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE_TYPE :: 4;
EFI_ACPI_6_0_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE_TYPE :: 5;
EFI_ACPI_6_0_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE_TYPE :: 6;

EFI_ACPI_6_0_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_CONTROL_REGION_FOR_MANAGEMENT :: BIT0;
EFI_ACPI_6_0_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_PROXIMITY_DOMAIN_VALID :: BIT1;

EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_PREVIOUS_SAVE_FAIL :: BIT0;
EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_LAST_RESTORE_FAIL :: BIT1;
EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_PLATFORM_FLUSH_FAIL :: BIT2;
EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_NOT_ARMED_PRIOR_TO_OSPM_HAND_OFF :: BIT3;
EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_SMART_HEALTH_EVENTS_PRIOR_OSPM_HAND_OFF :: BIT4;
EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_ENABLED_TO_NOTIFY_OSPM_ON_SMART_HEALTH_EVENTS :: BIT5;

EFI_ACPI_6_0_NFIT_NVDIMM_CONTROL_REGION_FLAGS_BLOCK_DATA_WINDOWS_BUFFERED :: BIT0;

EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_ERROR_SEVERITY_CORRECTABLE :: 0x00;
EFI_ACPI_6_0_ERROR_SEVERITY_FATAL :: 0x01;
EFI_ACPI_6_0_ERROR_SEVERITY_CORRECTED :: 0x02;
EFI_ACPI_6_0_ERROR_SEVERITY_NONE :: 0x03;

EFI_ACPI_6_0_GENERIC_ERROR_DATA_ENTRY_REVISION :: 0x0201;

EFI_ACPI_6_0_HARDWARE_ERROR_SOURCE_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION :: 0x00;
EFI_ACPI_6_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK :: 0x01;
EFI_ACPI_6_0_IA32_ARCHITECTURE_NMI_ERROR :: 0x02;
EFI_ACPI_6_0_PCI_EXPRESS_ROOT_PORT_AER :: 0x06;
EFI_ACPI_6_0_PCI_EXPRESS_DEVICE_AER :: 0x07;
EFI_ACPI_6_0_PCI_EXPRESS_BRIDGE_AER :: 0x08;
EFI_ACPI_6_0_GENERIC_HARDWARE_ERROR :: 0x09;

EFI_ACPI_6_0_ERROR_SOURCE_FLAG_FIRMWARE_FIRST :: 1 << 0;
EFI_ACPI_6_0_ERROR_SOURCE_FLAG_GLOBAL :: 1 << 1;

EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32 :: 0x00;
EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64 :: 0x01;
EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64 :: 0x02;

EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_POLLED :: 0x00;
EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT :: 0x01;
EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT :: 0x02;
EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_SCI :: 0x03;
EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_NMI :: 0x04;
EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_CMCI :: 0x05;
EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_MCE :: 0x06;
EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_GPIO_SIGNAL :: 0x07;

EFI_ACPI_6_0_ERROR_RECORD_SERIALIZATION_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_ERST_BEGIN_WRITE_OPERATION :: 0x00;
EFI_ACPI_6_0_ERST_BEGIN_READ_OPERATION :: 0x01;
EFI_ACPI_6_0_ERST_BEGIN_CLEAR_OPERATION :: 0x02;
EFI_ACPI_6_0_ERST_END_OPERATION :: 0x03;
EFI_ACPI_6_0_ERST_SET_RECORD_OFFSET :: 0x04;
EFI_ACPI_6_0_ERST_EXECUTE_OPERATION :: 0x05;
EFI_ACPI_6_0_ERST_CHECK_BUSY_STATUS :: 0x06;
EFI_ACPI_6_0_ERST_GET_COMMAND_STATUS :: 0x07;
EFI_ACPI_6_0_ERST_GET_RECORD_IDENTIFIER :: 0x08;
EFI_ACPI_6_0_ERST_SET_RECORD_IDENTIFIER :: 0x09;
EFI_ACPI_6_0_ERST_GET_RECORD_COUNT :: 0x0A;
EFI_ACPI_6_0_ERST_BEGIN_DUMMY_WRITE_OPERATION :: 0x0B;
EFI_ACPI_6_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE :: 0x0D;
EFI_ACPI_6_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH :: 0x0E;
EFI_ACPI_6_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES :: 0x0F;

EFI_ACPI_6_0_ERST_STATUS_SUCCESS :: 0x00;
EFI_ACPI_6_0_ERST_STATUS_NOT_ENOUGH_SPACE :: 0x01;
EFI_ACPI_6_0_ERST_STATUS_HARDWARE_NOT_AVAILABLE :: 0x02;
EFI_ACPI_6_0_ERST_STATUS_FAILED :: 0x03;
EFI_ACPI_6_0_ERST_STATUS_RECORD_STORE_EMPTY :: 0x04;
EFI_ACPI_6_0_ERST_STATUS_RECORD_NOT_FOUND :: 0x05;

EFI_ACPI_6_0_ERST_READ_REGISTER :: 0x00;
EFI_ACPI_6_0_ERST_READ_REGISTER_VALUE :: 0x01;
EFI_ACPI_6_0_ERST_WRITE_REGISTER :: 0x02;
EFI_ACPI_6_0_ERST_WRITE_REGISTER_VALUE :: 0x03;
EFI_ACPI_6_0_ERST_NOOP :: 0x04;
EFI_ACPI_6_0_ERST_LOAD_VAR1 :: 0x05;
EFI_ACPI_6_0_ERST_LOAD_VAR2 :: 0x06;
EFI_ACPI_6_0_ERST_STORE_VAR1 :: 0x07;
EFI_ACPI_6_0_ERST_ADD :: 0x08;
EFI_ACPI_6_0_ERST_SUBTRACT :: 0x09;
EFI_ACPI_6_0_ERST_ADD_VALUE :: 0x0A;
EFI_ACPI_6_0_ERST_SUBTRACT_VALUE :: 0x0B;
EFI_ACPI_6_0_ERST_STALL :: 0x0C;
EFI_ACPI_6_0_ERST_STALL_WHILE_TRUE :: 0x0D;
EFI_ACPI_6_0_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE :: 0x0E;
EFI_ACPI_6_0_ERST_GOTO :: 0x0F;
EFI_ACPI_6_0_ERST_SET_SRC_ADDRESS_BASE :: 0x10;
EFI_ACPI_6_0_ERST_SET_DST_ADDRESS_BASE :: 0x11;
EFI_ACPI_6_0_ERST_MOVE_DATA :: 0x12;

EFI_ACPI_6_0_ERST_PRESERVE_REGISTER :: 0x01;

EFI_ACPI_6_0_ERROR_INJECTION_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_EINJ_BEGIN_INJECTION_OPERATION :: 0x00;
EFI_ACPI_6_0_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE :: 0x01;
EFI_ACPI_6_0_EINJ_SET_ERROR_TYPE :: 0x02;
EFI_ACPI_6_0_EINJ_GET_ERROR_TYPE :: 0x03;
EFI_ACPI_6_0_EINJ_END_OPERATION :: 0x04;
EFI_ACPI_6_0_EINJ_EXECUTE_OPERATION :: 0x05;
EFI_ACPI_6_0_EINJ_CHECK_BUSY_STATUS :: 0x06;
EFI_ACPI_6_0_EINJ_GET_COMMAND_STATUS :: 0x07;
EFI_ACPI_6_0_EINJ_TRIGGER_ERROR :: 0xFF;

EFI_ACPI_6_0_EINJ_STATUS_SUCCESS :: 0x00;
EFI_ACPI_6_0_EINJ_STATUS_UNKNOWN_FAILURE :: 0x01;
EFI_ACPI_6_0_EINJ_STATUS_INVALID_ACCESS :: 0x02;

EFI_ACPI_6_0_EINJ_ERROR_PROCESSOR_CORRECTABLE :: 1 << 0;
EFI_ACPI_6_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL :: 1 << 1;
EFI_ACPI_6_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL :: 1 << 2;
EFI_ACPI_6_0_EINJ_ERROR_MEMORY_CORRECTABLE :: 1 << 3;
EFI_ACPI_6_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL :: 1 << 4;
EFI_ACPI_6_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL :: 1 << 5;
EFI_ACPI_6_0_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE :: 1 << 6;
EFI_ACPI_6_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL :: 1 << 7;
EFI_ACPI_6_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL :: 1 << 8;
EFI_ACPI_6_0_EINJ_ERROR_PLATFORM_CORRECTABLE :: 1 << 9;
EFI_ACPI_6_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL :: 1 << 10;
EFI_ACPI_6_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL :: 1 << 11;

EFI_ACPI_6_0_EINJ_READ_REGISTER :: 0x00;
EFI_ACPI_6_0_EINJ_READ_REGISTER_VALUE :: 0x01;
EFI_ACPI_6_0_EINJ_WRITE_REGISTER :: 0x02;
EFI_ACPI_6_0_EINJ_WRITE_REGISTER_VALUE :: 0x03;
EFI_ACPI_6_0_EINJ_NOOP :: 0x04;

EFI_ACPI_6_0_EINJ_PRESERVE_REGISTER :: 0x01;

EFI_ACPI_6_0_PLATFORM_COMMUNICATION_CHANNEL_TABLE_REVISION :: 0x01;

EFI_ACPI_6_0_PCCT_FLAGS_SCI_DOORBELL :: BIT0;

EFI_ACPI_6_0_PCCT_SUBSPACE_TYPE_GENERIC :: 0x00;
EFI_ACPI_6_0_PCCT_SUBSPACE_TYPE_1_HW_REDUCED_COMMUNICATIONS :: 0x01;
EFI_ACPI_6_0_PCCT_SUBSPACE_TYPE_2_HW_REDUCED_COMMUNICATIONS :: 0x02;

EFI_ACPI_6_0_PCCT_SUBSPACE_DOORBELL_INTERRUPT_FLAGS_POLARITY :: BIT0;
EFI_ACPI_6_0_PCCT_SUBSPACE_DOORBELL_INTERRUPT_FLAGS_MODE :: BIT1;

HARDWARE_DEVICE_PATH :: 0x01;

HW_PCI_DP :: 0x01;

HW_PCCARD_DP :: 0x02;

HW_MEMMAP_DP :: 0x03;

HW_VENDOR_DP :: 0x04;

HW_CONTROLLER_DP :: 0x05;

HW_BMC_DP :: 0x06;

ACPI_DEVICE_PATH :: 0x02;

ACPI_DP :: 0x01;

ACPI_EXTENDED_DP :: 0x02;

PNP_EISA_ID_CONST :: 0x41d0;

PNP_EISA_ID_MASK :: 0xffff;

ACPI_ADR_DP :: 0x03;

ACPI_ADR_DISPLAY_TYPE_OTHER :: 0;
ACPI_ADR_DISPLAY_TYPE_VGA :: 1;
ACPI_ADR_DISPLAY_TYPE_TV :: 2;
ACPI_ADR_DISPLAY_TYPE_EXTERNAL_DIGITAL :: 3;
ACPI_ADR_DISPLAY_TYPE_INTERNAL_DIGITAL :: 4;

MESSAGING_DEVICE_PATH :: 0x03;

MSG_ATAPI_DP :: 0x01;

MSG_SCSI_DP :: 0x02;

MSG_FIBRECHANNEL_DP :: 0x03;

MSG_FIBRECHANNELEX_DP :: 0x15;

MSG_1394_DP :: 0x04;

MSG_USB_DP :: 0x05;

MSG_USB_CLASS_DP :: 0x0f;

MSG_USB_WWID_DP :: 0x10;

MSG_DEVICE_LOGICAL_UNIT_DP :: 0x11;

MSG_SATA_DP :: 0x12;

SATA_HBA_DIRECT_CONNECT_FLAG :: 0x8000;

MSG_I2O_DP :: 0x06;

MSG_MAC_ADDR_DP :: 0x0b;

MSG_IPv4_DP :: 0x0c;

MSG_IPv6_DP :: 0x0d;

MSG_INFINIBAND_DP :: 0x09;

INFINIBAND_RESOURCE_FLAG_IOC_SERVICE :: 0x01;
INFINIBAND_RESOURCE_FLAG_EXTENDED_BOOT_ENVIRONMENT :: 0x02;
INFINIBAND_RESOURCE_FLAG_CONSOLE_PROTOCOL :: 0x04;
INFINIBAND_RESOURCE_FLAG_STORAGE_PROTOCOL :: 0x08;
INFINIBAND_RESOURCE_FLAG_NETWORK_PROTOCOL :: 0x10;

MSG_UART_DP :: 0x0e;

MSG_VENDOR_DP :: 0x0a;

UART_FLOW_CONTROL_HARDWARE :: 0x00000001;
UART_FLOW_CONTROL_XON_XOFF :: 0x00000010;

MSG_SASEX_DP :: 0x16;

MSG_NVME_NAMESPACE_DP :: 0x17;

MSG_DNS_DP :: 0x1F;

MSG_URI_DP :: 0x18;

MSG_UFS_DP :: 0x19;

MSG_SD_DP :: 0x1A;

MSG_EMMC_DP :: 0x1D;

MSG_ISCSI_DP :: 0x13;

ISCSI_LOGIN_OPTION_NO_HEADER_DIGEST :: 0x0000;
ISCSI_LOGIN_OPTION_HEADER_DIGEST_USING_CRC32C :: 0x0002;
ISCSI_LOGIN_OPTION_NO_DATA_DIGEST :: 0x0000;
ISCSI_LOGIN_OPTION_DATA_DIGEST_USING_CRC32C :: 0x0008;
ISCSI_LOGIN_OPTION_AUTHMETHOD_CHAP :: 0x0000;
ISCSI_LOGIN_OPTION_AUTHMETHOD_NON :: 0x1000;
ISCSI_LOGIN_OPTION_CHAP_BI :: 0x0000;
ISCSI_LOGIN_OPTION_CHAP_UNI :: 0x2000;

MSG_VLAN_DP :: 0x14;

MSG_BLUETOOTH_DP :: 0x1b;

MSG_WIFI_DP :: 0x1C;

MSG_BLUETOOTH_LE_DP :: 0x1E;

MEDIA_DEVICE_PATH :: 0x04;

MEDIA_HARDDRIVE_DP :: 0x01;

MBR_TYPE_PCAT :: 0x01;
MBR_TYPE_EFI_PARTITION_TABLE_HEADER :: 0x02;

NO_DISK_SIGNATURE :: 0x00;
SIGNATURE_TYPE_MBR :: 0x01;
SIGNATURE_TYPE_GUID :: 0x02;

MEDIA_CDROM_DP :: 0x02;

MEDIA_VENDOR_DP :: 0x03;

MEDIA_FILEPATH_DP :: 0x04;

MEDIA_PROTOCOL_DP :: 0x05;

MEDIA_PIWG_FW_FILE_DP :: 0x06;

MEDIA_PIWG_FW_VOL_DP :: 0x07;

MEDIA_RELATIVE_OFFSET_RANGE_DP :: 0x08;

MEDIA_RAM_DISK_DP :: 0x09;

BBS_DEVICE_PATH :: 0x05;

BBS_BBS_DP :: 0x01;

BBS_TYPE_FLOPPY :: 0x01;
BBS_TYPE_HARDDRIVE :: 0x02;
BBS_TYPE_CDROM :: 0x03;
BBS_TYPE_PCMCIA :: 0x04;
BBS_TYPE_USB :: 0x05;
BBS_TYPE_EMBEDDED_NETWORK :: 0x06;
BBS_TYPE_BEV :: 0x80;
BBS_TYPE_UNKNOWN :: 0xFF;

END_DEVICE_PATH_TYPE :: 0x7f;
END_ENTIRE_DEVICE_PATH_SUBTYPE :: 0xFF;
END_INSTANCE_DEVICE_PATH_SUBTYPE :: 0x01;

CHAR_BACKSPACE :: 0x0008;
CHAR_TAB :: 0x0009;
CHAR_LINEFEED :: 0x000A;
CHAR_CARRIAGE_RETURN :: 0x000D;

SCAN_NULL :: 0x0000;
SCAN_UP :: 0x0001;
SCAN_DOWN :: 0x0002;
SCAN_RIGHT :: 0x0003;
SCAN_LEFT :: 0x0004;
SCAN_HOME :: 0x0005;
SCAN_END :: 0x0006;
SCAN_INSERT :: 0x0007;
SCAN_DELETE :: 0x0008;
SCAN_PAGE_UP :: 0x0009;
SCAN_PAGE_DOWN :: 0x000A;
SCAN_F1 :: 0x000B;
SCAN_F2 :: 0x000C;
SCAN_F3 :: 0x000D;
SCAN_F4 :: 0x000E;
SCAN_F5 :: 0x000F;
SCAN_F6 :: 0x0010;
SCAN_F7 :: 0x0011;
SCAN_F8 :: 0x0012;
SCAN_F9 :: 0x0013;
SCAN_F10 :: 0x0014;
SCAN_ESC :: 0x0017;

EFI_SHIFT_STATE_VALID :: 0x80000000;
EFI_RIGHT_SHIFT_PRESSED :: 0x00000001;
EFI_LEFT_SHIFT_PRESSED :: 0x00000002;
EFI_RIGHT_CONTROL_PRESSED :: 0x00000004;
EFI_LEFT_CONTROL_PRESSED :: 0x00000008;
EFI_RIGHT_ALT_PRESSED :: 0x00000010;
EFI_LEFT_ALT_PRESSED :: 0x00000020;
EFI_RIGHT_LOGO_PRESSED :: 0x00000040;
EFI_LEFT_LOGO_PRESSED :: 0x00000080;
EFI_MENU_KEY_PRESSED :: 0x00000100;
EFI_SYS_REQ_PRESSED :: 0x00000200;

EFI_TOGGLE_STATE_VALID :: 0x80;
EFI_KEY_STATE_EXPOSED :: 0x40;
EFI_SCROLL_LOCK_ACTIVE :: 0x01;
EFI_NUM_LOCK_ACTIVE :: 0x02;
EFI_CAPS_LOCK_ACTIVE :: 0x04;

SCAN_F11 :: 0x0015;
SCAN_F12 :: 0x0016;
SCAN_PAUSE :: 0x0048;
SCAN_F13 :: 0x0068;
SCAN_F14 :: 0x0069;
SCAN_F15 :: 0x006A;
SCAN_F16 :: 0x006B;
SCAN_F17 :: 0x006C;
SCAN_F18 :: 0x006D;
SCAN_F19 :: 0x006E;
SCAN_F20 :: 0x006F;
SCAN_F21 :: 0x0070;
SCAN_F22 :: 0x0071;
SCAN_F23 :: 0x0072;
SCAN_F24 :: 0x0073;
SCAN_MUTE :: 0x007F;
SCAN_VOLUME_UP :: 0x0080;
SCAN_VOLUME_DOWN :: 0x0081;
SCAN_BRIGHTNESS_UP :: 0x0100;
SCAN_BRIGHTNESS_DOWN :: 0x0101;
SCAN_SUSPEND :: 0x0102;
SCAN_HIBERNATE :: 0x0103;
SCAN_TOGGLE_DISPLAY :: 0x0104;
SCAN_RECOVERY :: 0x0105;
SCAN_EJECT :: 0x0106;

BOXDRAW_HORIZONTAL :: 0x2500;
BOXDRAW_VERTICAL :: 0x2502;
BOXDRAW_DOWN_RIGHT :: 0x250c;
BOXDRAW_DOWN_LEFT :: 0x2510;
BOXDRAW_UP_RIGHT :: 0x2514;
BOXDRAW_UP_LEFT :: 0x2518;
BOXDRAW_VERTICAL_RIGHT :: 0x251c;
BOXDRAW_VERTICAL_LEFT :: 0x2524;
BOXDRAW_DOWN_HORIZONTAL :: 0x252c;
BOXDRAW_UP_HORIZONTAL :: 0x2534;
BOXDRAW_VERTICAL_HORIZONTAL :: 0x253c;
BOXDRAW_DOUBLE_HORIZONTAL :: 0x2550;
BOXDRAW_DOUBLE_VERTICAL :: 0x2551;
BOXDRAW_DOWN_RIGHT_DOUBLE :: 0x2552;
BOXDRAW_DOWN_DOUBLE_RIGHT :: 0x2553;
BOXDRAW_DOUBLE_DOWN_RIGHT :: 0x2554;
BOXDRAW_DOWN_LEFT_DOUBLE :: 0x2555;
BOXDRAW_DOWN_DOUBLE_LEFT :: 0x2556;
BOXDRAW_DOUBLE_DOWN_LEFT :: 0x2557;
BOXDRAW_UP_RIGHT_DOUBLE :: 0x2558;
BOXDRAW_UP_DOUBLE_RIGHT :: 0x2559;
BOXDRAW_DOUBLE_UP_RIGHT :: 0x255a;
BOXDRAW_UP_LEFT_DOUBLE :: 0x255b;
BOXDRAW_UP_DOUBLE_LEFT :: 0x255c;
BOXDRAW_DOUBLE_UP_LEFT :: 0x255d;
BOXDRAW_VERTICAL_RIGHT_DOUBLE :: 0x255e;
BOXDRAW_VERTICAL_DOUBLE_RIGHT :: 0x255f;
BOXDRAW_DOUBLE_VERTICAL_RIGHT :: 0x2560;
BOXDRAW_VERTICAL_LEFT_DOUBLE :: 0x2561;
BOXDRAW_VERTICAL_DOUBLE_LEFT :: 0x2562;
BOXDRAW_DOUBLE_VERTICAL_LEFT :: 0x2563;
BOXDRAW_DOWN_HORIZONTAL_DOUBLE :: 0x2564;
BOXDRAW_DOWN_DOUBLE_HORIZONTAL :: 0x2565;
BOXDRAW_DOUBLE_DOWN_HORIZONTAL :: 0x2566;
BOXDRAW_UP_HORIZONTAL_DOUBLE :: 0x2567;
BOXDRAW_UP_DOUBLE_HORIZONTAL :: 0x2568;
BOXDRAW_DOUBLE_UP_HORIZONTAL :: 0x2569;
BOXDRAW_VERTICAL_HORIZONTAL_DOUBLE :: 0x256a;
BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL :: 0x256b;
BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL :: 0x256c;

BLOCKELEMENT_FULL_BLOCK :: 0x2588;
BLOCKELEMENT_LIGHT_SHADE :: 0x2591;

GEOMETRICSHAPE_UP_TRIANGLE :: 0x25b2;
GEOMETRICSHAPE_RIGHT_TRIANGLE :: 0x25ba;
GEOMETRICSHAPE_DOWN_TRIANGLE :: 0x25bc;
GEOMETRICSHAPE_LEFT_TRIANGLE :: 0x25c4;

ARROW_LEFT :: 0x2190;
ARROW_UP :: 0x2191;
ARROW_RIGHT :: 0x2192;
ARROW_DOWN :: 0x2193;

EFI_BLACK :: 0x00;
EFI_BLUE :: 0x01;
EFI_GREEN :: 0x02;
EFI_CYAN :: EFI_BLUE | EFI_GREEN;
EFI_RED :: 0x04;
EFI_MAGENTA :: EFI_BLUE | EFI_RED;
EFI_BROWN :: EFI_GREEN | EFI_RED;
EFI_LIGHTGRAY :: EFI_BLUE | EFI_GREEN | EFI_RED;
EFI_BRIGHT :: 0x08;
EFI_DARKGRAY :: EFI_BLACK | EFI_BRIGHT;
EFI_LIGHTBLUE :: EFI_BLUE | EFI_BRIGHT;
EFI_LIGHTGREEN :: EFI_GREEN | EFI_BRIGHT;
EFI_LIGHTCYAN :: EFI_CYAN | EFI_BRIGHT;
EFI_LIGHTRED :: EFI_RED | EFI_BRIGHT;
EFI_LIGHTMAGENTA :: EFI_MAGENTA | EFI_BRIGHT;
EFI_YELLOW :: EFI_BROWN | EFI_BRIGHT;
EFI_WHITE :: EFI_BLUE | EFI_GREEN | EFI_RED | EFI_BRIGHT;

EFI_BACKGROUND_BLACK :: 0x00;
EFI_BACKGROUND_BLUE :: 0x10;
EFI_BACKGROUND_GREEN :: 0x20;
EFI_BACKGROUND_CYAN :: EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN;
EFI_BACKGROUND_RED :: 0x40;
EFI_BACKGROUND_MAGENTA :: EFI_BACKGROUND_BLUE | EFI_BACKGROUND_RED;
EFI_BACKGROUND_BROWN :: EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED;
EFI_BACKGROUND_LIGHTGRAY :: EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED;

EFI_WIDE_ATTRIBUTE :: 0x80;

EFI_TIME_ADJUST_DAYLIGHT :: 0x01;
EFI_TIME_IN_DAYLIGHT :: 0x02;

EFI_UNSPECIFIED_TIMEZONE :: 0x07FF;

EFI_MEMORY_UC :: 0x0000000000000001;
EFI_MEMORY_WC :: 0x0000000000000002;
EFI_MEMORY_WT :: 0x0000000000000004;
EFI_MEMORY_WB :: 0x0000000000000008;
EFI_MEMORY_UCE :: 0x0000000000000010;

EFI_MEMORY_WP :: 0x0000000000001000;
EFI_MEMORY_RP :: 0x0000000000002000;
EFI_MEMORY_XP :: 0x0000000000004000;
EFI_MEMORY_RO :: 0x0000000000020000;

EFI_MEMORY_NV :: 0x0000000000008000;

EFI_MEMORY_MORE_RELIABLE :: 0x0000000000010000;

EFI_MEMORY_RUNTIME :: 0x8000000000000000;

EFI_MEMORY_DESCRIPTOR_VERSION :: 1;

EFI_OPTIONAL_PTR :: 0x00000001;

EVT_TIMER :: 0x80000000;
EVT_RUNTIME :: 0x40000000;
EVT_NOTIFY_WAIT :: 0x00000100;
EVT_NOTIFY_SIGNAL :: 0x00000200;

EVT_SIGNAL_EXIT_BOOT_SERVICES :: 0x00000201;
EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE :: 0x60000202;

EVT_RUNTIME_CONTEXT :: 0x20000000;

TPL_APPLICATION :: 4;
TPL_CALLBACK :: 8;
TPL_NOTIFY :: 16;
TPL_HIGH_LEVEL :: 31;

EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL :: 0x00000001;
EFI_OPEN_PROTOCOL_GET_PROTOCOL :: 0x00000002;
EFI_OPEN_PROTOCOL_TEST_PROTOCOL :: 0x00000004;
EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER :: 0x00000008;
EFI_OPEN_PROTOCOL_BY_DRIVER :: 0x00000010;
EFI_OPEN_PROTOCOL_EXCLUSIVE :: 0x00000020;

CAPSULE_FLAGS_PERSIST_ACROSS_RESET :: 0x00010000;
CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE :: 0x00020000;
CAPSULE_FLAGS_INITIATE_RESET :: 0x00040000;

EFI_OS_INDICATIONS_BOOT_TO_FW_UI :: 0x0000000000000001;
EFI_OS_INDICATIONS_TIMESTAMP_REVOCATION :: 0x0000000000000002;
EFI_OS_INDICATIONS_FILE_CAPSULE_DELIVERY_SUPPORTED :: 0x0000000000000004;
EFI_OS_INDICATIONS_FMP_CAPSULE_SUPPORTED :: 0x0000000000000008;
EFI_OS_INDICATIONS_CAPSULE_RESULT_VAR_SUPPORTED :: 0x0000000000000010;
EFI_OS_INDICATIONS_START_PLATFORM_RECOVERY :: 0x0000000000000040;

EFI_2_70_SYSTEM_TABLE_REVISION :: (2 << 16) | (70);
EFI_2_60_SYSTEM_TABLE_REVISION :: (2 << 16) | (60);
EFI_2_50_SYSTEM_TABLE_REVISION :: (2 << 16) | (50);
EFI_2_40_SYSTEM_TABLE_REVISION :: (2 << 16) | (40);
EFI_2_31_SYSTEM_TABLE_REVISION :: (2 << 16) | (31);
EFI_2_30_SYSTEM_TABLE_REVISION :: (2 << 16) | (30);
EFI_2_20_SYSTEM_TABLE_REVISION :: (2 << 16) | (20);
EFI_2_10_SYSTEM_TABLE_REVISION :: (2 << 16) | (10);
EFI_2_00_SYSTEM_TABLE_REVISION :: (2 << 16) | (0x0 /* 00 */);
EFI_1_10_SYSTEM_TABLE_REVISION :: (1 << 16) | (10);
EFI_1_02_SYSTEM_TABLE_REVISION :: (1 << 16) | (0x2 /* 02 */);
EFI_SYSTEM_TABLE_REVISION :: EFI_2_70_SYSTEM_TABLE_REVISION;
EFI_SPECIFICATION_VERSION :: EFI_SYSTEM_TABLE_REVISION;

EFI_RUNTIME_SERVICES_REVISION :: EFI_SPECIFICATION_VERSION;

EFI_BOOT_SERVICES_REVISION :: EFI_SPECIFICATION_VERSION;

LOAD_OPTION_ACTIVE :: 0x00000001;
LOAD_OPTION_FORCE_RECONNECT :: 0x00000002;
LOAD_OPTION_HIDDEN :: 0x00000008;
LOAD_OPTION_CATEGORY :: 0x00001F00;

LOAD_OPTION_CATEGORY_BOOT :: 0x00000000;
LOAD_OPTION_CATEGORY_APP :: 0x00000100;

EFI_BOOT_OPTION_SUPPORT_KEY :: 0x00000001;
EFI_BOOT_OPTION_SUPPORT_APP :: 0x00000002;
EFI_BOOT_OPTION_SUPPORT_SYSPREP :: 0x00000010;
EFI_BOOT_OPTION_SUPPORT_COUNT :: 0x00000300;

PXE_CPBSIZE_NOT_USED :: 0;
PXE_DBSIZE_NOT_USED :: 0;
PXE_CPBADDR_NOT_USED :: cast(PXE_UINT64) 0;
PXE_DBADDR_NOT_USED :: cast(PXE_UINT64) 0;

PXE_FALSE :: 0;
PXE_TRUE :: !PXE_FALSE;

PXE_OPCODE_GET_STATE :: 0x0000;

PXE_OPCODE_START :: 0x0001;

PXE_OPCODE_STOP :: 0x0002;

PXE_OPCODE_GET_INIT_INFO :: 0x0003;

PXE_OPCODE_GET_CONFIG_INFO :: 0x0004;

PXE_OPCODE_INITIALIZE :: 0x0005;

PXE_OPCODE_RESET :: 0x0006;

PXE_OPCODE_SHUTDOWN :: 0x0007;

PXE_OPCODE_INTERRUPT_ENABLES :: 0x0008;

PXE_OPCODE_RECEIVE_FILTERS :: 0x0009;

PXE_OPCODE_STATION_ADDRESS :: 0x000A;

PXE_OPCODE_STATISTICS :: 0x000B;

PXE_OPCODE_MCAST_IP_TO_MAC :: 0x000C;

PXE_OPCODE_NVDATA :: 0x000D;

PXE_OPCODE_GET_STATUS :: 0x000E;

PXE_OPCODE_FILL_HEADER :: 0x000F;

PXE_OPCODE_TRANSMIT :: 0x0010;

PXE_OPCODE_RECEIVE :: 0x0011;

PXE_OPCODE_LAST_VALID :: 0x0011;

PXE_OPFLAGS_NOT_USED :: 0x0000;

PXE_OPFLAGS_INITIALIZE_CABLE_DETECT_MASK :: 0x0001;
PXE_OPFLAGS_INITIALIZE_DETECT_CABLE :: 0x0000;
PXE_OPFLAGS_INITIALIZE_DO_NOT_DETECT_CABLE :: 0x0001;

PXE_OPFLAGS_RESET_DISABLE_INTERRUPTS :: 0x0001;
PXE_OPFLAGS_RESET_DISABLE_FILTERS :: 0x0002;

PXE_OPFLAGS_INTERRUPT_OPMASK :: 0xC000;
PXE_OPFLAGS_INTERRUPT_ENABLE :: 0x8000;
PXE_OPFLAGS_INTERRUPT_DISABLE :: 0x4000;
PXE_OPFLAGS_INTERRUPT_READ :: 0x0000;

PXE_OPFLAGS_INTERRUPT_RECEIVE :: 0x0001;

PXE_OPFLAGS_INTERRUPT_TRANSMIT :: 0x0002;

PXE_OPFLAGS_INTERRUPT_COMMAND :: 0x0004;

PXE_OPFLAGS_INTERRUPT_SOFTWARE :: 0x0008;

PXE_OPFLAGS_RECEIVE_FILTER_OPMASK :: 0xC000;
PXE_OPFLAGS_RECEIVE_FILTER_ENABLE :: 0x8000;
PXE_OPFLAGS_RECEIVE_FILTER_DISABLE :: 0x4000;
PXE_OPFLAGS_RECEIVE_FILTER_READ :: 0x0000;

PXE_OPFLAGS_RECEIVE_FILTER_RESET_MCAST_LIST :: 0x2000;

PXE_OPFLAGS_RECEIVE_FILTER_UNICAST :: 0x0001;

PXE_OPFLAGS_RECEIVE_FILTER_BROADCAST :: 0x0002;

PXE_OPFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST :: 0x0004;

PXE_OPFLAGS_RECEIVE_FILTER_PROMISCUOUS :: 0x0008;

PXE_OPFLAGS_RECEIVE_FILTER_ALL_MULTICAST :: 0x0010;

PXE_OPFLAGS_STATION_ADDRESS_READ :: 0x0000;
PXE_OPFLAGS_STATION_ADDRESS_WRITE :: 0x0000;
PXE_OPFLAGS_STATION_ADDRESS_RESET :: 0x0001;

PXE_OPFLAGS_STATISTICS_READ :: 0x0000;
PXE_OPFLAGS_STATISTICS_RESET :: 0x0001;

PXE_OPFLAGS_MCAST_IP_TO_MAC_OPMASK :: 0x0003;
PXE_OPFLAGS_MCAST_IPV4_TO_MAC :: 0x0000;
PXE_OPFLAGS_MCAST_IPV6_TO_MAC :: 0x0001;

PXE_OPFLAGS_NVDATA_OPMASK :: 0x0001;
PXE_OPFLAGS_NVDATA_READ :: 0x0000;
PXE_OPFLAGS_NVDATA_WRITE :: 0x0001;

PXE_OPFLAGS_GET_INTERRUPT_STATUS :: 0x0001;

PXE_OPFLAGS_GET_TRANSMITTED_BUFFERS :: 0x0002;

PXE_OPFLAGS_GET_MEDIA_STATUS :: 0x0004;

PXE_OPFLAGS_FILL_HEADER_OPMASK :: 0x0001;
PXE_OPFLAGS_FILL_HEADER_FRAGMENTED :: 0x0001;
PXE_OPFLAGS_FILL_HEADER_WHOLE :: 0x0000;

PXE_OPFLAGS_SWUNDI_TRANSMIT_OPMASK :: 0x0001;
PXE_OPFLAGS_TRANSMIT_BLOCK :: 0x0001;
PXE_OPFLAGS_TRANSMIT_DONT_BLOCK :: 0x0000;

PXE_OPFLAGS_TRANSMIT_OPMASK :: 0x0002;
PXE_OPFLAGS_TRANSMIT_FRAGMENTED :: 0x0002;
PXE_OPFLAGS_TRANSMIT_WHOLE :: 0x0000;

PXE_STATFLAGS_INITIALIZE :: 0x0000;

PXE_STATFLAGS_STATUS_MASK :: 0xC000;
PXE_STATFLAGS_COMMAND_COMPLETE :: 0xC000;
PXE_STATFLAGS_COMMAND_FAILED :: 0x8000;
PXE_STATFLAGS_COMMAND_QUEUED :: 0x4000;

PXE_STATFLAGS_GET_STATE_MASK :: 0x0003;
PXE_STATFLAGS_GET_STATE_INITIALIZED :: 0x0002;
PXE_STATFLAGS_GET_STATE_STARTED :: 0x0001;
PXE_STATFLAGS_GET_STATE_STOPPED :: 0x0000;

PXE_STATFLAGS_CABLE_DETECT_MASK :: 0x0001;
PXE_STATFLAGS_CABLE_DETECT_NOT_SUPPORTED :: 0x0000;
PXE_STATFLAGS_CABLE_DETECT_SUPPORTED :: 0x0001;

PXE_STATFLAGS_GET_STATUS_NO_MEDIA_MASK :: 0x0002;
PXE_STATFLAGS_GET_STATUS_NO_MEDIA_NOT_SUPPORTED :: 0x0000;
PXE_STATFLAGS_GET_STATUS_NO_MEDIA_SUPPORTED :: 0x0002;

PXE_STATFLAGS_INITIALIZED_NO_MEDIA :: 0x0001;

PXE_STATFLAGS_RESET_NO_MEDIA :: 0x0001;

PXE_STATFLAGS_INTERRUPT_RECEIVE :: 0x0001;

PXE_STATFLAGS_INTERRUPT_TRANSMIT :: 0x0002;

PXE_STATFLAGS_INTERRUPT_COMMAND :: 0x0004;

PXE_STATFLAGS_RECEIVE_FILTER_UNICAST :: 0x0001;

PXE_STATFLAGS_RECEIVE_FILTER_BROADCAST :: 0x0002;

PXE_STATFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST :: 0x0004;

PXE_STATFLAGS_RECEIVE_FILTER_PROMISCUOUS :: 0x0008;

PXE_STATFLAGS_RECEIVE_FILTER_ALL_MULTICAST :: 0x0010;

PXE_STATFLAGS_GET_STATUS_INTERRUPT_MASK :: 0x000F;
PXE_STATFLAGS_GET_STATUS_NO_INTERRUPTS :: 0x0000;

PXE_STATFLAGS_GET_STATUS_RECEIVE :: 0x0001;

PXE_STATFLAGS_GET_STATUS_TRANSMIT :: 0x0002;

PXE_STATFLAGS_GET_STATUS_COMMAND :: 0x0004;

PXE_STATFLAGS_GET_STATUS_SOFTWARE :: 0x0008;

PXE_STATFLAGS_GET_STATUS_TXBUF_QUEUE_EMPTY :: 0x0010;

PXE_STATFLAGS_GET_STATUS_NO_TXBUFS_WRITTEN :: 0x0020;

PXE_STATFLAGS_GET_STATUS_NO_MEDIA :: 0x0040;

PXE_STATCODE_INITIALIZE :: 0x0000;

PXE_STATCODE_SUCCESS :: 0x0000;

PXE_STATCODE_INVALID_CDB :: 0x0001;
PXE_STATCODE_INVALID_CPB :: 0x0002;
PXE_STATCODE_BUSY :: 0x0003;
PXE_STATCODE_QUEUE_FULL :: 0x0004;
PXE_STATCODE_ALREADY_STARTED :: 0x0005;
PXE_STATCODE_NOT_STARTED :: 0x0006;
PXE_STATCODE_NOT_SHUTDOWN :: 0x0007;
PXE_STATCODE_ALREADY_INITIALIZED :: 0x0008;
PXE_STATCODE_NOT_INITIALIZED :: 0x0009;
PXE_STATCODE_DEVICE_FAILURE :: 0x000A;
PXE_STATCODE_NVDATA_FAILURE :: 0x000B;
PXE_STATCODE_UNSUPPORTED :: 0x000C;
PXE_STATCODE_BUFFER_FULL :: 0x000D;
PXE_STATCODE_INVALID_PARAMETER :: 0x000E;
PXE_STATCODE_INVALID_UNDI :: 0x000F;
PXE_STATCODE_IPV4_NOT_SUPPORTED :: 0x0010;
PXE_STATCODE_IPV6_NOT_SUPPORTED :: 0x0011;
PXE_STATCODE_NOT_ENOUGH_MEMORY :: 0x0012;
PXE_STATCODE_NO_DATA :: 0x0013;

PXE_IFNUM_START :: 0x0000;

PXE_IFNUM_INVALID :: 0x0000;

PXE_CONTROL_QUEUE_IF_BUSY :: 0x0002;

PXE_CONTROL_LINK :: 0x0001;
PXE_CONTROL_LAST_CDB_IN_LIST :: 0x0000;

PXE_FRAME_TYPE_NONE :: 0x00;
PXE_FRAME_TYPE_UNICAST :: 0x01;
PXE_FRAME_TYPE_BROADCAST :: 0x02;
PXE_FRAME_TYPE_FILTERED_MULTICAST :: 0x03;
PXE_FRAME_TYPE_PROMISCUOUS :: 0x04;
PXE_FRAME_TYPE_PROMISCUOUS_MULTICAST :: 0x05;

PXE_FRAME_TYPE_MULTICAST :: PXE_FRAME_TYPE_FILTERED_MULTICAST;

PXE_MAC_LENGTH :: 32;

PXE_IFTYPE_ETHERNET :: 0x01;
PXE_IFTYPE_TOKENRING :: 0x04;
PXE_IFTYPE_FIBRE_CHANNEL :: 0x12;

PXE_HWSTAT_STATE_MASK :: 0xC0000000;
PXE_HWSTAT_BUSY :: 0xC0000000;
PXE_HWSTAT_INITIALIZED :: 0x80000000;
PXE_HWSTAT_STARTED :: 0x40000000;
PXE_HWSTAT_STOPPED :: 0x00000000;

PXE_HWSTAT_COMMAND_FAILED :: 0x20000000;

PXE_HWSTAT_PROMISCUOUS_MULTICAST_RX_ENABLED :: 0x00001000;
PXE_HWSTAT_PROMISCUOUS_RX_ENABLED :: 0x00000800;
PXE_HWSTAT_BROADCAST_RX_ENABLED :: 0x00000400;
PXE_HWSTAT_MULTICAST_RX_ENABLED :: 0x00000200;
PXE_HWSTAT_UNICAST_RX_ENABLED :: 0x00000100;

PXE_HWSTAT_SOFTWARE_INT_ENABLED :: 0x00000080;
PXE_HWSTAT_TX_COMPLETE_INT_ENABLED :: 0x00000040;
PXE_HWSTAT_PACKET_RX_INT_ENABLED :: 0x00000020;
PXE_HWSTAT_CMD_COMPLETE_INT_ENABLED :: 0x00000010;

PXE_HWSTAT_SOFTWARE_INT_PENDING :: 0x00000008;
PXE_HWSTAT_TX_COMPLETE_INT_PENDING :: 0x00000004;
PXE_HWSTAT_PACKET_RX_INT_PENDING :: 0x00000002;
PXE_HWSTAT_CMD_COMPLETE_INT_PENDING :: 0x00000001;

PXE_HWCMD_ISSUE_COMMAND :: 0x80000000;
PXE_HWCMD_INTS_AND_FILTS :: 0x00000000;

PXE_HWCMD_PROMISCUOUS_MULTICAST_RX_ENABLE :: 0x00001000;
PXE_HWCMD_PROMISCUOUS_RX_ENABLE :: 0x00000800;
PXE_HWCMD_BROADCAST_RX_ENABLE :: 0x00000400;
PXE_HWCMD_MULTICAST_RX_ENABLE :: 0x00000200;
PXE_HWCMD_UNICAST_RX_ENABLE :: 0x00000100;

PXE_HWCMD_SOFTWARE_INT_ENABLE :: 0x00000080;
PXE_HWCMD_TX_COMPLETE_INT_ENABLE :: 0x00000040;
PXE_HWCMD_PACKET_RX_INT_ENABLE :: 0x00000020;
PXE_HWCMD_CMD_COMPLETE_INT_ENABLE :: 0x00000010;

PXE_HWCMD_CLEAR_SOFTWARE_INT :: 0x00000008;
PXE_HWCMD_CLEAR_TX_COMPLETE_INT :: 0x00000004;
PXE_HWCMD_CLEAR_PACKET_RX_INT :: 0x00000002;
PXE_HWCMD_CLEAR_CMD_COMPLETE_INT :: 0x00000001;

PXE_ROMID_REV :: 0x02;

PXE_ROMID_MAJORVER :: 0x03;
PXE_ROMID_MINORVER :: 0x01;

PXE_ROMID_IMP_HW_UNDI :: 0x80000000;
PXE_ROMID_IMP_SW_VIRT_ADDR :: 0x40000000;
PXE_ROMID_IMP_64BIT_DEVICE :: 0x00010000;
PXE_ROMID_IMP_FRAG_SUPPORTED :: 0x00008000;
PXE_ROMID_IMP_CMD_LINK_SUPPORTED :: 0x00004000;
PXE_ROMID_IMP_CMD_QUEUE_SUPPORTED :: 0x00002000;
PXE_ROMID_IMP_MULTI_FRAME_SUPPORTED :: 0x00001000;
PXE_ROMID_IMP_NVDATA_SUPPORT_MASK :: 0x00000C00;
PXE_ROMID_IMP_NVDATA_BULK_WRITABLE :: 0x00000C00;
PXE_ROMID_IMP_NVDATA_SPARSE_WRITABLE :: 0x00000800;
PXE_ROMID_IMP_NVDATA_READ_ONLY :: 0x00000400;
PXE_ROMID_IMP_NVDATA_NOT_AVAILABLE :: 0x00000000;
PXE_ROMID_IMP_STATISTICS_SUPPORTED :: 0x00000200;
PXE_ROMID_IMP_STATION_ADDR_SETTABLE :: 0x00000100;
PXE_ROMID_IMP_PROMISCUOUS_MULTICAST_RX_SUPPORTED :: 0x00000080;
PXE_ROMID_IMP_PROMISCUOUS_RX_SUPPORTED :: 0x00000040;
PXE_ROMID_IMP_BROADCAST_RX_SUPPORTED :: 0x00000020;
PXE_ROMID_IMP_FILTERED_MULTICAST_RX_SUPPORTED :: 0x00000010;
PXE_ROMID_IMP_SOFTWARE_INT_SUPPORTED :: 0x00000008;
PXE_ROMID_IMP_TX_COMPLETE_INT_SUPPORTED :: 0x00000004;
PXE_ROMID_IMP_PACKET_RX_INT_SUPPORTED :: 0x00000002;
PXE_ROMID_IMP_CMD_COMPLETE_INT_SUPPORTED :: 0x00000001;

MAX_PCI_CONFIG_LEN :: 64;
MAX_EEPROM_LEN :: 128;
MAX_XMIT_BUFFERS :: 32;
MAX_MCAST_ADDRESS_CNT :: 8;

TO_AND_FROM_DEVICE :: 0;
FROM_DEVICE :: 1;
TO_DEVICE :: 2;

PXE_DELAY_MILLISECOND :: 1000;
PXE_DELAY_SECOND :: 1000000;
PXE_IO_READ :: 0;
PXE_IO_WRITE :: 1;
PXE_MEM_READ :: 2;
PXE_MEM_WRITE :: 4;

PXE_MAX_TXRX_UNIT_ETHER :: 1500;

PXE_HWADDR_LEN_ETHER :: 0x0006;
PXE_MAC_HEADER_LEN_ETHER :: 0x000E;

PXE_DUPLEX_ENABLE_FULL_SUPPORTED :: 1;
PXE_DUPLEX_FORCE_FULL_SUPPORTED :: 2;

PXE_LOOPBACK_INTERNAL_SUPPORTED :: 1;
PXE_LOOPBACK_EXTERNAL_SUPPORTED :: 2;

PXE_DUPLEX_DEFAULT :: 0x00;
PXE_FORCE_FULL_DUPLEX :: 0x01;
PXE_ENABLE_FULL_DUPLEX :: 0x02;
PXE_FORCE_HALF_DUPLEX :: 0x04;
PXE_DISABLE_FULL_DUPLEX :: 0x08;

LOOPBACK_NORMAL :: 0;
LOOPBACK_INTERNAL :: 1;
LOOPBACK_EXTERNAL :: 2;

PXE_STATISTICS_RX_TOTAL_FRAMES :: 0x00;

PXE_STATISTICS_RX_GOOD_FRAMES :: 0x01;

PXE_STATISTICS_RX_UNDERSIZE_FRAMES :: 0x02;

PXE_STATISTICS_RX_OVERSIZE_FRAMES :: 0x03;

PXE_STATISTICS_RX_DROPPED_FRAMES :: 0x04;

PXE_STATISTICS_RX_UNICAST_FRAMES :: 0x05;

PXE_STATISTICS_RX_BROADCAST_FRAMES :: 0x06;

PXE_STATISTICS_RX_MULTICAST_FRAMES :: 0x07;

PXE_STATISTICS_RX_CRC_ERROR_FRAMES :: 0x08;

PXE_STATISTICS_RX_TOTAL_BYTES :: 0x09;

PXE_STATISTICS_TX_TOTAL_FRAMES :: 0x0A;
PXE_STATISTICS_TX_GOOD_FRAMES :: 0x0B;
PXE_STATISTICS_TX_UNDERSIZE_FRAMES :: 0x0C;
PXE_STATISTICS_TX_OVERSIZE_FRAMES :: 0x0D;
PXE_STATISTICS_TX_DROPPED_FRAMES :: 0x0E;
PXE_STATISTICS_TX_UNICAST_FRAMES :: 0x0F;
PXE_STATISTICS_TX_BROADCAST_FRAMES :: 0x10;
PXE_STATISTICS_TX_MULTICAST_FRAMES :: 0x11;
PXE_STATISTICS_TX_CRC_ERROR_FRAMES :: 0x12;
PXE_STATISTICS_TX_TOTAL_BYTES :: 0x13;

PXE_STATISTICS_COLLISIONS :: 0x14;

PXE_STATISTICS_UNSUPPORTED_PROTOCOL :: 0x15;

PXE_STATISTICS_RX_DUPLICATED_FRAMES :: 0x16;

PXE_STATISTICS_RX_DECRYPT_ERROR_FRAMES :: 0x17;

PXE_STATISTICS_TX_ERROR_FRAMES :: 0x18;

PXE_STATISTICS_TX_RETRY_FRAMES :: 0x19;

PXE_PROTOCOL_ETHERNET_IP :: 0x0800;
PXE_PROTOCOL_ETHERNET_ARP :: 0x0806;
MAX_XMIT_FRAGMENTS :: 16;

PRIMARY_PART_HEADER_LBA :: 1;

EFI_HII_PACKAGE_TYPE_ALL :: 0x00;
EFI_HII_PACKAGE_TYPE_GUID :: 0x01;
EFI_HII_PACKAGE_FORMS :: 0x02;
EFI_HII_PACKAGE_STRINGS :: 0x04;
EFI_HII_PACKAGE_FONTS :: 0x05;
EFI_HII_PACKAGE_IMAGES :: 0x06;
EFI_HII_PACKAGE_SIMPLE_FONTS :: 0x07;
EFI_HII_PACKAGE_DEVICE_PATH :: 0x08;
EFI_HII_PACKAGE_KEYBOARD_LAYOUT :: 0x09;
EFI_HII_PACKAGE_ANIMATIONS :: 0x0A;
EFI_HII_PACKAGE_END :: 0xDF;
EFI_HII_PACKAGE_TYPE_SYSTEM_BEGIN :: 0xE0;
EFI_HII_PACKAGE_TYPE_SYSTEM_END :: 0xFF;

EFI_GLYPH_NON_SPACING :: 0x01;
EFI_GLYPH_WIDE :: 0x02;
EFI_GLYPH_HEIGHT :: 19;
EFI_GLYPH_WIDTH :: 8;

EFI_HII_FONT_STYLE_NORMAL :: 0x00000000;
EFI_HII_FONT_STYLE_BOLD :: 0x00000001;
EFI_HII_FONT_STYLE_ITALIC :: 0x00000002;
EFI_HII_FONT_STYLE_EMBOSS :: 0x00010000;
EFI_HII_FONT_STYLE_OUTLINE :: 0x00020000;
EFI_HII_FONT_STYLE_SHADOW :: 0x00040000;
EFI_HII_FONT_STYLE_UNDERLINE :: 0x00080000;
EFI_HII_FONT_STYLE_DBL_UNDER :: 0x00100000;

EFI_HII_GIBT_END :: 0x00;
EFI_HII_GIBT_GLYPH :: 0x10;
EFI_HII_GIBT_GLYPHS :: 0x11;
EFI_HII_GIBT_GLYPH_DEFAULT :: 0x12;
EFI_HII_GIBT_GLYPHS_DEFAULT :: 0x13;
EFI_HII_GIBT_GLYPH_VARIABILITY :: 0x14;
EFI_HII_GIBT_DUPLICATE :: 0x20;
EFI_HII_GIBT_SKIP2 :: 0x21;
EFI_HII_GIBT_SKIP1 :: 0x22;
EFI_HII_GIBT_DEFAULTS :: 0x23;
EFI_HII_GIBT_EXT1 :: 0x30;
EFI_HII_GIBT_EXT2 :: 0x31;
EFI_HII_GIBT_EXT4 :: 0x32;

UEFI_CONFIG_LANG :: "x-UEFI";
UEFI_CONFIG_LANG_2 :: "x-i-UEFI";

EFI_HII_SIBT_END :: 0x00;
EFI_HII_SIBT_STRING_SCSU :: 0x10;
EFI_HII_SIBT_STRING_SCSU_FONT :: 0x11;
EFI_HII_SIBT_STRINGS_SCSU :: 0x12;
EFI_HII_SIBT_STRINGS_SCSU_FONT :: 0x13;
EFI_HII_SIBT_STRING_UCS2 :: 0x14;
EFI_HII_SIBT_STRING_UCS2_FONT :: 0x15;
EFI_HII_SIBT_STRINGS_UCS2 :: 0x16;
EFI_HII_SIBT_STRINGS_UCS2_FONT :: 0x17;
EFI_HII_SIBT_DUPLICATE :: 0x20;
EFI_HII_SIBT_SKIP2 :: 0x21;
EFI_HII_SIBT_SKIP1 :: 0x22;
EFI_HII_SIBT_EXT1 :: 0x30;
EFI_HII_SIBT_EXT2 :: 0x31;
EFI_HII_SIBT_EXT4 :: 0x32;
EFI_HII_SIBT_FONT :: 0x40;

EFI_HII_IIBT_END :: 0x00;
EFI_HII_IIBT_IMAGE_1BIT :: 0x10;
EFI_HII_IIBT_IMAGE_1BIT_TRANS :: 0x11;
EFI_HII_IIBT_IMAGE_4BIT :: 0x12;
EFI_HII_IIBT_IMAGE_4BIT_TRANS :: 0x13;
EFI_HII_IIBT_IMAGE_8BIT :: 0x14;
EFI_HII_IIBT_IMAGE_8BIT_TRANS :: 0x15;
EFI_HII_IIBT_IMAGE_24BIT :: 0x16;
EFI_HII_IIBT_IMAGE_24BIT_TRANS :: 0x17;
EFI_HII_IIBT_IMAGE_JPEG :: 0x18;
EFI_HII_IIBT_IMAGE_PNG :: 0x19;
EFI_HII_IIBT_DUPLICATE :: 0x20;
EFI_HII_IIBT_SKIP2 :: 0x21;
EFI_HII_IIBT_SKIP1 :: 0x22;
EFI_HII_IIBT_EXT1 :: 0x30;
EFI_HII_IIBT_EXT2 :: 0x31;
EFI_HII_IIBT_EXT4 :: 0x32;

EFI_IFR_FORM_OP :: 0x01;
EFI_IFR_SUBTITLE_OP :: 0x02;
EFI_IFR_TEXT_OP :: 0x03;
EFI_IFR_IMAGE_OP :: 0x04;
EFI_IFR_ONE_OF_OP :: 0x05;
EFI_IFR_CHECKBOX_OP :: 0x06;
EFI_IFR_NUMERIC_OP :: 0x07;
EFI_IFR_PASSWORD_OP :: 0x08;
EFI_IFR_ONE_OF_OPTION_OP :: 0x09;
EFI_IFR_SUPPRESS_IF_OP :: 0x0A;
EFI_IFR_LOCKED_OP :: 0x0B;
EFI_IFR_ACTION_OP :: 0x0C;
EFI_IFR_RESET_BUTTON_OP :: 0x0D;
EFI_IFR_FORM_SET_OP :: 0x0E;
EFI_IFR_REF_OP :: 0x0F;
EFI_IFR_NO_SUBMIT_IF_OP :: 0x10;
EFI_IFR_INCONSISTENT_IF_OP :: 0x11;
EFI_IFR_EQ_ID_VAL_OP :: 0x12;
EFI_IFR_EQ_ID_ID_OP :: 0x13;
EFI_IFR_EQ_ID_VAL_LIST_OP :: 0x14;
EFI_IFR_AND_OP :: 0x15;
EFI_IFR_OR_OP :: 0x16;
EFI_IFR_NOT_OP :: 0x17;
EFI_IFR_RULE_OP :: 0x18;
EFI_IFR_GRAY_OUT_IF_OP :: 0x19;
EFI_IFR_DATE_OP :: 0x1A;
EFI_IFR_TIME_OP :: 0x1B;
EFI_IFR_STRING_OP :: 0x1C;
EFI_IFR_REFRESH_OP :: 0x1D;
EFI_IFR_DISABLE_IF_OP :: 0x1E;
EFI_IFR_ANIMATION_OP :: 0x1F;
EFI_IFR_TO_LOWER_OP :: 0x20;
EFI_IFR_TO_UPPER_OP :: 0x21;
EFI_IFR_MAP_OP :: 0x22;
EFI_IFR_ORDERED_LIST_OP :: 0x23;
EFI_IFR_VARSTORE_OP :: 0x24;
EFI_IFR_VARSTORE_NAME_VALUE_OP :: 0x25;
EFI_IFR_VARSTORE_EFI_OP :: 0x26;
EFI_IFR_VARSTORE_DEVICE_OP :: 0x27;
EFI_IFR_VERSION_OP :: 0x28;
EFI_IFR_END_OP :: 0x29;
EFI_IFR_MATCH_OP :: 0x2A;
EFI_IFR_GET_OP :: 0x2B;
EFI_IFR_SET_OP :: 0x2C;
EFI_IFR_READ_OP :: 0x2D;
EFI_IFR_WRITE_OP :: 0x2E;
EFI_IFR_EQUAL_OP :: 0x2F;
EFI_IFR_NOT_EQUAL_OP :: 0x30;
EFI_IFR_GREATER_THAN_OP :: 0x31;
EFI_IFR_GREATER_EQUAL_OP :: 0x32;
EFI_IFR_LESS_THAN_OP :: 0x33;
EFI_IFR_LESS_EQUAL_OP :: 0x34;
EFI_IFR_BITWISE_AND_OP :: 0x35;
EFI_IFR_BITWISE_OR_OP :: 0x36;
EFI_IFR_BITWISE_NOT_OP :: 0x37;
EFI_IFR_SHIFT_LEFT_OP :: 0x38;
EFI_IFR_SHIFT_RIGHT_OP :: 0x39;
EFI_IFR_ADD_OP :: 0x3A;
EFI_IFR_SUBTRACT_OP :: 0x3B;
EFI_IFR_MULTIPLY_OP :: 0x3C;
EFI_IFR_DIVIDE_OP :: 0x3D;
EFI_IFR_MODULO_OP :: 0x3E;
EFI_IFR_RULE_REF_OP :: 0x3F;
EFI_IFR_QUESTION_REF1_OP :: 0x40;
EFI_IFR_QUESTION_REF2_OP :: 0x41;
EFI_IFR_UINT8_OP :: 0x42;
EFI_IFR_UINT16_OP :: 0x43;
EFI_IFR_UINT32_OP :: 0x44;
EFI_IFR_UINT64_OP :: 0x45;
EFI_IFR_TRUE_OP :: 0x46;
EFI_IFR_FALSE_OP :: 0x47;
EFI_IFR_TO_UINT_OP :: 0x48;
EFI_IFR_TO_STRING_OP :: 0x49;
EFI_IFR_TO_BOOLEAN_OP :: 0x4A;
EFI_IFR_MID_OP :: 0x4B;
EFI_IFR_FIND_OP :: 0x4C;
EFI_IFR_TOKEN_OP :: 0x4D;
EFI_IFR_STRING_REF1_OP :: 0x4E;
EFI_IFR_STRING_REF2_OP :: 0x4F;
EFI_IFR_CONDITIONAL_OP :: 0x50;
EFI_IFR_QUESTION_REF3_OP :: 0x51;
EFI_IFR_ZERO_OP :: 0x52;
EFI_IFR_ONE_OP :: 0x53;
EFI_IFR_ONES_OP :: 0x54;
EFI_IFR_UNDEFINED_OP :: 0x55;
EFI_IFR_LENGTH_OP :: 0x56;
EFI_IFR_DUP_OP :: 0x57;
EFI_IFR_THIS_OP :: 0x58;
EFI_IFR_SPAN_OP :: 0x59;
EFI_IFR_VALUE_OP :: 0x5A;
EFI_IFR_DEFAULT_OP :: 0x5B;
EFI_IFR_DEFAULTSTORE_OP :: 0x5C;
EFI_IFR_FORM_MAP_OP :: 0x5D;
EFI_IFR_CATENATE_OP :: 0x5E;
EFI_IFR_GUID_OP :: 0x5F;
EFI_IFR_SECURITY_OP :: 0x60;
EFI_IFR_MODAL_TAG_OP :: 0x61;
EFI_IFR_REFRESH_ID_OP :: 0x62;
EFI_IFR_WARNING_IF_OP :: 0x63;
EFI_IFR_MATCH2_OP :: 0x64;

EFI_IFR_FLAG_READ_ONLY :: 0x01;
EFI_IFR_FLAG_CALLBACK :: 0x04;
EFI_IFR_FLAG_RESET_REQUIRED :: 0x10;
EFI_IFR_FLAG_RECONNECT_REQUIRED :: 0x40;
EFI_IFR_FLAG_OPTIONS_ONLY :: 0x80;

EFI_HII_DEFAULT_CLASS_STANDARD :: 0x0000;
EFI_HII_DEFAULT_CLASS_MANUFACTURING :: 0x0001;
EFI_HII_DEFAULT_CLASS_SAFE :: 0x0002;
EFI_HII_DEFAULT_CLASS_PLATFORM_BEGIN :: 0x4000;
EFI_HII_DEFAULT_CLASS_PLATFORM_END :: 0x7fff;
EFI_HII_DEFAULT_CLASS_HARDWARE_BEGIN :: 0x8000;
EFI_HII_DEFAULT_CLASS_HARDWARE_END :: 0xbfff;
EFI_HII_DEFAULT_CLASS_FIRMWARE_BEGIN :: 0xc000;
EFI_HII_DEFAULT_CLASS_FIRMWARE_END :: 0xffff;

EFI_IFR_FLAGS_HORIZONTAL :: 0x01;

EFI_IFR_CHECKBOX_DEFAULT :: 0x01;
EFI_IFR_CHECKBOX_DEFAULT_MFG :: 0x02;

EFI_QF_DATE_YEAR_SUPPRESS :: 0x01;
EFI_QF_DATE_MONTH_SUPPRESS :: 0x02;
EFI_QF_DATE_DAY_SUPPRESS :: 0x04;

EFI_QF_DATE_STORAGE :: 0x30;
QF_DATE_STORAGE_NORMAL :: 0x00;
QF_DATE_STORAGE_TIME :: 0x10;
QF_DATE_STORAGE_WAKEUP :: 0x20;

EFI_IFR_NUMERIC_SIZE :: 0x03;
EFI_IFR_NUMERIC_SIZE_1 :: 0x00;
EFI_IFR_NUMERIC_SIZE_2 :: 0x01;
EFI_IFR_NUMERIC_SIZE_4 :: 0x02;
EFI_IFR_NUMERIC_SIZE_8 :: 0x03;

EFI_IFR_DISPLAY :: 0x30;
EFI_IFR_DISPLAY_INT_DEC :: 0x00;
EFI_IFR_DISPLAY_UINT_DEC :: 0x10;
EFI_IFR_DISPLAY_UINT_HEX :: 0x20;

EFI_IFR_STRING_MULTI_LINE :: 0x01;

EFI_IFR_UNIQUE_SET :: 0x01;
EFI_IFR_NO_EMPTY_SET :: 0x02;

QF_TIME_HOUR_SUPPRESS :: 0x01;
QF_TIME_MINUTE_SUPPRESS :: 0x02;
QF_TIME_SECOND_SUPPRESS :: 0x04;

QF_TIME_STORAGE :: 0x30;
QF_TIME_STORAGE_NORMAL :: 0x00;
QF_TIME_STORAGE_TIME :: 0x10;
QF_TIME_STORAGE_WAKEUP :: 0x20;

EFI_IFR_TYPE_NUM_SIZE_8 :: 0x00;
EFI_IFR_TYPE_NUM_SIZE_16 :: 0x01;
EFI_IFR_TYPE_NUM_SIZE_32 :: 0x02;
EFI_IFR_TYPE_NUM_SIZE_64 :: 0x03;
EFI_IFR_TYPE_BOOLEAN :: 0x04;
EFI_IFR_TYPE_TIME :: 0x05;
EFI_IFR_TYPE_DATE :: 0x06;
EFI_IFR_TYPE_STRING :: 0x07;
EFI_IFR_TYPE_OTHER :: 0x08;
EFI_IFR_TYPE_UNDEFINED :: 0x09;
EFI_IFR_TYPE_ACTION :: 0x0A;
EFI_IFR_TYPE_BUFFER :: 0x0B;
EFI_IFR_TYPE_REF :: 0x0C;

EFI_IFR_OPTION_DEFAULT :: 0x10;
EFI_IFR_OPTION_DEFAULT_MFG :: 0x20;

EFI_IFR_STRING_UNSIGNED_DEC :: 0;
EFI_IFR_STRING_SIGNED_DEC :: 1;
EFI_IFR_STRING_LOWERCASE_HEX :: 2;
EFI_IFR_STRING_UPPERCASE_HEX :: 3;

EFI_IFR_STRING_ASCII :: 0;
EFI_IFR_STRING_UNICODE :: 8;

EFI_IFR_FF_CASE_SENSITIVE :: 0x00;
EFI_IFR_FF_CASE_INSENSITIVE :: 0x01;

EFI_IFR_FLAGS_FIRST_MATCHING :: 0x00;
EFI_IFR_FLAGS_FIRST_NON_MATCHING :: 0x01;

EFI_AFFECTED_BY_STANDARD_SHIFT :: 0x0001;

EFI_AFFECTED_BY_CAPS_LOCK :: 0x0002;

EFI_AFFECTED_BY_NUM_LOCK :: 0x0004;

EFI_NULL_MODIFIER :: 0x0000;
EFI_LEFT_CONTROL_MODIFIER :: 0x0001;
EFI_RIGHT_CONTROL_MODIFIER :: 0x0002;
EFI_LEFT_ALT_MODIFIER :: 0x0003;
EFI_RIGHT_ALT_MODIFIER :: 0x0004;
EFI_ALT_GR_MODIFIER :: 0x0005;
EFI_INSERT_MODIFIER :: 0x0006;
EFI_DELETE_MODIFIER :: 0x0007;
EFI_PAGE_DOWN_MODIFIER :: 0x0008;
EFI_PAGE_UP_MODIFIER :: 0x0009;
EFI_HOME_MODIFIER :: 0x000A;
EFI_END_MODIFIER :: 0x000B;
EFI_LEFT_SHIFT_MODIFIER :: 0x000C;
EFI_RIGHT_SHIFT_MODIFIER :: 0x000D;
EFI_CAPS_LOCK_MODIFIER :: 0x000E;
EFI_NUM_LOCK_MODIFIER :: 0x000F;
EFI_LEFT_ARROW_MODIFIER :: 0x0010;
EFI_RIGHT_ARROW_MODIFIER :: 0x0011;
EFI_DOWN_ARROW_MODIFIER :: 0x0012;
EFI_UP_ARROW_MODIFIER :: 0x0013;
EFI_NS_KEY_MODIFIER :: 0x0014;
EFI_NS_KEY_DEPENDENCY_MODIFIER :: 0x0015;
EFI_FUNCTION_KEY_ONE_MODIFIER :: 0x0016;
EFI_FUNCTION_KEY_TWO_MODIFIER :: 0x0017;
EFI_FUNCTION_KEY_THREE_MODIFIER :: 0x0018;
EFI_FUNCTION_KEY_FOUR_MODIFIER :: 0x0019;
EFI_FUNCTION_KEY_FIVE_MODIFIER :: 0x001A;
EFI_FUNCTION_KEY_SIX_MODIFIER :: 0x001B;
EFI_FUNCTION_KEY_SEVEN_MODIFIER :: 0x001C;
EFI_FUNCTION_KEY_EIGHT_MODIFIER :: 0x001D;
EFI_FUNCTION_KEY_NINE_MODIFIER :: 0x001E;
EFI_FUNCTION_KEY_TEN_MODIFIER :: 0x001F;
EFI_FUNCTION_KEY_ELEVEN_MODIFIER :: 0x0020;
EFI_FUNCTION_KEY_TWELVE_MODIFIER :: 0x0021;

EFI_PRINT_MODIFIER :: 0x0022;
EFI_SYS_REQUEST_MODIFIER :: 0x0023;
EFI_SCROLL_LOCK_MODIFIER :: 0x0024;
EFI_PAUSE_MODIFIER :: 0x0025;
EFI_BREAK_MODIFIER :: 0x0026;

EFI_LEFT_LOGO_MODIFIER :: 0x0027;
EFI_RIGHT_LOGO_MODIFIER :: 0x0028;
EFI_MENU_MODIFIER :: 0x0029;

EFI_HII_AIBT_END :: 0x00;
EFI_HII_AIBT_OVERLAY_IMAGES :: 0x10;
EFI_HII_AIBT_CLEAR_IMAGES :: 0x11;
EFI_HII_AIBT_RESTORE_SCRN :: 0x12;
EFI_HII_AIBT_OVERLAY_IMAGES_LOOP :: 0x18;
EFI_HII_AIBT_CLEAR_IMAGES_LOOP :: 0x19;
EFI_HII_AIBT_RESTORE_SCRN_LOOP :: 0x1A;
EFI_HII_AIBT_DUPLICATE :: 0x20;
EFI_HII_AIBT_SKIP2 :: 0x21;
EFI_HII_AIBT_SKIP1 :: 0x22;
EFI_HII_AIBT_EXT1 :: 0x30;
EFI_HII_AIBT_EXT2 :: 0x31;
EFI_HII_AIBT_EXT4 :: 0x32;

///
/// 2-byte Character.  Unless otherwise specified all strings are stored in the
/// UTF-16 encoding format as defined by Unicode 2.1 and ISO/IEC 10646 standards.
///
CHAR16 :: u16;

///
/// Logical Boolean.  1-byte value containing 0 for FALSE or a 1 for TRUE.  Other
/// values are undefined.
///
BOOLEAN :: u8;

///
/// 1-byte Character
///
CHAR8 :: u8;

///
/// Unsigned value of native width.  (4 bytes on supported 32-bit processor instructions,
/// 8 bytes on supported 64-bit processor instructions)
///
UINTN :: u64;

///
/// Signed value of native width.  (4 bytes on supported 32-bit processor instructions,
/// 8 bytes on supported 64-bit processor instructions)
///
INTN :: s64;

//
// The following three enum types are used to verify that the compiler
// configuration for enum types is compliant with Section 2.3.1 of the
// UEFI 2.3 Specification. These enum types and enum values are not
// intended to be used. A prefix of '__' is used avoid conflicts with
// other types.
//
__VERIFY_UINT8_ENUM_SIZE :: enum s32 {
    __VerifyUint8EnumValue :: 255;
}

__VERIFY_UINT16_ENUM_SIZE :: enum s32 {
    __VerifyUint16EnumValue :: 65535;
}

__VERIFY_UINT32_ENUM_SIZE :: enum s32 {
    __VerifyUint32EnumValue :: -1;
}

///
/// 128 bit buffer containing a unique identifier value.
/// Unless otherwise specified, aligned on a 64 bit boundary.
///
GUID :: struct {
    Data1: u32;
    Data2: u16;
    Data3: u16;
    Data4: [8] u8;
}

///
/// 4-byte buffer. An IPv4 internet protocol address.
///
IPv4_ADDRESS :: struct {
    Addr: [4] u8;
}

///
/// 16-byte buffer. An IPv6 internet protocol address.
///
IPv6_ADDRESS :: struct {
    Addr: [16] u8;
}

//
// 8-bytes unsigned value that represents a physical system address.
//
PHYSICAL_ADDRESS :: u64;

///
/// LIST_ENTRY structure definition.
///
LIST_ENTRY :: _LIST_ENTRY;

///
/// _LIST_ENTRY structure definition.
///
_LIST_ENTRY :: struct {
    ForwardLink: *LIST_ENTRY;
    BackLink:    *LIST_ENTRY;
}

///
/// Variable used to traverse the list of arguments. This type can vary by
/// implementation and could be an array or structure.
///
VA_LIST :: *CHAR8;

///
/// Pointer to the start of a variable argument list stored in a memory buffer. Same as UINT8 *.
///
BASE_LIST :: *UINTN;

//
// Status codes common to all execution phases
//
RETURN_STATUS :: UINTN;

///
/// 128-bit buffer containing a unique identifier value.
///
EFI_GUID :: GUID;

///
/// Function return status for EFI API.
///
EFI_STATUS :: RETURN_STATUS;

///
/// A collection of related interfaces.
///
EFI_HANDLE :: *void;

///
/// Handle to an event structure.
///
EFI_EVENT :: *void;

///
/// Task priority level.
///
EFI_TPL :: UINTN;

///
/// Logical block address.
///
EFI_LBA :: u64;

///
/// 64-bit physical memory address.
///
EFI_PHYSICAL_ADDRESS :: u64;

///
/// 64-bit virtual memory address.
///
EFI_VIRTUAL_ADDRESS :: u64;

///
/// EFI Time Abstraction:
///  Year:       1900 - 9999
///  Month:      1 - 12
///  Day:        1 - 31
///  Hour:       0 - 23
///  Minute:     0 - 59
///  Second:     0 - 59
///  Nanosecond: 0 - 999,999,999
///  TimeZone:   -1440 to 1440 or 2047
///
EFI_TIME :: struct {
    Year:       u16;
    Month:      u8;
    Day:        u8;
    Hour:       u8;
    Minute:     u8;
    Second:     u8;
    Pad1:       u8;
    Nanosecond: u32;
    TimeZone:   s16;
    Daylight:   u8;
    Pad2:       u8;
}

///
/// 4-byte buffer. An IPv4 internet protocol address.
///
EFI_IPv4_ADDRESS :: IPv4_ADDRESS;

///
/// 16-byte buffer. An IPv6 internet protocol address.
///
EFI_IPv6_ADDRESS :: IPv6_ADDRESS;

///
/// 32-byte buffer containing a network Media Access Control address.
///
EFI_MAC_ADDRESS :: struct {
    Addr: [32] u8;
}

///
/// 16-byte buffer aligned on a 4-byte boundary.
/// An IPv4 or IPv6 internet protocol address.
///
EFI_IP_ADDRESS :: union {
    Addr: [4] u32;
    v4:   EFI_IPv4_ADDRESS;
    v6:   EFI_IPv6_ADDRESS;
}

///
/// The WIN_CERTIFICATE structure is part of the PE/COFF specification.
///
WIN_CERTIFICATE :: struct {
    ///
    /// The length of the entire certificate,
    /// including the length of the header, in bytes.
    ///
    dwLength:         u32;

    ///
    /// The revision level of the WIN_CERTIFICATE
    /// structure. The current revision level is 0x0200.
    ///
    wRevision:        u16;

    ///
    /// The certificate type. See WIN_CERT_TYPE_xxx for the UEFI
    /// certificate types. The UEFI specification reserves the range of
    /// certificate type values from 0x0EF0 to 0x0EFF.
    ///
    wCertificateType: u16;
}

///
/// WIN_CERTIFICATE_UEFI_GUID.CertData
///
EFI_CERT_BLOCK_RSA_2048_SHA256 :: struct {
    HashType:  EFI_GUID;
    PublicKey: [256] u8;
    Signature: [256] u8;
}

///
/// Certificate which encapsulates a GUID-specific digital signature
///
WIN_CERTIFICATE_UEFI_GUID :: struct {
    ///
    /// This is the standard WIN_CERTIFICATE header, where
    /// wCertificateType is set to WIN_CERT_TYPE_EFI_GUID.
    ///
    Hdr:      WIN_CERTIFICATE;

    ///
    /// This is the unique id which determines the
    /// format of the CertData. .
    ///
    CertType: EFI_GUID;

    ///
    /// The following is the certificate data. The format of
    /// the data is determined by the CertType.
    /// If CertType is EFI_CERT_TYPE_RSA2048_SHA256_GUID,
    /// the CertData will be EFI_CERT_BLOCK_RSA_2048_SHA256 structure.
    ///
    CertData: [1] u8;
}

///
/// Certificate which encapsulates the RSASSA_PKCS1-v1_5 digital signature.
///
/// The WIN_CERTIFICATE_UEFI_PKCS1_15 structure is derived from
/// WIN_CERTIFICATE and encapsulate the information needed to
/// implement the RSASSA-PKCS1-v1_5 digital signature algorithm as
/// specified in RFC2437.
///
WIN_CERTIFICATE_EFI_PKCS1_15 :: struct {
    ///
    /// This is the standard WIN_CERTIFICATE header, where
    /// wCertificateType is set to WIN_CERT_TYPE_UEFI_PKCS1_15.
    ///
    Hdr:           WIN_CERTIFICATE;

    ///
    /// This is the hashing algorithm which was performed on the
    /// UEFI executable when creating the digital signature.
    ///
    HashAlgorithm: EFI_GUID;
}

///
/// Enumeration of memory types introduced in UEFI.
///
EFI_MEMORY_TYPE :: enum s32 {
    ReservedMemoryType      :: 0;

    LoaderCode              :: 1;

    LoaderData              :: 2;

    BootServicesCode        :: 3;

    BootServicesData        :: 4;

    RuntimeServicesCode     :: 5;

    RuntimeServicesData     :: 6;

    ConventionalMemory      :: 7;

    UnusableMemory          :: 8;

    ACPIReclaimMemory       :: 9;

    ACPIMemoryNVS           :: 10;

    MemoryMappedIO          :: 11;

    MemoryMappedIOPortSpace :: 12;

    PalCode                 :: 13;

    PersistentMemory        :: 14;
    MaxMemoryType           :: 15;

    EfiReservedMemoryType      :: ReservedMemoryType;

    EfiLoaderCode              :: LoaderCode;

    EfiLoaderData              :: LoaderData;

    EfiBootServicesCode        :: BootServicesCode;

    EfiBootServicesData        :: BootServicesData;

    EfiRuntimeServicesCode     :: RuntimeServicesCode;

    EfiRuntimeServicesData     :: RuntimeServicesData;

    EfiConventionalMemory      :: ConventionalMemory;

    EfiUnusableMemory          :: UnusableMemory;

    EfiACPIReclaimMemory       :: ACPIReclaimMemory;

    EfiACPIMemoryNVS           :: ACPIMemoryNVS;

    EfiMemoryMappedIO          :: MemoryMappedIO;

    EfiMemoryMappedIOPortSpace :: MemoryMappedIOPortSpace;

    EfiPalCode                 :: PalCode;

    EfiPersistentMemory        :: PersistentMemory;
    EfiMaxMemoryType           :: MaxMemoryType;
}

///
/// Enumeration of reset types.
///
EFI_RESET_TYPE :: enum s32 {
    Cold             :: 0;

    Warm             :: 1;

    Shutdown         :: 2;

    PlatformSpecific :: 3;

    EfiResetCold             :: Cold;

    EfiResetWarm             :: Warm;

    EfiResetShutdown         :: Shutdown;

    EfiResetPlatformSpecific :: PlatformSpecific;
}

///
/// Data structure that precedes all of the standard EFI table types.
///
EFI_TABLE_HEADER :: struct {
    ///
    /// A 64-bit signature that identifies the type of table that follows.
    /// Unique signatures have been generated for the EFI System Table,
    /// the EFI Boot Services Table, and the EFI Runtime Services Table.
    ///
    Signature:  u64;

    ///
    /// The revision of the EFI Specification to which this table
    /// conforms. The upper 16 bits of this field contain the major
    /// revision value, and the lower 16 bits contain the minor revision
    /// value. The minor revision values are limited to the range of 00..99.
    ///
    Revision:   u32;

    ///
    /// The size, in bytes, of the entire table including the EFI_TABLE_HEADER.
    ///
    HeaderSize: u32;

    ///
    /// The 32-bit CRC for the entire table. This value is computed by
    /// setting this field to 0, and computing the 32-bit CRC for HeaderSize bytes.
    ///
    CRC32:      u32;

    ///
    /// Reserved field that must be set to 0.
    ///
    Reserved:   u32;
}

///
/// AuthInfo is a WIN_CERTIFICATE using the wCertificateType
/// WIN_CERTIFICATE_UEFI_GUID and the CertType
/// EFI_CERT_TYPE_RSA2048_SHA256_GUID. If the attribute specifies
/// authenticated access, then the Data buffer should begin with an
/// authentication descriptor prior to the data payload and DataSize
/// should reflect the the data.and descriptor size. The caller
/// shall digest the Monotonic Count value and the associated data
/// for the variable update using the SHA-256 1-way hash algorithm.
/// The ensuing the 32-byte digest will be signed using the private
/// key associated w/ the public/private 2048-bit RSA key-pair. The
/// WIN_CERTIFICATE shall be used to describe the signature of the
/// Variable data *Data. In addition, the signature will also
/// include the MonotonicCount value to guard against replay attacks.
///
EFI_VARIABLE_AUTHENTICATION :: struct {
    ///
    /// Included in the signature of
    /// AuthInfo.Used to ensure freshness/no
    /// replay. Incremented during each
    /// "Write" access.
    ///
    MonotonicCount: u64;

    ///
    /// Provides the authorization for the variable
    /// access. It is a signature across the
    /// variable data and the  Monotonic Count
    /// value. Caller uses Private key that is
    /// associated with a public key that has been
    /// provisioned via the key exchange.
    ///
    AuthInfo:       WIN_CERTIFICATE_UEFI_GUID;
}

///
/// When the attribute EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS is
/// set, then the Data buffer shall begin with an instance of a complete (and serialized)
/// EFI_VARIABLE_AUTHENTICATION_2 descriptor. The descriptor shall be followed by the new
/// variable value and DataSize shall reflect the combined size of the descriptor and the new
/// variable value. The authentication descriptor is not part of the variable data and is not
/// returned by subsequent calls to GetVariable().
///
EFI_VARIABLE_AUTHENTICATION_2 :: struct {
    ///
    /// For the TimeStamp value, components Pad1, Nanosecond, TimeZone, Daylight and
    /// Pad2 shall be set to 0. This means that the time shall always be expressed in GMT.
    ///
    TimeStamp: EFI_TIME;

    ///
    /// Only a CertType of  EFI_CERT_TYPE_PKCS7_GUID is accepted.
    ///
    AuthInfo:  WIN_CERTIFICATE_UEFI_GUID;
}

///
/// BLUETOOTH_ADDRESS
///
BLUETOOTH_ADDRESS :: struct {
    ///
    /// 48bit Bluetooth device address.
    ///
    Address: [6] u8;
}

///
/// BLUETOOTH_CLASS_OF_DEVICE. See Bluetooth specification for detail.
///
BLUETOOTH_CLASS_OF_DEVICE :: struct {
    FormatType:        u8;
    #place FormatType; /*bitfield 2*/ MinorDeviceClass:  u8;
    MajorDeviceClass:  u16;
    #place MajorDeviceClass; /*bitfield 5*/ MajorServiceClass: u16;
}

///
/// BLUETOOTH_LE_ADDRESS
///
BLUETOOTH_LE_ADDRESS :: struct {
    ///
    /// 48-bit Bluetooth device address
    ///
    Address: [6] u8;

    ///
    /// 0x00 - Public Device Address
    /// 0x01 - Random Device Address
    ///
    Type:    u8;
}

///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure.
///
EFI_ACPI_COMMON_HEADER :: struct {
    Signature: u32;
    Length:    u32;
}

///
/// The common ACPI description table header.  This structure prefaces most ACPI tables.
///
EFI_ACPI_DESCRIPTION_HEADER :: struct {
    Signature:       u32;
    Length:          u32;
    Revision:        u8;
    Checksum:        u8;
    OemId:           [6] u8;
    OemTableId:      u64;
    OemRevision:     u32;
    CreatorId:       u32;
    CreatorRevision: u32;
}

///
/// The commond definition of QWORD, DWORD, and WORD
/// Address Space Descriptors.
///
EFI_ACPI_ADDRESS_SPACE_DESCRIPTOR :: struct {
    Desc:                  u8;
    Len:                   u16 #align 1;
    ResType:               u8;
    GenFlag:               u8;
    SpecificFlag:          u8;
    AddrSpaceGranularity:  u64 #align 6;
    AddrRangeMin:          u64 #align 6;
    AddrRangeMax:          u64 #align 6;
    AddrTranslationOffset: u64 #align 6;
    AddrLen:               u64 #align 6;
}

ACPI_SMALL_RESOURCE_HEADER :: union {
    Byte: u8;
    Bits: struct {
        Length: u8;
        #place Length; /*bitfield 3*/ Name:   u8;
        #place Length; /*bitfield 7*/ Type:   u8;
    };
}

ACPI_LARGE_RESOURCE_HEADER :: struct {
    Header: union {
        Byte: u8;
        Bits: struct {
            Name: u8;
            #place Name; /*bitfield 7*/ Type: u8;
        };
    };

    Length: u16 #align 1;
}

///
/// IRQ Descriptor.
///
EFI_ACPI_IRQ_NOFLAG_DESCRIPTOR :: struct {
    Header: ACPI_SMALL_RESOURCE_HEADER;
    Mask:   u16 #align 1;
}

///
/// IRQ Descriptor.
///
EFI_ACPI_IRQ_DESCRIPTOR :: struct {
    Header:      ACPI_SMALL_RESOURCE_HEADER;
    Mask:        u16 #align 1;
    Information: u8;
}

///
/// DMA Descriptor.
///
EFI_ACPI_DMA_DESCRIPTOR :: struct {
    Header:      ACPI_SMALL_RESOURCE_HEADER;
    ChannelMask: u8;
    Information: u8;
}

///
/// I/O Port Descriptor
///
EFI_ACPI_IO_PORT_DESCRIPTOR :: struct {
    Header:         ACPI_SMALL_RESOURCE_HEADER;
    Information:    u8;
    BaseAddressMin: u16;
    BaseAddressMax: u16;
    Alignment:      u8;
    Length:         u8;
}

///
/// Fixed Location I/O Port Descriptor.
///
EFI_ACPI_FIXED_LOCATION_IO_PORT_DESCRIPTOR :: struct {
    Header:      ACPI_SMALL_RESOURCE_HEADER;
    BaseAddress: u16 #align 1;
    Length:      u8;
}

///
/// 24-Bit Memory Range Descriptor
///
EFI_ACPI_24_BIT_MEMORY_RANGE_DESCRIPTOR :: struct {
    Header:         ACPI_LARGE_RESOURCE_HEADER;
    Information:    u8;
    BaseAddressMin: u16;
    BaseAddressMax: u16;
    Alignment:      u16;
    Length:         u16;
}

///
/// 32-Bit Memory Range Descriptor
///
EFI_ACPI_32_BIT_MEMORY_RANGE_DESCRIPTOR :: struct {
    Header:         ACPI_LARGE_RESOURCE_HEADER;
    Information:    u8;
    BaseAddressMin: u32;
    BaseAddressMax: u32;
    Alignment:      u32;
    Length:         u32;
}

///
/// Fixed 32-Bit Fixed Memory Range Descriptor
///
EFI_ACPI_32_BIT_FIXED_MEMORY_RANGE_DESCRIPTOR :: struct {
    Header:      ACPI_LARGE_RESOURCE_HEADER;
    Information: u8;
    BaseAddress: u32;
    Length:      u32;
}

///
/// QWORD Address Space Descriptor
///
EFI_ACPI_QWORD_ADDRESS_SPACE_DESCRIPTOR :: struct {
    Header:                ACPI_LARGE_RESOURCE_HEADER;
    ResType:               u8;
    GenFlag:               u8;
    SpecificFlag:          u8;
    AddrSpaceGranularity:  u64 #align 6;
    AddrRangeMin:          u64 #align 6;
    AddrRangeMax:          u64 #align 6;
    AddrTranslationOffset: u64 #align 6;
    AddrLen:               u64 #align 6;
}

///
/// DWORD Address Space Descriptor
///
EFI_ACPI_DWORD_ADDRESS_SPACE_DESCRIPTOR :: struct {
    Header:                ACPI_LARGE_RESOURCE_HEADER;
    ResType:               u8;
    GenFlag:               u8;
    SpecificFlag:          u8;
    AddrSpaceGranularity:  u32 #align 2;
    AddrRangeMin:          u32 #align 2;
    AddrRangeMax:          u32 #align 2;
    AddrTranslationOffset: u32 #align 2;
    AddrLen:               u32 #align 2;
}

///
/// WORD Address Space Descriptor
///
EFI_ACPI_WORD_ADDRESS_SPACE_DESCRIPTOR :: struct {
    Header:                ACPI_LARGE_RESOURCE_HEADER;
    ResType:               u8;
    GenFlag:               u8;
    SpecificFlag:          u8;
    AddrSpaceGranularity:  u16;
    AddrRangeMin:          u16;
    AddrRangeMax:          u16;
    AddrTranslationOffset: u16;
    AddrLen:               u16;
}

///
/// Extended Interrupt Descriptor
///
EFI_ACPI_EXTENDED_INTERRUPT_DESCRIPTOR :: struct {
    Header:               ACPI_LARGE_RESOURCE_HEADER;
    InterruptVectorFlags: u8;
    InterruptTableLength: u8;
    InterruptNumber:      [1] u32 #align 1;
}

///
/// The End tag identifies an end of resource data.
///
EFI_ACPI_END_TAG_DESCRIPTOR :: struct {
    Desc:     u8;
    Checksum: u8;
}

///
/// Root System Description Pointer Structure.
///
EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER :: struct {
    Signature:   u64;
    Checksum:    u8;
    OemId:       [6] u8;
    Reserved:    u8;
    RsdtAddress: u32;
}

///
/// Fixed ACPI Description Table Structure (FADT).
///
EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE :: struct {
    Header:       EFI_ACPI_DESCRIPTION_HEADER;
    FirmwareCtrl: u32;
    Dsdt:         u32;
    IntModel:     u8;
    Reserved1:    u8;
    SciInt:       u16;
    SmiCmd:       u32;
    AcpiEnable:   u8;
    AcpiDisable:  u8;
    S4BiosReq:    u8;
    Reserved2:    u8;
    Pm1aEvtBlk:   u32;
    Pm1bEvtBlk:   u32;
    Pm1aCntBlk:   u32;
    Pm1bCntBlk:   u32;
    Pm2CntBlk:    u32;
    PmTmrBlk:     u32;
    Gpe0Blk:      u32;
    Gpe1Blk:      u32;
    Pm1EvtLen:    u8;
    Pm1CntLen:    u8;
    Pm2CntLen:    u8;
    PmTmLen:      u8;
    Gpe0BlkLen:   u8;
    Gpe1BlkLen:   u8;
    Gpe1Base:     u8;
    Reserved3:    u8;
    PLvl2Lat:     u16;
    PLvl3Lat:     u16;
    FlushSize:    u16;
    FlushStride:  u16;
    DutyOffset:   u8;
    DutyWidth:    u8;
    DayAlrm:      u8;
    MonAlrm:      u8;
    Century:      u8;
    Reserved4:    u8;
    Reserved5:    u8;
    Reserved6:    u8;
    Flags:        u32;
}

///
/// Firmware ACPI Control Structure.
///
EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE :: struct {
    Signature:            u32;
    Length:               u32;
    HardwareSignature:    u32;
    FirmwareWakingVector: u32;
    GlobalLock:           u32;
    Flags:                u32;
    Reserved:             [40] u8;
}

///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform-specific manner.
///
EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER :: struct {
    Header:           EFI_ACPI_DESCRIPTION_HEADER;
    LocalApicAddress: u32;
    Flags:            u32;
}

///
/// Processor Local APIC Structure Definition.
///
EFI_ACPI_1_0_PROCESSOR_LOCAL_APIC_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    ApicId:          u8;
    Flags:           u32;
}

///
/// IO APIC Structure.
///
EFI_ACPI_1_0_IO_APIC_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    IoApicId:         u8;
    Reserved:         u8;
    IoApicAddress:    u32;
    SystemVectorBase: u32;
}

///
/// Interrupt Source Override Structure.
///
EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE :: struct {
    Type:                        u8;
    Length:                      u8;
    Bus:                         u8;
    Source:                      u8;
    GlobalSystemInterruptVector: u32;
    Flags:                       u16;
}

///
/// Non-Maskable Interrupt Source Structure.
///
EFI_ACPI_1_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE :: struct {
    Type:                        u8;
    Length:                      u8;
    Flags:                       u16;
    GlobalSystemInterruptVector: u32;
}

///
/// Local APIC NMI Structure.
///
EFI_ACPI_1_0_LOCAL_APIC_NMI_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    Flags:           u16 #align 1;
    LocalApicInti:   u8;
}

///
/// Smart Battery Description Table (SBST)
///
EFI_ACPI_1_0_SMART_BATTERY_DESCRIPTION_TABLE :: struct {
    Header:              EFI_ACPI_DESCRIPTION_HEADER;
    WarningEnergyLevel:  u32;
    LowEnergyLevel:      u32;
    CriticalEnergyLevel: u32;
}

///
/// Generic Register Descriptor
///
EFI_ACPI_GENERIC_REGISTER_DESCRIPTOR :: struct {
    Header:            ACPI_LARGE_RESOURCE_HEADER;
    AddressSpaceId:    u8;
    RegisterBitWidth:  u8;
    RegisterBitOffset: u8;
    AddressSize:       u8;
    RegisterAddress:   u64 #align 7;
}

///
/// ACPI 2.0 Generic Address Space definition
///
EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE :: struct {
    AddressSpaceId:    u8;
    RegisterBitWidth:  u8;
    RegisterBitOffset: u8;
    Reserved:          u8;
    Address:           u64 #align 4;
}

///
/// Root System Description Pointer Structure
///
EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER :: struct {
    Signature:        u64;
    Checksum:         u8;
    OemId:            [6] u8;
    Revision:         u8;
    RsdtAddress:      u32;
    Length:           u32;
    XsdtAddress:      u64;
    ExtendedChecksum: u8;
    Reserved:         [3] u8;
}

///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
EFI_ACPI_2_0_COMMON_HEADER :: struct {
    Signature: u32;
    Length:    u32;
}

///
/// Fixed ACPI Description Table Structure (FADT)
///
EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE :: struct {
    Header:             EFI_ACPI_DESCRIPTION_HEADER;
    FirmwareCtrl:       u32;
    Dsdt:               u32;
    Reserved0:          u8;
    PreferredPmProfile: u8;
    SciInt:             u16;
    SmiCmd:             u32;
    AcpiEnable:         u8;
    AcpiDisable:        u8;
    S4BiosReq:          u8;
    PstateCnt:          u8;
    Pm1aEvtBlk:         u32;
    Pm1bEvtBlk:         u32;
    Pm1aCntBlk:         u32;
    Pm1bCntBlk:         u32;
    Pm2CntBlk:          u32;
    PmTmrBlk:           u32;
    Gpe0Blk:            u32;
    Gpe1Blk:            u32;
    Pm1EvtLen:          u8;
    Pm1CntLen:          u8;
    Pm2CntLen:          u8;
    PmTmrLen:           u8;
    Gpe0BlkLen:         u8;
    Gpe1BlkLen:         u8;
    Gpe1Base:           u8;
    CstCnt:             u8;
    PLvl2Lat:           u16;
    PLvl3Lat:           u16;
    FlushSize:          u16;
    FlushStride:        u16;
    DutyOffset:         u8;
    DutyWidth:          u8;
    DayAlrm:            u8;
    MonAlrm:            u8;
    Century:            u8;
    IaPcBootArch:       u16 #align 1;
    Reserved1:          u8;
    Flags:              u32;
    ResetReg:           EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    ResetValue:         u8;
    Reserved2:          [3] u8;
    XFirmwareCtrl:      u64 #align 4;
    XDsdt:              u64 #align 4;
    XPm1aEvtBlk:        EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bEvtBlk:        EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE;
    XPm1aCntBlk:        EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bCntBlk:        EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE;
    XPm2CntBlk:         EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPmTmrBlk:          EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE;
    XGpe0Blk:           EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XGpe1Blk:           EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE;
}

///
/// Firmware ACPI Control Structure
///
EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE :: struct {
    Signature:             u32;
    Length:                u32;
    HardwareSignature:     u32;
    FirmwareWakingVector:  u32;
    GlobalLock:            u32;
    Flags:                 u32;
    XFirmwareWakingVector: u64;
    Version:               u8;
    Reserved:              [31] u8;
}

///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
EFI_ACPI_2_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER :: struct {
    Header:           EFI_ACPI_DESCRIPTION_HEADER;
    LocalApicAddress: u32;
    Flags:            u32;
}

///
/// Processor Local APIC Structure Definition
///
EFI_ACPI_2_0_PROCESSOR_LOCAL_APIC_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    ApicId:          u8;
    Flags:           u32;
}

///
/// IO APIC Structure
///
EFI_ACPI_2_0_IO_APIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    IoApicAddress:             u32;
    GlobalSystemInterruptBase: u32;
}

///
/// Interrupt Source Override Structure
///
EFI_ACPI_2_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Bus:                   u8;
    Source:                u8;
    GlobalSystemInterrupt: u32;
    Flags:                 u16;
}

///
/// Non-Maskable Interrupt Source Structure
///
EFI_ACPI_2_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Flags:                 u16;
    GlobalSystemInterrupt: u32;
}

///
/// Local APIC NMI Structure
///
EFI_ACPI_2_0_LOCAL_APIC_NMI_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    Flags:           u16 #align 1;
    LocalApicLint:   u8;
}

///
/// Local APIC Address Override Structure
///
EFI_ACPI_2_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Reserved:         u16;
    LocalApicAddress: u64 #align 4;
}

///
/// IO SAPIC Structure
///
EFI_ACPI_2_0_IO_SAPIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    GlobalSystemInterruptBase: u32;
    IoSapicAddress:            u64;
}

///
/// Local SAPIC Structure
///
EFI_ACPI_2_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    LocalSapicId:    u8;
    LocalSapicEid:   u8;
    Reserved:        [3] u8;
    Flags:           u32;
}

///
/// Platform Interrupt Sources Structure
///
EFI_ACPI_2_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Flags:                 u16;
    InterruptType:         u8;
    ProcessorId:           u8;
    ProcessorEid:          u8;
    IoSapicVector:         u8;
    GlobalSystemInterrupt: u32;
    Reserved:              u32;
}

///
/// Smart Battery Description Table (SBST)
///
EFI_ACPI_2_0_SMART_BATTERY_DESCRIPTION_TABLE :: struct {
    Header:              EFI_ACPI_DESCRIPTION_HEADER;
    WarningEnergyLevel:  u32;
    LowEnergyLevel:      u32;
    CriticalEnergyLevel: u32;
}

///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
EFI_ACPI_2_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE :: struct {
    Header:    EFI_ACPI_DESCRIPTION_HEADER;
    EcControl: EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    EcData:    EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE;
    Uid:       u32;
    GpeBit:    u8;
}

///
/// Extended Address Space Descriptor
///
EFI_ACPI_EXTENDED_ADDRESS_SPACE_DESCRIPTOR :: struct {
    Header:                ACPI_LARGE_RESOURCE_HEADER;
    ResType:               u8;
    GenFlag:               u8;
    SpecificFlag:          u8;
    RevisionId:            u8;
    Reserved:              u8;
    AddrSpaceGranularity:  u64;
    AddrRangeMin:          u64;
    AddrRangeMax:          u64;
    AddrTranslationOffset: u64;
    AddrLen:               u64;
    TypeSpecificAttribute: u64;
}

///
/// ACPI 3.0 Generic Address Space definition
///
EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE :: struct {
    AddressSpaceId:    u8;
    RegisterBitWidth:  u8;
    RegisterBitOffset: u8;
    AccessSize:        u8;
    Address:           u64 #align 4;
}

///
/// Root System Description Pointer Structure
///
EFI_ACPI_3_0_ROOT_SYSTEM_DESCRIPTION_POINTER :: struct {
    Signature:        u64;
    Checksum:         u8;
    OemId:            [6] u8;
    Revision:         u8;
    RsdtAddress:      u32;
    Length:           u32;
    XsdtAddress:      u64;
    ExtendedChecksum: u8;
    Reserved:         [3] u8;
}

///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
EFI_ACPI_3_0_COMMON_HEADER :: struct {
    Signature: u32;
    Length:    u32;
}

///
/// Fixed ACPI Description Table Structure (FADT)
///
EFI_ACPI_3_0_FIXED_ACPI_DESCRIPTION_TABLE :: struct {
    Header:             EFI_ACPI_DESCRIPTION_HEADER;
    FirmwareCtrl:       u32;
    Dsdt:               u32;
    Reserved0:          u8;
    PreferredPmProfile: u8;
    SciInt:             u16;
    SmiCmd:             u32;
    AcpiEnable:         u8;
    AcpiDisable:        u8;
    S4BiosReq:          u8;
    PstateCnt:          u8;
    Pm1aEvtBlk:         u32;
    Pm1bEvtBlk:         u32;
    Pm1aCntBlk:         u32;
    Pm1bCntBlk:         u32;
    Pm2CntBlk:          u32;
    PmTmrBlk:           u32;
    Gpe0Blk:            u32;
    Gpe1Blk:            u32;
    Pm1EvtLen:          u8;
    Pm1CntLen:          u8;
    Pm2CntLen:          u8;
    PmTmrLen:           u8;
    Gpe0BlkLen:         u8;
    Gpe1BlkLen:         u8;
    Gpe1Base:           u8;
    CstCnt:             u8;
    PLvl2Lat:           u16;
    PLvl3Lat:           u16;
    FlushSize:          u16;
    FlushStride:        u16;
    DutyOffset:         u8;
    DutyWidth:          u8;
    DayAlrm:            u8;
    MonAlrm:            u8;
    Century:            u8;
    IaPcBootArch:       u16 #align 1;
    Reserved1:          u8;
    Flags:              u32;
    ResetReg:           EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    ResetValue:         u8;
    Reserved2:          [3] u8;
    XFirmwareCtrl:      u64 #align 4;
    XDsdt:              u64 #align 4;
    XPm1aEvtBlk:        EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bEvtBlk:        EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE;
    XPm1aCntBlk:        EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bCntBlk:        EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE;
    XPm2CntBlk:         EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPmTmrBlk:          EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE;
    XGpe0Blk:           EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XGpe1Blk:           EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE;
}

///
/// Firmware ACPI Control Structure
///
EFI_ACPI_3_0_FIRMWARE_ACPI_CONTROL_STRUCTURE :: struct {
    Signature:             u32;
    Length:                u32;
    HardwareSignature:     u32;
    FirmwareWakingVector:  u32;
    GlobalLock:            u32;
    Flags:                 u32;
    XFirmwareWakingVector: u64;
    Version:               u8;
    Reserved:              [31] u8;
}

///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
EFI_ACPI_3_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER :: struct {
    Header:           EFI_ACPI_DESCRIPTION_HEADER;
    LocalApicAddress: u32;
    Flags:            u32;
}

///
/// Processor Local APIC Structure Definition
///
EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    ApicId:          u8;
    Flags:           u32;
}

///
/// IO APIC Structure
///
EFI_ACPI_3_0_IO_APIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    IoApicAddress:             u32;
    GlobalSystemInterruptBase: u32;
}

///
/// Interrupt Source Override Structure
///
EFI_ACPI_3_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Bus:                   u8;
    Source:                u8;
    GlobalSystemInterrupt: u32;
    Flags:                 u16;
}

///
/// Platform Interrupt Sources Structure Definition
///
EFI_ACPI_3_0_PLATFORM_INTERRUPT_APIC_STRUCTURE :: struct {
    Type:                         u8;
    Length:                       u8;
    Flags:                        u16;
    InterruptType:                u8;
    ProcessorId:                  u8;
    ProcessorEid:                 u8;
    IoSapicVector:                u8;
    GlobalSystemInterrupt:        u32;
    PlatformInterruptSourceFlags: u32;
    CpeiProcessorOverride:        u8;
    Reserved:                     [31] u8;
}

///
/// Non-Maskable Interrupt Source Structure
///
EFI_ACPI_3_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Flags:                 u16;
    GlobalSystemInterrupt: u32;
}

///
/// Local APIC NMI Structure
///
EFI_ACPI_3_0_LOCAL_APIC_NMI_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    Flags:           u16 #align 1;
    LocalApicLint:   u8;
}

///
/// Local APIC Address Override Structure
///
EFI_ACPI_3_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Reserved:         u16;
    LocalApicAddress: u64 #align 4;
}

///
/// IO SAPIC Structure
///
EFI_ACPI_3_0_IO_SAPIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    GlobalSystemInterruptBase: u32;
    IoSapicAddress:            u64;
}

///
/// Local SAPIC Structure
/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
///
EFI_ACPI_3_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    AcpiProcessorId:       u8;
    LocalSapicId:          u8;
    LocalSapicEid:         u8;
    Reserved:              [3] u8;
    Flags:                 u32;
    ACPIProcessorUIDValue: u32;
}

///
/// Platform Interrupt Sources Structure
///
EFI_ACPI_3_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE :: struct {
    Type:                         u8;
    Length:                       u8;
    Flags:                        u16;
    InterruptType:                u8;
    ProcessorId:                  u8;
    ProcessorEid:                 u8;
    IoSapicVector:                u8;
    GlobalSystemInterrupt:        u32;
    PlatformInterruptSourceFlags: u32;
}

///
/// Smart Battery Description Table (SBST)
///
EFI_ACPI_3_0_SMART_BATTERY_DESCRIPTION_TABLE :: struct {
    Header:              EFI_ACPI_DESCRIPTION_HEADER;
    WarningEnergyLevel:  u32;
    LowEnergyLevel:      u32;
    CriticalEnergyLevel: u32;
}

///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
EFI_ACPI_3_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE :: struct {
    Header:    EFI_ACPI_DESCRIPTION_HEADER;
    EcControl: EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    EcData:    EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE;
    Uid:       u32;
    GpeBit:    u8;
}

///
/// System Resource Affinity Table (SRAT.  The rest of the table
/// must be defined in a platform specific manner.
///
EFI_ACPI_3_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER :: struct {
    Header:    EFI_ACPI_DESCRIPTION_HEADER;
    Reserved1: u32; ///< Must be set to 1
    Reserved2: u64;
}

///
/// Processor Local APIC/SAPIC Affinity Structure Definition
///
EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE :: struct {
    Type:                 u8;
    Length:               u8;
    ProximityDomain7To0:  u8;
    ApicId:               u8;
    Flags:                u32;
    LocalSapicEid:        u8;
    ProximityDomain31To8: [3] u8;
    Reserved:             [4] u8;
}

///
/// Memory Affinity Structure Definition
///
EFI_ACPI_3_0_MEMORY_AFFINITY_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    ProximityDomain: u32 #align 2;
    Reserved1:       u16;
    AddressBaseLow:  u32;
    AddressBaseHigh: u32;
    LengthLow:       u32;
    LengthHigh:      u32;
    Reserved2:       u32;
    Flags:           u32;
    Reserved3:       u64;
}

///
/// System Locality Distance Information Table (SLIT).
/// The rest of the table is a matrix.
///
EFI_ACPI_3_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER :: struct {
    Header:                   EFI_ACPI_DESCRIPTION_HEADER;
    NumberOfSystemLocalities: u64 #align 4;
}

///
/// ACPI 4.0 Generic Address Space definition
///
EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE :: struct {
    AddressSpaceId:    u8;
    RegisterBitWidth:  u8;
    RegisterBitOffset: u8;
    AccessSize:        u8;
    Address:           u64 #align 4;
}

///
/// Root System Description Pointer Structure
///
EFI_ACPI_4_0_ROOT_SYSTEM_DESCRIPTION_POINTER :: struct {
    Signature:        u64;
    Checksum:         u8;
    OemId:            [6] u8;
    Revision:         u8;
    RsdtAddress:      u32;
    Length:           u32;
    XsdtAddress:      u64;
    ExtendedChecksum: u8;
    Reserved:         [3] u8;
}

///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
EFI_ACPI_4_0_COMMON_HEADER :: struct {
    Signature: u32;
    Length:    u32;
}

///
/// Fixed ACPI Description Table Structure (FADT)
///
EFI_ACPI_4_0_FIXED_ACPI_DESCRIPTION_TABLE :: struct {
    Header:             EFI_ACPI_DESCRIPTION_HEADER;
    FirmwareCtrl:       u32;
    Dsdt:               u32;
    Reserved0:          u8;
    PreferredPmProfile: u8;
    SciInt:             u16;
    SmiCmd:             u32;
    AcpiEnable:         u8;
    AcpiDisable:        u8;
    S4BiosReq:          u8;
    PstateCnt:          u8;
    Pm1aEvtBlk:         u32;
    Pm1bEvtBlk:         u32;
    Pm1aCntBlk:         u32;
    Pm1bCntBlk:         u32;
    Pm2CntBlk:          u32;
    PmTmrBlk:           u32;
    Gpe0Blk:            u32;
    Gpe1Blk:            u32;
    Pm1EvtLen:          u8;
    Pm1CntLen:          u8;
    Pm2CntLen:          u8;
    PmTmrLen:           u8;
    Gpe0BlkLen:         u8;
    Gpe1BlkLen:         u8;
    Gpe1Base:           u8;
    CstCnt:             u8;
    PLvl2Lat:           u16;
    PLvl3Lat:           u16;
    FlushSize:          u16;
    FlushStride:        u16;
    DutyOffset:         u8;
    DutyWidth:          u8;
    DayAlrm:            u8;
    MonAlrm:            u8;
    Century:            u8;
    IaPcBootArch:       u16 #align 1;
    Reserved1:          u8;
    Flags:              u32;
    ResetReg:           EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    ResetValue:         u8;
    Reserved2:          [3] u8;
    XFirmwareCtrl:      u64 #align 4;
    XDsdt:              u64 #align 4;
    XPm1aEvtBlk:        EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bEvtBlk:        EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE;
    XPm1aCntBlk:        EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bCntBlk:        EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE;
    XPm2CntBlk:         EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPmTmrBlk:          EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE;
    XGpe0Blk:           EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XGpe1Blk:           EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE;
}

///
/// Firmware ACPI Control Structure
///
EFI_ACPI_4_0_FIRMWARE_ACPI_CONTROL_STRUCTURE :: struct {
    Signature:             u32;
    Length:                u32;
    HardwareSignature:     u32;
    FirmwareWakingVector:  u32;
    GlobalLock:            u32;
    Flags:                 u32;
    XFirmwareWakingVector: u64;
    Version:               u8;
    Reserved0:             [3] u8;
    OspmFlags:             u32;
    Reserved1:             [24] u8;
}

///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
EFI_ACPI_4_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER :: struct {
    Header:           EFI_ACPI_DESCRIPTION_HEADER;
    LocalApicAddress: u32;
    Flags:            u32;
}

///
/// Processor Local APIC Structure Definition
///
EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    ApicId:          u8;
    Flags:           u32;
}

///
/// IO APIC Structure
///
EFI_ACPI_4_0_IO_APIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    IoApicAddress:             u32;
    GlobalSystemInterruptBase: u32;
}

///
/// Interrupt Source Override Structure
///
EFI_ACPI_4_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Bus:                   u8;
    Source:                u8;
    GlobalSystemInterrupt: u32;
    Flags:                 u16;
}

///
/// Platform Interrupt Sources Structure Definition
///
EFI_ACPI_4_0_PLATFORM_INTERRUPT_APIC_STRUCTURE :: struct {
    Type:                         u8;
    Length:                       u8;
    Flags:                        u16;
    InterruptType:                u8;
    ProcessorId:                  u8;
    ProcessorEid:                 u8;
    IoSapicVector:                u8;
    GlobalSystemInterrupt:        u32;
    PlatformInterruptSourceFlags: u32;
    CpeiProcessorOverride:        u8;
    Reserved:                     [31] u8;
}

///
/// Non-Maskable Interrupt Source Structure
///
EFI_ACPI_4_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Flags:                 u16;
    GlobalSystemInterrupt: u32;
}

///
/// Local APIC NMI Structure
///
EFI_ACPI_4_0_LOCAL_APIC_NMI_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    Flags:           u16 #align 1;
    LocalApicLint:   u8;
}

///
/// Local APIC Address Override Structure
///
EFI_ACPI_4_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Reserved:         u16;
    LocalApicAddress: u64 #align 4;
}

///
/// IO SAPIC Structure
///
EFI_ACPI_4_0_IO_SAPIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    GlobalSystemInterruptBase: u32;
    IoSapicAddress:            u64;
}

///
/// Local SAPIC Structure
/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
///
EFI_ACPI_4_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    AcpiProcessorId:       u8;
    LocalSapicId:          u8;
    LocalSapicEid:         u8;
    Reserved:              [3] u8;
    Flags:                 u32;
    ACPIProcessorUIDValue: u32;
}

///
/// Platform Interrupt Sources Structure
///
EFI_ACPI_4_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE :: struct {
    Type:                         u8;
    Length:                       u8;
    Flags:                        u16;
    InterruptType:                u8;
    ProcessorId:                  u8;
    ProcessorEid:                 u8;
    IoSapicVector:                u8;
    GlobalSystemInterrupt:        u32;
    PlatformInterruptSourceFlags: u32;
}

///
/// Processor Local x2APIC Structure Definition
///
EFI_ACPI_4_0_PROCESSOR_LOCAL_X2APIC_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Reserved:         [2] u8;
    X2ApicId:         u32;
    Flags:            u32;
    AcpiProcessorUid: u32;
}

///
/// Local x2APIC NMI Structure
///
EFI_ACPI_4_0_LOCAL_X2APIC_NMI_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Flags:            u16;
    AcpiProcessorUid: u32;
    LocalX2ApicLint:  u8;
    Reserved:         [3] u8;
}

///
/// Smart Battery Description Table (SBST)
///
EFI_ACPI_4_0_SMART_BATTERY_DESCRIPTION_TABLE :: struct {
    Header:              EFI_ACPI_DESCRIPTION_HEADER;
    WarningEnergyLevel:  u32;
    LowEnergyLevel:      u32;
    CriticalEnergyLevel: u32;
}

///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
EFI_ACPI_4_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE :: struct {
    Header:    EFI_ACPI_DESCRIPTION_HEADER;
    EcControl: EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    EcData:    EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE;
    Uid:       u32;
    GpeBit:    u8;
}

///
/// System Resource Affinity Table (SRAT.  The rest of the table
/// must be defined in a platform specific manner.
///
EFI_ACPI_4_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER :: struct {
    Header:    EFI_ACPI_DESCRIPTION_HEADER;
    Reserved1: u32; ///< Must be set to 1
    Reserved2: u64;
}

///
/// Processor Local APIC/SAPIC Affinity Structure Definition
///
EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE :: struct {
    Type:                 u8;
    Length:               u8;
    ProximityDomain7To0:  u8;
    ApicId:               u8;
    Flags:                u32;
    LocalSapicEid:        u8;
    ProximityDomain31To8: [3] u8;
    ClockDomain:          u32;
}

///
/// Memory Affinity Structure Definition
///
EFI_ACPI_4_0_MEMORY_AFFINITY_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    ProximityDomain: u32 #align 2;
    Reserved1:       u16;
    AddressBaseLow:  u32;
    AddressBaseHigh: u32;
    LengthLow:       u32;
    LengthHigh:      u32;
    Reserved2:       u32;
    Flags:           u32;
    Reserved3:       u64;
}

///
/// Processor Local x2APIC Affinity Structure Definition
///
EFI_ACPI_4_0_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    Reserved1:       [2] u8;
    ProximityDomain: u32;
    X2ApicId:        u32;
    Flags:           u32;
    ClockDomain:     u32;
    Reserved2:       [4] u8;
}

///
/// System Locality Distance Information Table (SLIT).
/// The rest of the table is a matrix.
///
EFI_ACPI_4_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER :: struct {
    Header:                   EFI_ACPI_DESCRIPTION_HEADER;
    NumberOfSystemLocalities: u64 #align 4;
}

///
/// Corrected Platform Error Polling Table (CPEP)
///
EFI_ACPI_4_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER :: struct {
    Header:   EFI_ACPI_DESCRIPTION_HEADER;
    Reserved: [8] u8;
}

///
/// Corrected Platform Error Polling Processor Structure Definition
///
EFI_ACPI_4_0_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    ProcessorId:     u8;
    ProcessorEid:    u8;
    PollingInterval: u32;
}

///
/// Maximum System Characteristics Table (MSCT)
///
EFI_ACPI_4_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER :: struct {
    Header:                          EFI_ACPI_DESCRIPTION_HEADER;
    OffsetProxDomInfo:               u32;
    MaximumNumberOfProximityDomains: u32;
    MaximumNumberOfClockDomains:     u32;
    MaximumPhysicalAddress:          u64;
}

///
/// Maximum Proximity Domain Information Structure Definition
///
EFI_ACPI_4_0_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE :: struct {
    Revision:                 u8;
    Length:                   u8;
    ProximityDomainRangeLow:  u32 #align 2;
    ProximityDomainRangeHigh: u32 #align 2;
    MaximumProcessorCapacity: u32 #align 2;
    MaximumMemoryCapacity:    u64 #align 6;
}

///
/// Boot Error Record Table (BERT)
///
EFI_ACPI_4_0_BOOT_ERROR_RECORD_TABLE_HEADER :: struct {
    Header:                EFI_ACPI_DESCRIPTION_HEADER;
    BootErrorRegionLength: u32;
    BootErrorRegion:       u64;
}

///
/// Boot Error Region Block Status Definition
///
EFI_ACPI_4_0_ERROR_BLOCK_STATUS :: struct {
    UncorrectableErrorValid:     u32;
    #place UncorrectableErrorValid; /*bitfield 1*/ CorrectableErrorValid:       u32;
    #place UncorrectableErrorValid; /*bitfield 2*/ MultipleUncorrectableErrors: u32;
    #place UncorrectableErrorValid; /*bitfield 3*/ MultipleCorrectableErrors:   u32;
    #place UncorrectableErrorValid; /*bitfield 4*/ ErrorDataEntryCount:         u32;
    #place UncorrectableErrorValid; /*bitfield 14*/ Reserved:                    u32;
}

///
/// Boot Error Region Definition
///
EFI_ACPI_4_0_BOOT_ERROR_REGION_STRUCTURE :: struct {
    BlockStatus:   EFI_ACPI_4_0_ERROR_BLOCK_STATUS;
    RawDataOffset: u32;
    RawDataLength: u32;
    DataLength:    u32;
    ErrorSeverity: u32;
}

///
/// Generic Error Data Entry Definition
///
EFI_ACPI_4_0_GENERIC_ERROR_DATA_ENTRY_STRUCTURE :: struct {
    SectionType:     [16] u8;
    ErrorSeverity:   u32;
    Revision:        u16;
    ValidationBits:  u8;
    Flags:           u8;
    ErrorDataLength: u32;
    FruId:           [16] u8;
    FruText:         [20] u8;
}

///
/// HEST - Hardware Error Source Table
///
EFI_ACPI_4_0_HARDWARE_ERROR_SOURCE_TABLE_HEADER :: struct {
    Header:           EFI_ACPI_DESCRIPTION_HEADER;
    ErrorSourceCount: u32;
}

///
/// IA-32 Architecture Machine Check Exception Structure Definition
///
EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    GlobalCapabilityInitData:     u64;
    GlobalControlInitData:        u64;
    NumberOfHardwareBanks:        u8;
    Reserved1:                    [7] u8;
}

///
/// IA-32 Architecture Machine Check Bank Structure Definition
///
EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE :: struct {
    BankNumber:                  u8;
    ClearStatusOnInitialization: u8;
    StatusDataFormat:            u8;
    Reserved0:                   u8;
    ControlRegisterMsrAddress:   u32;
    ControlInitData:             u64;
    StatusRegisterMsrAddress:    u32;
    AddressRegisterMsrAddress:   u32;
    MiscRegisterMsrAddress:      u32;
}

///
/// Hardware Error Notification Configuration Write Enable Structure Definition
///
EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE :: struct {
    Type:                           u16;
    #place Type; /*bitfield 1*/ PollInterval:                   u16;
    #place Type; /*bitfield 2*/ SwitchToPollingThresholdValue:  u16;
    #place Type; /*bitfield 3*/ SwitchToPollingThresholdWindow: u16;
    #place Type; /*bitfield 4*/ ErrorThresholdValue:            u16;
    #place Type; /*bitfield 5*/ ErrorThresholdWindow:           u16;
    #place Type; /*bitfield 6*/ Reserved:                       u16;
}

///
/// Hardware Error Notification Structure Definition
///
EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE :: struct {
    Type:                           u8;
    Length:                         u8;
    ConfigurationWriteEnable:       EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
    PollInterval:                   u32;
    Vector:                         u32;
    SwitchToPollingThresholdValue:  u32;
    SwitchToPollingThresholdWindow: u32;
    ErrorThresholdValue:            u32;
    ErrorThresholdWindow:           u32;
}

///
/// IA-32 Architecture Corrected Machine Check Structure Definition
///
EFI_ACPI_4_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    NotificationStructure:        EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
    NumberOfHardwareBanks:        u8;
    Reserved1:                    [3] u8;
}

///
/// IA-32 Architecture NMI Error Structure Definition
///
EFI_ACPI_4_0_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    NumberOfRecordsToPreAllocate: u32 #align 2;
    MaxSectionsPerRecord:         u32 #align 2;
    MaxRawDataLength:             u32 #align 2;
}

///
/// PCI Express Root Port AER Structure Definition
///
EFI_ACPI_4_0_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE :: struct {
    Type:                                u16;
    SourceId:                            u16;
    Reserved0:                           [2] u8;
    Flags:                               u8;
    Enabled:                             u8;
    NumberOfRecordsToPreAllocate:        u32;
    MaxSectionsPerRecord:                u32;
    Bus:                                 u32;
    Device:                              u16;
    Function:                            u16;
    DeviceControl:                       u16;
    Reserved1:                           [2] u8;
    UncorrectableErrorMask:              u32;
    UncorrectableErrorSeverity:          u32;
    CorrectableErrorMask:                u32;
    AdvancedErrorCapabilitiesAndControl: u32;
    RootErrorCommand:                    u32;
}

///
/// PCI Express Device AER Structure Definition
///
EFI_ACPI_4_0_PCI_EXPRESS_DEVICE_AER_STRUCTURE :: struct {
    Type:                                u16;
    SourceId:                            u16;
    Reserved0:                           [2] u8;
    Flags:                               u8;
    Enabled:                             u8;
    NumberOfRecordsToPreAllocate:        u32;
    MaxSectionsPerRecord:                u32;
    Bus:                                 u32;
    Device:                              u16;
    Function:                            u16;
    DeviceControl:                       u16;
    Reserved1:                           [2] u8;
    UncorrectableErrorMask:              u32;
    UncorrectableErrorSeverity:          u32;
    CorrectableErrorMask:                u32;
    AdvancedErrorCapabilitiesAndControl: u32;
}

///
/// PCI Express Bridge AER Structure Definition
///
EFI_ACPI_4_0_PCI_EXPRESS_BRIDGE_AER_STRUCTURE :: struct {
    Type:                                         u16;
    SourceId:                                     u16;
    Reserved0:                                    [2] u8;
    Flags:                                        u8;
    Enabled:                                      u8;
    NumberOfRecordsToPreAllocate:                 u32;
    MaxSectionsPerRecord:                         u32;
    Bus:                                          u32;
    Device:                                       u16;
    Function:                                     u16;
    DeviceControl:                                u16;
    Reserved1:                                    [2] u8;
    UncorrectableErrorMask:                       u32;
    UncorrectableErrorSeverity:                   u32;
    CorrectableErrorMask:                         u32;
    AdvancedErrorCapabilitiesAndControl:          u32;
    SecondaryUncorrectableErrorMask:              u32;
    SecondaryUncorrectableErrorSeverity:          u32;
    SecondaryAdvancedErrorCapabilitiesAndControl: u32;
}

///
/// Generic Hardware Error Source Structure Definition
///
EFI_ACPI_4_0_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    RelatedSourceId:              u16;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    MaxRawDataLength:             u32;
    ErrorStatusAddress:           EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    NotificationStructure:        EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
    ErrorStatusBlockLength:       u32;
}

///
/// Generic Error Status Definition
///
EFI_ACPI_4_0_GENERIC_ERROR_STATUS_STRUCTURE :: struct {
    BlockStatus:   EFI_ACPI_4_0_ERROR_BLOCK_STATUS;
    RawDataOffset: u32;
    RawDataLength: u32;
    DataLength:    u32;
    ErrorSeverity: u32;
}

///
/// ERST - Error Record Serialization Table
///
EFI_ACPI_4_0_ERROR_RECORD_SERIALIZATION_TABLE_HEADER :: struct {
    Header:                  EFI_ACPI_DESCRIPTION_HEADER;
    SerializationHeaderSize: u32;
    Reserved0:               [4] u8;
    InstructionEntryCount:   u32;
}

///
/// ERST Serialization Instruction Entry
///
EFI_ACPI_4_0_ERST_SERIALIZATION_INSTRUCTION_ENTRY :: struct {
    SerializationAction: u8;
    Instruction:         u8;
    Flags:               u8;
    Reserved0:           u8;
    RegisterRegion:      EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    Value:               u64;
    Mask:                u64;
}

///
/// EINJ - Error Injection Table
///
EFI_ACPI_4_0_ERROR_INJECTION_TABLE_HEADER :: struct {
    Header:              EFI_ACPI_DESCRIPTION_HEADER;
    InjectionHeaderSize: u32;
    InjectionFlags:      u8;
    Reserved0:           [3] u8;
    InjectionEntryCount: u32;
}

///
/// EINJ Injection Instruction Entry
///
EFI_ACPI_4_0_EINJ_INJECTION_INSTRUCTION_ENTRY :: struct {
    InjectionAction: u8;
    Instruction:     u8;
    Flags:           u8;
    Reserved0:       u8;
    RegisterRegion:  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    Value:           u64;
    Mask:            u64;
}

///
/// EINJ Trigger Action Table
///
EFI_ACPI_4_0_EINJ_TRIGGER_ACTION_TABLE :: struct {
    HeaderSize: u32;
    Revision:   u32;
    TableSize:  u32;
    EntryCount: u32;
}

///
/// Generic DMA Descriptor.
///
EFI_ACPI_FIXED_DMA_DESCRIPTOR :: struct {
    Header:           ACPI_SMALL_RESOURCE_HEADER;
    DmaRequestLine:   u16 #align 1;
    DmaChannel:       u16 #align 1;
    DmaTransferWidth: u8;
}

///
/// GPIO Connection Descriptor
///
EFI_ACPI_GPIO_CONNECTION_DESCRIPTOR :: struct {
    Header:                   ACPI_LARGE_RESOURCE_HEADER;
    RevisionId:               u8;
    ConnectionType:           u8;
    GeneralFlags:             u16 #align 1;
    InterruptFlags:           u16 #align 1;
    PinConfiguration:         u8;
    OutputDriveStrength:      u16;
    DebounceTimeout:          u16;
    PinTableOffset:           u16;
    ResourceSourceIndex:      u8;
    ResourceSourceNameOffset: u16 #align 1;
    VendorDataOffset:         u16 #align 1;
    VendorDataLength:         u16 #align 1;
}

///
/// Serial Bus Resource Descriptor (Generic)
///
EFI_ACPI_SERIAL_BUS_RESOURCE_DESCRIPTOR :: struct {
    Header:                 ACPI_LARGE_RESOURCE_HEADER;
    RevisionId:             u8;
    ResourceSourceIndex:    u8;
    SerialBusType:          u8;
    GeneralFlags:           u8;
    TypeSpecificFlags:      u16 #align 1;
    TypeSpecificRevisionId: u8;
    TypeDataLength:         u16;
}

///
/// Serial Bus Resource Descriptor (I2C)
///
EFI_ACPI_SERIAL_BUS_RESOURCE_I2C_DESCRIPTOR :: struct {
    Header:                 ACPI_LARGE_RESOURCE_HEADER;
    RevisionId:             u8;
    ResourceSourceIndex:    u8;
    SerialBusType:          u8;
    GeneralFlags:           u8;
    TypeSpecificFlags:      u16 #align 1;
    TypeSpecificRevisionId: u8;
    TypeDataLength:         u16;
    ConnectionSpeed:        u32;
    SlaveAddress:           u16;
}

///
/// Serial Bus Resource Descriptor (SPI)
///
EFI_ACPI_SERIAL_BUS_RESOURCE_SPI_DESCRIPTOR :: struct {
    Header:                 ACPI_LARGE_RESOURCE_HEADER;
    RevisionId:             u8;
    ResourceSourceIndex:    u8;
    SerialBusType:          u8;
    GeneralFlags:           u8;
    TypeSpecificFlags:      u16 #align 1;
    TypeSpecificRevisionId: u8;
    TypeDataLength:         u16;
    ConnectionSpeed:        u32;
    DataBitLength:          u8;
    Phase:                  u8;
    Polarity:               u8;
    DeviceSelection:        u16 #align 1;
}

///
/// Serial Bus Resource Descriptor (UART)
///
EFI_ACPI_SERIAL_BUS_RESOURCE_UART_DESCRIPTOR :: struct {
    Header:                 ACPI_LARGE_RESOURCE_HEADER;
    RevisionId:             u8;
    ResourceSourceIndex:    u8;
    SerialBusType:          u8;
    GeneralFlags:           u8;
    TypeSpecificFlags:      u16 #align 1;
    TypeSpecificRevisionId: u8;
    TypeDataLength:         u16;
    DefaultBaudRate:        u32;
    RxFIFO:                 u16;
    TxFIFO:                 u16;
    Parity:                 u8;
    SerialLinesEnabled:     u8;
}

///
/// ACPI 5.0 Generic Address Space definition
///
EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE :: struct {
    AddressSpaceId:    u8;
    RegisterBitWidth:  u8;
    RegisterBitOffset: u8;
    AccessSize:        u8;
    Address:           u64 #align 4;
}

///
/// Root System Description Pointer Structure
///
EFI_ACPI_5_0_ROOT_SYSTEM_DESCRIPTION_POINTER :: struct {
    Signature:        u64;
    Checksum:         u8;
    OemId:            [6] u8;
    Revision:         u8;
    RsdtAddress:      u32;
    Length:           u32;
    XsdtAddress:      u64;
    ExtendedChecksum: u8;
    Reserved:         [3] u8;
}

///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
EFI_ACPI_5_0_COMMON_HEADER :: struct {
    Signature: u32;
    Length:    u32;
}

///
/// Fixed ACPI Description Table Structure (FADT)
///
EFI_ACPI_5_0_FIXED_ACPI_DESCRIPTION_TABLE :: struct {
    Header:             EFI_ACPI_DESCRIPTION_HEADER;
    FirmwareCtrl:       u32;
    Dsdt:               u32;
    Reserved0:          u8;
    PreferredPmProfile: u8;
    SciInt:             u16;
    SmiCmd:             u32;
    AcpiEnable:         u8;
    AcpiDisable:        u8;
    S4BiosReq:          u8;
    PstateCnt:          u8;
    Pm1aEvtBlk:         u32;
    Pm1bEvtBlk:         u32;
    Pm1aCntBlk:         u32;
    Pm1bCntBlk:         u32;
    Pm2CntBlk:          u32;
    PmTmrBlk:           u32;
    Gpe0Blk:            u32;
    Gpe1Blk:            u32;
    Pm1EvtLen:          u8;
    Pm1CntLen:          u8;
    Pm2CntLen:          u8;
    PmTmrLen:           u8;
    Gpe0BlkLen:         u8;
    Gpe1BlkLen:         u8;
    Gpe1Base:           u8;
    CstCnt:             u8;
    PLvl2Lat:           u16;
    PLvl3Lat:           u16;
    FlushSize:          u16;
    FlushStride:        u16;
    DutyOffset:         u8;
    DutyWidth:          u8;
    DayAlrm:            u8;
    MonAlrm:            u8;
    Century:            u8;
    IaPcBootArch:       u16 #align 1;
    Reserved1:          u8;
    Flags:              u32;
    ResetReg:           EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    ResetValue:         u8;
    Reserved2:          [3] u8;
    XFirmwareCtrl:      u64 #align 4;
    XDsdt:              u64 #align 4;
    XPm1aEvtBlk:        EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bEvtBlk:        EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE;
    XPm1aCntBlk:        EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bCntBlk:        EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE;
    XPm2CntBlk:         EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPmTmrBlk:          EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE;
    XGpe0Blk:           EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XGpe1Blk:           EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE;
    SleepControlReg:    EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    SleepStatusReg:     EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE;
}

///
/// Firmware ACPI Control Structure
///
EFI_ACPI_5_0_FIRMWARE_ACPI_CONTROL_STRUCTURE :: struct {
    Signature:             u32;
    Length:                u32;
    HardwareSignature:     u32;
    FirmwareWakingVector:  u32;
    GlobalLock:            u32;
    Flags:                 u32;
    XFirmwareWakingVector: u64;
    Version:               u8;
    Reserved0:             [3] u8;
    OspmFlags:             u32;
    Reserved1:             [24] u8;
}

///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
EFI_ACPI_5_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER :: struct {
    Header:           EFI_ACPI_DESCRIPTION_HEADER;
    LocalApicAddress: u32;
    Flags:            u32;
}

///
/// Processor Local APIC Structure Definition
///
EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    ApicId:          u8;
    Flags:           u32;
}

///
/// IO APIC Structure
///
EFI_ACPI_5_0_IO_APIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    IoApicAddress:             u32;
    GlobalSystemInterruptBase: u32;
}

///
/// Interrupt Source Override Structure
///
EFI_ACPI_5_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Bus:                   u8;
    Source:                u8;
    GlobalSystemInterrupt: u32;
    Flags:                 u16;
}

///
/// Platform Interrupt Sources Structure Definition
///
EFI_ACPI_5_0_PLATFORM_INTERRUPT_APIC_STRUCTURE :: struct {
    Type:                         u8;
    Length:                       u8;
    Flags:                        u16;
    InterruptType:                u8;
    ProcessorId:                  u8;
    ProcessorEid:                 u8;
    IoSapicVector:                u8;
    GlobalSystemInterrupt:        u32;
    PlatformInterruptSourceFlags: u32;
    CpeiProcessorOverride:        u8;
    Reserved:                     [31] u8;
}

///
/// Non-Maskable Interrupt Source Structure
///
EFI_ACPI_5_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Flags:                 u16;
    GlobalSystemInterrupt: u32;
}

///
/// Local APIC NMI Structure
///
EFI_ACPI_5_0_LOCAL_APIC_NMI_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    Flags:           u16 #align 1;
    LocalApicLint:   u8;
}

///
/// Local APIC Address Override Structure
///
EFI_ACPI_5_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Reserved:         u16;
    LocalApicAddress: u64 #align 4;
}

///
/// IO SAPIC Structure
///
EFI_ACPI_5_0_IO_SAPIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    GlobalSystemInterruptBase: u32;
    IoSapicAddress:            u64;
}

///
/// Local SAPIC Structure
/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
///
EFI_ACPI_5_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    AcpiProcessorId:       u8;
    LocalSapicId:          u8;
    LocalSapicEid:         u8;
    Reserved:              [3] u8;
    Flags:                 u32;
    ACPIProcessorUIDValue: u32;
}

///
/// Platform Interrupt Sources Structure
///
EFI_ACPI_5_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE :: struct {
    Type:                         u8;
    Length:                       u8;
    Flags:                        u16;
    InterruptType:                u8;
    ProcessorId:                  u8;
    ProcessorEid:                 u8;
    IoSapicVector:                u8;
    GlobalSystemInterrupt:        u32;
    PlatformInterruptSourceFlags: u32;
}

///
/// Processor Local x2APIC Structure Definition
///
EFI_ACPI_5_0_PROCESSOR_LOCAL_X2APIC_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Reserved:         [2] u8;
    X2ApicId:         u32;
    Flags:            u32;
    AcpiProcessorUid: u32;
}

///
/// Local x2APIC NMI Structure
///
EFI_ACPI_5_0_LOCAL_X2APIC_NMI_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Flags:            u16;
    AcpiProcessorUid: u32;
    LocalX2ApicLint:  u8;
    Reserved:         [3] u8;
}

///
/// GIC Structure
///
EFI_ACPI_5_0_GIC_STRUCTURE :: struct {
    Type:                     u8;
    Length:                   u8;
    Reserved:                 u16;
    GicId:                    u32;
    AcpiProcessorUid:         u32;
    Flags:                    u32;
    ParkingProtocolVersion:   u32;
    PerformanceInterruptGsiv: u32;
    ParkedAddress:            u64;
    PhysicalBaseAddress:      u64;
}

///
/// GIC Distributor Structure
///
EFI_ACPI_5_0_GIC_DISTRIBUTOR_STRUCTURE :: struct {
    Type:                u8;
    Length:              u8;
    Reserved1:           u16;
    GicId:               u32;
    PhysicalBaseAddress: u64;
    SystemVectorBase:    u32;
    Reserved2:           u32;
}

///
/// Smart Battery Description Table (SBST)
///
EFI_ACPI_5_0_SMART_BATTERY_DESCRIPTION_TABLE :: struct {
    Header:              EFI_ACPI_DESCRIPTION_HEADER;
    WarningEnergyLevel:  u32;
    LowEnergyLevel:      u32;
    CriticalEnergyLevel: u32;
}

///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
EFI_ACPI_5_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE :: struct {
    Header:    EFI_ACPI_DESCRIPTION_HEADER;
    EcControl: EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    EcData:    EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE;
    Uid:       u32;
    GpeBit:    u8;
}

///
/// System Resource Affinity Table (SRAT).  The rest of the table
/// must be defined in a platform specific manner.
///
EFI_ACPI_5_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER :: struct {
    Header:    EFI_ACPI_DESCRIPTION_HEADER;
    Reserved1: u32; ///< Must be set to 1
    Reserved2: u64;
}

///
/// Processor Local APIC/SAPIC Affinity Structure Definition
///
EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE :: struct {
    Type:                 u8;
    Length:               u8;
    ProximityDomain7To0:  u8;
    ApicId:               u8;
    Flags:                u32;
    LocalSapicEid:        u8;
    ProximityDomain31To8: [3] u8;
    ClockDomain:          u32;
}

///
/// Memory Affinity Structure Definition
///
EFI_ACPI_5_0_MEMORY_AFFINITY_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    ProximityDomain: u32 #align 2;
    Reserved1:       u16;
    AddressBaseLow:  u32;
    AddressBaseHigh: u32;
    LengthLow:       u32;
    LengthHigh:      u32;
    Reserved2:       u32;
    Flags:           u32;
    Reserved3:       u64;
}

///
/// Processor Local x2APIC Affinity Structure Definition
///
EFI_ACPI_5_0_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    Reserved1:       [2] u8;
    ProximityDomain: u32;
    X2ApicId:        u32;
    Flags:           u32;
    ClockDomain:     u32;
    Reserved2:       [4] u8;
}

///
/// System Locality Distance Information Table (SLIT).
/// The rest of the table is a matrix.
///
EFI_ACPI_5_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER :: struct {
    Header:                   EFI_ACPI_DESCRIPTION_HEADER;
    NumberOfSystemLocalities: u64 #align 4;
}

///
/// Corrected Platform Error Polling Table (CPEP)
///
EFI_ACPI_5_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER :: struct {
    Header:   EFI_ACPI_DESCRIPTION_HEADER;
    Reserved: [8] u8;
}

///
/// Corrected Platform Error Polling Processor Structure Definition
///
EFI_ACPI_5_0_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    ProcessorId:     u8;
    ProcessorEid:    u8;
    PollingInterval: u32;
}

///
/// Maximum System Characteristics Table (MSCT)
///
EFI_ACPI_5_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER :: struct {
    Header:                          EFI_ACPI_DESCRIPTION_HEADER;
    OffsetProxDomInfo:               u32;
    MaximumNumberOfProximityDomains: u32;
    MaximumNumberOfClockDomains:     u32;
    MaximumPhysicalAddress:          u64;
}

///
/// Maximum Proximity Domain Information Structure Definition
///
EFI_ACPI_5_0_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE :: struct {
    Revision:                 u8;
    Length:                   u8;
    ProximityDomainRangeLow:  u32 #align 2;
    ProximityDomainRangeHigh: u32 #align 2;
    MaximumProcessorCapacity: u32 #align 2;
    MaximumMemoryCapacity:    u64 #align 6;
}

///
/// ACPI RAS Feature Table definition.
///
EFI_ACPI_5_0_RAS_FEATURE_TABLE :: struct {
    Header:                                 EFI_ACPI_DESCRIPTION_HEADER;
    PlatformCommunicationChannelIdentifier: [12] u8;
}

///
/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
///
EFI_ACPI_5_0_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION :: struct {
    Signature:                   u32;
    Command:                     u16;
    Status:                      u16;
    Version:                     u16;
    RASCapabilities:             [16] u8;
    SetRASCapabilities:          [16] u8;
    NumberOfRASFParameterBlocks: u16;
    SetRASCapabilitiesStatus:    u32;
}

///
/// ACPI RASF Parameter Block structure for PATROL_SCRUB
///
EFI_ACPI_5_0_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE :: struct {
    Type:                  u16;
    Version:               u16;
    Length:                u16;
    PatrolScrubCommand:    u16;
    RequestedAddressRange: [2] u64;
    ActualAddressRange:    [2] u64;
    Flags:                 u16;
    RequestedSpeed:        u8;
}

///
/// Memory Power State Table definition.
///
EFI_ACPI_5_0_MEMORY_POWER_STATUS_TABLE :: struct {
    Header:                                 EFI_ACPI_DESCRIPTION_HEADER;
    PlatformCommunicationChannelIdentifier: u8;
    Reserved:                               [3] u8;
}

///
/// MPST Platform Communication Channel Shared Memory Region definition.
///
EFI_ACPI_5_0_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION :: struct {
    Signature:                    u32;
    Command:                      u16;
    Status:                       u16;
    MemoryPowerCommandRegister:   u32;
    MemoryPowerStatusRegister:    u32;
    PowerStateId:                 u32;
    MemoryPowerNodeId:            u32;
    MemoryEnergyConsumed:         u64;
    ExpectedAveragePowerComsuned: u64;
}

///
/// MPST Memory Power Node Table
///
EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE :: struct {
    PowerStateValue:            u8;
    PowerStateInformationIndex: u8;
}

EFI_ACPI_5_0_MPST_MEMORY_POWER_STRUCTURE :: struct {
    Flag:                       u8;
    Reserved:                   u8;
    MemoryPowerNodeId:          u16;
    Length:                     u32;
    AddressBase:                u64;
    AddressLength:              u64;
    NumberOfPowerStates:        u32;
    NumberOfPhysicalComponents: u32;
}

EFI_ACPI_5_0_MPST_MEMORY_POWER_NODE_TABLE :: struct {
    MemoryPowerNodeCount: u16;
    Reserved:             [2] u8;
}

///
/// MPST Memory Power State Characteristics Table
///
EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE :: struct {
    PowerStateStructureID:      u8;
    Flag:                       u8;
    Reserved:                   u16;
    AveragePowerConsumedInMPS0: u32;
    RelativePowerSavingToMPS0:  u32;
    ExitLatencyToMPS0:          u64 #align 4;
}

EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE :: struct {
    MemoryPowerStateCharacteristicsCount: u16;
    Reserved:                             [2] u8;
}

///
/// Memory Topology Table definition.
///
EFI_ACPI_5_0_MEMORY_TOPOLOGY_TABLE :: struct {
    Header:   EFI_ACPI_DESCRIPTION_HEADER;
    Reserved: u32;
}

///
/// Common Memory Aggregator Device Structure.
///
EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Type:      u8;
    Reserved:  u8;
    Length:    u16;
    Flags:     u16;
    Reserved1: u16;
}

///
/// Socket Memory Aggregator Device Structure.
///
EFI_ACPI_5_0_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Header:           EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
    SocketIdentifier: u16;
    Reserved:         u16;
}

///
/// MemoryController Memory Aggregator Device Structure.
///
EFI_ACPI_5_0_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Header:                   EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
    ReadLatency:              u32;
    WriteLatency:             u32;
    ReadBandwidth:            u32;
    WriteBandwidth:           u32;
    OptimalAccessUnit:        u16;
    OptimalAccessAlignment:   u16;
    Reserved:                 u16;
    NumberOfProximityDomains: u16;
}

///
/// DIMM Memory Aggregator Device Structure.
///
EFI_ACPI_5_0_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Header:                      EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
    PhysicalComponentIdentifier: u16;
    Reserved:                    u16;
    SizeOfDimm:                  u32;
    SmbiosHandle:                u32;
}

///
/// Boot Graphics Resource Table definition.
///
EFI_ACPI_5_0_BOOT_GRAPHICS_RESOURCE_TABLE :: struct {
    Header:       EFI_ACPI_DESCRIPTION_HEADER;

    ///
    /// 2-bytes (16 bit) version ID. This value must be 1.
    ///
    Version:      u16;

    ///
    /// 1-byte status field indicating current status about the table.
    ///     Bits[7:1] = Reserved (must be zero)
    ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
    ///
    Status:       u8;

    ///
    /// 1-byte enumerated type field indicating format of the image.
    ///     0 = Bitmap
    ///     1 - 255  Reserved (for future use)
    ///
    ImageType:    u8;

    ///
    /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
    /// of the image bitmap.
    ///
    ImageAddress: u64;

    ///
    /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
    /// (X, Y) display offset of the top left corner of the boot image.
    /// The top left corner of the display is at offset (0, 0).
    ///
    ImageOffsetX: u32;

    ///
    /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
    /// (X, Y) display offset of the top left corner of the boot image.
    /// The top left corner of the display is at offset (0, 0).
    ///
    ImageOffsetY: u32;
}

///
/// FPDT Performance Record header
///
EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER :: struct {
    Type:     u16;
    Length:   u8;
    Revision: u8;
}

///
/// FPDT Performance Table header
///
EFI_ACPI_5_0_FPDT_PERFORMANCE_TABLE_HEADER :: struct {
    Signature: u32;
    Length:    u32;
}

///
/// FPDT Firmware Basic Boot Performance Pointer Record Structure
///
EFI_ACPI_5_0_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD :: struct {
    Header:                      EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER;
    Reserved:                    u32;

    ///
    /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
    ///
    BootPerformanceTablePointer: u64;
}

///
/// FPDT S3 Performance Table Pointer Record Structure
///
EFI_ACPI_5_0_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD :: struct {
    Header:                    EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER;
    Reserved:                  u32;

    ///
    /// 64-bit processor-relative physical address of the S3 Performance Table.
    ///
    S3PerformanceTablePointer: u64;
}

///
/// FPDT Firmware Basic Boot Performance Record Structure
///
EFI_ACPI_5_0_FPDT_FIRMWARE_BASIC_BOOT_RECORD :: struct {
    Header:                  EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER;
    Reserved:                u32;

    ///
    /// Timer value logged at the beginning of firmware image execution.
    /// This may not always be zero or near zero.
    ///
    ResetEnd:                u64;

    ///
    /// Timer value logged just prior to loading the OS boot loader into memory.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    OsLoaderLoadImageStart:  u64;

    ///
    /// Timer value logged just prior to launching the previously loaded OS boot loader image.
    /// For non-UEFI compatible boots, the timer value logged will be just prior
    /// to the INT 19h handler invocation.
    ///
    OsLoaderStartImageStart: u64;

    ///
    /// Timer value logged at the point when the OS loader calls the
    /// ExitBootServices function for UEFI compatible firmware.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    ExitBootServicesEntry:   u64;

    ///
    /// Timer value logged at the point just prior towhen the OS loader gaining
    /// control back from calls the ExitBootServices function for UEFI compatible firmware.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    ExitBootServicesExit:    u64;
}

//
// FPDT Firmware Basic Boot Performance Table
//
EFI_ACPI_5_0_FPDT_FIRMWARE_BASIC_BOOT_TABLE :: struct {
    Header: EFI_ACPI_5_0_FPDT_PERFORMANCE_TABLE_HEADER;
}

//
// FPDT Firmware S3 Boot Performance Table
//
EFI_ACPI_5_0_FPDT_FIRMWARE_S3_BOOT_TABLE :: struct {
    Header: EFI_ACPI_5_0_FPDT_PERFORMANCE_TABLE_HEADER;
}

///
/// FPDT Basic S3 Resume Performance Record
///
EFI_ACPI_5_0_FPDT_S3_RESUME_RECORD :: struct {
    Header:        EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER;

    ///
    /// A count of the number of S3 resume cycles since the last full boot sequence.
    ///
    ResumeCount:   u32;

    ///
    /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
    /// OS waking vector. Only the most recent resume cycle's time is retained.
    ///
    FullResume:    u64;

    ///
    /// Average timer value of all resume cycles logged since the last full boot
    /// sequence, including the most recent resume.  Note that the entire log of
    /// timer values does not need to be retained in order to calculate this average.
    ///
    AverageResume: u64;
}

///
/// FPDT Basic S3 Suspend Performance Record
///
EFI_ACPI_5_0_FPDT_S3_SUSPEND_RECORD :: struct {
    Header:       EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER;

    ///
    /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
    /// Only the most recent suspend cycle's timer value is retained.
    ///
    SuspendStart: u64 #align 4;

    ///
    /// Timer value recorded at the final firmware write to SLP_TYP (or other
    /// mechanism) used to trigger hardware entry to S3.
    /// Only the most recent suspend cycle's timer value is retained.
    ///
    SuspendEnd:   u64 #align 4;
}

///
/// Firmware Performance Record Table definition.
///
EFI_ACPI_5_0_FIRMWARE_PERFORMANCE_RECORD_TABLE :: struct {
    Header: EFI_ACPI_DESCRIPTION_HEADER;
}

///
/// Generic Timer Description Table definition.
///
EFI_ACPI_5_0_GENERIC_TIMER_DESCRIPTION_TABLE :: struct {
    Header:                 EFI_ACPI_DESCRIPTION_HEADER;
    PhysicalAddress:        u64 #align 4;
    GlobalFlags:            u32;
    SecurePL1TimerGSIV:     u32;
    SecurePL1TimerFlags:    u32;
    NonSecurePL1TimerGSIV:  u32;
    NonSecurePL1TimerFlags: u32;
    VirtualTimerGSIV:       u32;
    VirtualTimerFlags:      u32;
    NonSecurePL2TimerGSIV:  u32;
    NonSecurePL2TimerFlags: u32;
}

///
/// Boot Error Record Table (BERT)
///
EFI_ACPI_5_0_BOOT_ERROR_RECORD_TABLE_HEADER :: struct {
    Header:                EFI_ACPI_DESCRIPTION_HEADER;
    BootErrorRegionLength: u32;
    BootErrorRegion:       u64;
}

///
/// Boot Error Region Block Status Definition
///
EFI_ACPI_5_0_ERROR_BLOCK_STATUS :: struct {
    UncorrectableErrorValid:     u32;
    #place UncorrectableErrorValid; /*bitfield 1*/ CorrectableErrorValid:       u32;
    #place UncorrectableErrorValid; /*bitfield 2*/ MultipleUncorrectableErrors: u32;
    #place UncorrectableErrorValid; /*bitfield 3*/ MultipleCorrectableErrors:   u32;
    #place UncorrectableErrorValid; /*bitfield 4*/ ErrorDataEntryCount:         u32;
    #place UncorrectableErrorValid; /*bitfield 14*/ Reserved:                    u32;
}

///
/// Boot Error Region Definition
///
EFI_ACPI_5_0_BOOT_ERROR_REGION_STRUCTURE :: struct {
    BlockStatus:   EFI_ACPI_5_0_ERROR_BLOCK_STATUS;
    RawDataOffset: u32;
    RawDataLength: u32;
    DataLength:    u32;
    ErrorSeverity: u32;
}

///
/// Generic Error Data Entry Definition
///
EFI_ACPI_5_0_GENERIC_ERROR_DATA_ENTRY_STRUCTURE :: struct {
    SectionType:     [16] u8;
    ErrorSeverity:   u32;
    Revision:        u16;
    ValidationBits:  u8;
    Flags:           u8;
    ErrorDataLength: u32;
    FruId:           [16] u8;
    FruText:         [20] u8;
}

///
/// HEST - Hardware Error Source Table
///
EFI_ACPI_5_0_HARDWARE_ERROR_SOURCE_TABLE_HEADER :: struct {
    Header:           EFI_ACPI_DESCRIPTION_HEADER;
    ErrorSourceCount: u32;
}

///
/// IA-32 Architecture Machine Check Exception Structure Definition
///
EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    GlobalCapabilityInitData:     u64;
    GlobalControlInitData:        u64;
    NumberOfHardwareBanks:        u8;
    Reserved1:                    [7] u8;
}

///
/// IA-32 Architecture Machine Check Bank Structure Definition
///
EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE :: struct {
    BankNumber:                  u8;
    ClearStatusOnInitialization: u8;
    StatusDataFormat:            u8;
    Reserved0:                   u8;
    ControlRegisterMsrAddress:   u32;
    ControlInitData:             u64;
    StatusRegisterMsrAddress:    u32;
    AddressRegisterMsrAddress:   u32;
    MiscRegisterMsrAddress:      u32;
}

///
/// Hardware Error Notification Configuration Write Enable Structure Definition
///
EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE :: struct {
    Type:                           u16;
    #place Type; /*bitfield 1*/ PollInterval:                   u16;
    #place Type; /*bitfield 2*/ SwitchToPollingThresholdValue:  u16;
    #place Type; /*bitfield 3*/ SwitchToPollingThresholdWindow: u16;
    #place Type; /*bitfield 4*/ ErrorThresholdValue:            u16;
    #place Type; /*bitfield 5*/ ErrorThresholdWindow:           u16;
    #place Type; /*bitfield 6*/ Reserved:                       u16;
}

///
/// Hardware Error Notification Structure Definition
///
EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE :: struct {
    Type:                           u8;
    Length:                         u8;
    ConfigurationWriteEnable:       EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
    PollInterval:                   u32;
    Vector:                         u32;
    SwitchToPollingThresholdValue:  u32;
    SwitchToPollingThresholdWindow: u32;
    ErrorThresholdValue:            u32;
    ErrorThresholdWindow:           u32;
}

///
/// IA-32 Architecture Corrected Machine Check Structure Definition
///
EFI_ACPI_5_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    NotificationStructure:        EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
    NumberOfHardwareBanks:        u8;
    Reserved1:                    [3] u8;
}

///
/// IA-32 Architecture NMI Error Structure Definition
///
EFI_ACPI_5_0_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    NumberOfRecordsToPreAllocate: u32 #align 2;
    MaxSectionsPerRecord:         u32 #align 2;
    MaxRawDataLength:             u32 #align 2;
}

///
/// PCI Express Root Port AER Structure Definition
///
EFI_ACPI_5_0_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE :: struct {
    Type:                                u16;
    SourceId:                            u16;
    Reserved0:                           [2] u8;
    Flags:                               u8;
    Enabled:                             u8;
    NumberOfRecordsToPreAllocate:        u32;
    MaxSectionsPerRecord:                u32;
    Bus:                                 u32;
    Device:                              u16;
    Function:                            u16;
    DeviceControl:                       u16;
    Reserved1:                           [2] u8;
    UncorrectableErrorMask:              u32;
    UncorrectableErrorSeverity:          u32;
    CorrectableErrorMask:                u32;
    AdvancedErrorCapabilitiesAndControl: u32;
    RootErrorCommand:                    u32;
}

///
/// PCI Express Device AER Structure Definition
///
EFI_ACPI_5_0_PCI_EXPRESS_DEVICE_AER_STRUCTURE :: struct {
    Type:                                u16;
    SourceId:                            u16;
    Reserved0:                           [2] u8;
    Flags:                               u8;
    Enabled:                             u8;
    NumberOfRecordsToPreAllocate:        u32;
    MaxSectionsPerRecord:                u32;
    Bus:                                 u32;
    Device:                              u16;
    Function:                            u16;
    DeviceControl:                       u16;
    Reserved1:                           [2] u8;
    UncorrectableErrorMask:              u32;
    UncorrectableErrorSeverity:          u32;
    CorrectableErrorMask:                u32;
    AdvancedErrorCapabilitiesAndControl: u32;
}

///
/// PCI Express Bridge AER Structure Definition
///
EFI_ACPI_5_0_PCI_EXPRESS_BRIDGE_AER_STRUCTURE :: struct {
    Type:                                         u16;
    SourceId:                                     u16;
    Reserved0:                                    [2] u8;
    Flags:                                        u8;
    Enabled:                                      u8;
    NumberOfRecordsToPreAllocate:                 u32;
    MaxSectionsPerRecord:                         u32;
    Bus:                                          u32;
    Device:                                       u16;
    Function:                                     u16;
    DeviceControl:                                u16;
    Reserved1:                                    [2] u8;
    UncorrectableErrorMask:                       u32;
    UncorrectableErrorSeverity:                   u32;
    CorrectableErrorMask:                         u32;
    AdvancedErrorCapabilitiesAndControl:          u32;
    SecondaryUncorrectableErrorMask:              u32;
    SecondaryUncorrectableErrorSeverity:          u32;
    SecondaryAdvancedErrorCapabilitiesAndControl: u32;
}

///
/// Generic Hardware Error Source Structure Definition
///
EFI_ACPI_5_0_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    RelatedSourceId:              u16;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    MaxRawDataLength:             u32;
    ErrorStatusAddress:           EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    NotificationStructure:        EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
    ErrorStatusBlockLength:       u32;
}

///
/// Generic Error Status Definition
///
EFI_ACPI_5_0_GENERIC_ERROR_STATUS_STRUCTURE :: struct {
    BlockStatus:   EFI_ACPI_5_0_ERROR_BLOCK_STATUS;
    RawDataOffset: u32;
    RawDataLength: u32;
    DataLength:    u32;
    ErrorSeverity: u32;
}

///
/// ERST - Error Record Serialization Table
///
EFI_ACPI_5_0_ERROR_RECORD_SERIALIZATION_TABLE_HEADER :: struct {
    Header:                  EFI_ACPI_DESCRIPTION_HEADER;
    SerializationHeaderSize: u32;
    Reserved0:               [4] u8;
    InstructionEntryCount:   u32;
}

///
/// ERST Serialization Instruction Entry
///
EFI_ACPI_5_0_ERST_SERIALIZATION_INSTRUCTION_ENTRY :: struct {
    SerializationAction: u8;
    Instruction:         u8;
    Flags:               u8;
    Reserved0:           u8;
    RegisterRegion:      EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    Value:               u64;
    Mask:                u64;
}

///
/// EINJ - Error Injection Table
///
EFI_ACPI_5_0_ERROR_INJECTION_TABLE_HEADER :: struct {
    Header:              EFI_ACPI_DESCRIPTION_HEADER;
    InjectionHeaderSize: u32;
    InjectionFlags:      u8;
    Reserved0:           [3] u8;
    InjectionEntryCount: u32;
}

///
/// EINJ Injection Instruction Entry
///
EFI_ACPI_5_0_EINJ_INJECTION_INSTRUCTION_ENTRY :: struct {
    InjectionAction: u8;
    Instruction:     u8;
    Flags:           u8;
    Reserved0:       u8;
    RegisterRegion:  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    Value:           u64;
    Mask:            u64;
}

///
/// EINJ Trigger Action Table
///
EFI_ACPI_5_0_EINJ_TRIGGER_ACTION_TABLE :: struct {
    HeaderSize: u32;
    Revision:   u32;
    TableSize:  u32;
    EntryCount: u32;
}

///
/// Platform Communications Channel Table (PCCT)
///
EFI_ACPI_5_0_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER :: struct {
    Header:   EFI_ACPI_DESCRIPTION_HEADER;
    Flags:    u32;
    Reserved: u64;
}

///
/// PCC Subspace Structure Header
///
EFI_ACPI_5_0_PCCT_SUBSPACE_HEADER :: struct {
    Type:   u8;
    Length: u8;
}

///
/// Generic Communications Subspace Structure
///
EFI_ACPI_5_0_PCCT_SUBSPACE_GENERIC :: struct {
    Type:                         u8;
    Length:                       u8;
    Reserved:                     [6] u8;
    BaseAddress:                  u64;
    AddressLength:                u64;
    DoorbellRegister:             EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE;
    DoorbellPreserve:             u64 #align 4;
    DoorbellWrite:                u64 #align 4;
    NominalLatency:               u32;
    MaximumPeriodicAccessRate:    u32;
    MinimumRequestTurnaroundTime: u16;
}

///
/// Generic Communications Channel Shared Memory Region
///
EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND :: struct {
    Command:     u8;
    Reserved:    u8;
    #place Reserved; /*bitfield 7*/ GenerateSci: u8;
}

EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS :: struct {
    CommandComplete:      u8;
    #place CommandComplete; /*bitfield 1*/ SciDoorbell:          u8;
    #place CommandComplete; /*bitfield 2*/ Error:                u8;
    #place CommandComplete; /*bitfield 3*/ PlatformNotification: u8;
    #place CommandComplete; /*bitfield 4*/ Reserved:             u8;
    Reserved1:            u8;
}

EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER :: struct {
    Signature: u32;
    Command:   EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;
    Status:    EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;
}

///
/// ACPI 5.1 Generic Address Space definition
///
EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE :: struct {
    AddressSpaceId:    u8;
    RegisterBitWidth:  u8;
    RegisterBitOffset: u8;
    AccessSize:        u8;
    Address:           u64 #align 4;
}

///
/// Root System Description Pointer Structure
///
EFI_ACPI_5_1_ROOT_SYSTEM_DESCRIPTION_POINTER :: struct {
    Signature:        u64;
    Checksum:         u8;
    OemId:            [6] u8;
    Revision:         u8;
    RsdtAddress:      u32;
    Length:           u32;
    XsdtAddress:      u64;
    ExtendedChecksum: u8;
    Reserved:         [3] u8;
}

///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
EFI_ACPI_5_1_COMMON_HEADER :: struct {
    Signature: u32;
    Length:    u32;
}

///
/// Fixed ACPI Description Table Structure (FADT)
///
EFI_ACPI_5_1_FIXED_ACPI_DESCRIPTION_TABLE :: struct {
    Header:             EFI_ACPI_DESCRIPTION_HEADER;
    FirmwareCtrl:       u32;
    Dsdt:               u32;
    Reserved0:          u8;
    PreferredPmProfile: u8;
    SciInt:             u16;
    SmiCmd:             u32;
    AcpiEnable:         u8;
    AcpiDisable:        u8;
    S4BiosReq:          u8;
    PstateCnt:          u8;
    Pm1aEvtBlk:         u32;
    Pm1bEvtBlk:         u32;
    Pm1aCntBlk:         u32;
    Pm1bCntBlk:         u32;
    Pm2CntBlk:          u32;
    PmTmrBlk:           u32;
    Gpe0Blk:            u32;
    Gpe1Blk:            u32;
    Pm1EvtLen:          u8;
    Pm1CntLen:          u8;
    Pm2CntLen:          u8;
    PmTmrLen:           u8;
    Gpe0BlkLen:         u8;
    Gpe1BlkLen:         u8;
    Gpe1Base:           u8;
    CstCnt:             u8;
    PLvl2Lat:           u16;
    PLvl3Lat:           u16;
    FlushSize:          u16;
    FlushStride:        u16;
    DutyOffset:         u8;
    DutyWidth:          u8;
    DayAlrm:            u8;
    MonAlrm:            u8;
    Century:            u8;
    IaPcBootArch:       u16 #align 1;
    Reserved1:          u8;
    Flags:              u32;
    ResetReg:           EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE #align 4;
    ResetValue:         u8;
    ArmBootArch:        u16 #align 1;
    MinorVersion:       u8;
    XFirmwareCtrl:      u64 #align 4;
    XDsdt:              u64 #align 4;
    XPm1aEvtBlk:        EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bEvtBlk:        EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE;
    XPm1aCntBlk:        EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bCntBlk:        EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE;
    XPm2CntBlk:         EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPmTmrBlk:          EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE;
    XGpe0Blk:           EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE #align 4;
    XGpe1Blk:           EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE;
    SleepControlReg:    EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE #align 4;
    SleepStatusReg:     EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE;
}

///
/// Firmware ACPI Control Structure
///
EFI_ACPI_5_1_FIRMWARE_ACPI_CONTROL_STRUCTURE :: struct {
    Signature:             u32;
    Length:                u32;
    HardwareSignature:     u32;
    FirmwareWakingVector:  u32;
    GlobalLock:            u32;
    Flags:                 u32;
    XFirmwareWakingVector: u64;
    Version:               u8;
    Reserved0:             [3] u8;
    OspmFlags:             u32;
    Reserved1:             [24] u8;
}

///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
EFI_ACPI_5_1_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER :: struct {
    Header:           EFI_ACPI_DESCRIPTION_HEADER;
    LocalApicAddress: u32;
    Flags:            u32;
}

///
/// Processor Local APIC Structure Definition
///
EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    ApicId:          u8;
    Flags:           u32;
}

///
/// IO APIC Structure
///
EFI_ACPI_5_1_IO_APIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    IoApicAddress:             u32;
    GlobalSystemInterruptBase: u32;
}

///
/// Interrupt Source Override Structure
///
EFI_ACPI_5_1_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Bus:                   u8;
    Source:                u8;
    GlobalSystemInterrupt: u32;
    Flags:                 u16;
}

///
/// Platform Interrupt Sources Structure Definition
///
EFI_ACPI_5_1_PLATFORM_INTERRUPT_APIC_STRUCTURE :: struct {
    Type:                         u8;
    Length:                       u8;
    Flags:                        u16;
    InterruptType:                u8;
    ProcessorId:                  u8;
    ProcessorEid:                 u8;
    IoSapicVector:                u8;
    GlobalSystemInterrupt:        u32;
    PlatformInterruptSourceFlags: u32;
    CpeiProcessorOverride:        u8;
    Reserved:                     [31] u8;
}

///
/// Non-Maskable Interrupt Source Structure
///
EFI_ACPI_5_1_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Flags:                 u16;
    GlobalSystemInterrupt: u32;
}

///
/// Local APIC NMI Structure
///
EFI_ACPI_5_1_LOCAL_APIC_NMI_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    AcpiProcessorId: u8;
    Flags:           u16 #align 1;
    LocalApicLint:   u8;
}

///
/// Local APIC Address Override Structure
///
EFI_ACPI_5_1_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Reserved:         u16;
    LocalApicAddress: u64 #align 4;
}

///
/// IO SAPIC Structure
///
EFI_ACPI_5_1_IO_SAPIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    GlobalSystemInterruptBase: u32;
    IoSapicAddress:            u64;
}

///
/// Local SAPIC Structure
/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
///
EFI_ACPI_5_1_PROCESSOR_LOCAL_SAPIC_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    AcpiProcessorId:       u8;
    LocalSapicId:          u8;
    LocalSapicEid:         u8;
    Reserved:              [3] u8;
    Flags:                 u32;
    ACPIProcessorUIDValue: u32;
}

///
/// Platform Interrupt Sources Structure
///
EFI_ACPI_5_1_PLATFORM_INTERRUPT_SOURCES_STRUCTURE :: struct {
    Type:                         u8;
    Length:                       u8;
    Flags:                        u16;
    InterruptType:                u8;
    ProcessorId:                  u8;
    ProcessorEid:                 u8;
    IoSapicVector:                u8;
    GlobalSystemInterrupt:        u32;
    PlatformInterruptSourceFlags: u32;
}

///
/// Processor Local x2APIC Structure Definition
///
EFI_ACPI_5_1_PROCESSOR_LOCAL_X2APIC_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Reserved:         [2] u8;
    X2ApicId:         u32;
    Flags:            u32;
    AcpiProcessorUid: u32;
}

///
/// Local x2APIC NMI Structure
///
EFI_ACPI_5_1_LOCAL_X2APIC_NMI_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Flags:            u16;
    AcpiProcessorUid: u32;
    LocalX2ApicLint:  u8;
    Reserved:         [3] u8;
}

///
/// GIC Structure
///
EFI_ACPI_5_1_GIC_STRUCTURE :: struct {
    Type:                     u8;
    Length:                   u8;
    Reserved:                 u16;
    CPUInterfaceNumber:       u32;
    AcpiProcessorUid:         u32;
    Flags:                    u32;
    ParkingProtocolVersion:   u32;
    PerformanceInterruptGsiv: u32;
    ParkedAddress:            u64;
    PhysicalBaseAddress:      u64;
    GICV:                     u64;
    GICH:                     u64;
    VGICMaintenanceInterrupt: u32;
    GICRBaseAddress:          u64 #align 4;
    MPIDR:                    u64 #align 4;
}

///
/// GIC Distributor Structure
///
EFI_ACPI_5_1_GIC_DISTRIBUTOR_STRUCTURE :: struct {
    Type:                u8;
    Length:              u8;
    Reserved1:           u16;
    GicId:               u32;
    PhysicalBaseAddress: u64;
    SystemVectorBase:    u32;
    GicVersion:          u8;
    Reserved2:           [3] u8;
}

///
/// GIC MSI Frame Structure
///
EFI_ACPI_5_1_GIC_MSI_FRAME_STRUCTURE :: struct {
    Type:                u8;
    Length:              u8;
    Reserved1:           u16;
    GicMsiFrameId:       u32;
    PhysicalBaseAddress: u64;
    Flags:               u32;
    SPICount:            u16;
    SPIBase:             u16;
}

///
/// GICR Structure
///
EFI_ACPI_5_1_GICR_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    Reserved:                  u16;
    DiscoveryRangeBaseAddress: u64 #align 4;
    DiscoveryRangeLength:      u32;
}

///
/// Smart Battery Description Table (SBST)
///
EFI_ACPI_5_1_SMART_BATTERY_DESCRIPTION_TABLE :: struct {
    Header:              EFI_ACPI_DESCRIPTION_HEADER;
    WarningEnergyLevel:  u32;
    LowEnergyLevel:      u32;
    CriticalEnergyLevel: u32;
}

///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
EFI_ACPI_5_1_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE :: struct {
    Header:    EFI_ACPI_DESCRIPTION_HEADER;
    EcControl: EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE #align 4;
    EcData:    EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE;
    Uid:       u32;
    GpeBit:    u8;
}

///
/// System Resource Affinity Table (SRAT).  The rest of the table
/// must be defined in a platform specific manner.
///
EFI_ACPI_5_1_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER :: struct {
    Header:    EFI_ACPI_DESCRIPTION_HEADER;
    Reserved1: u32; ///< Must be set to 1
    Reserved2: u64;
}

///
/// Processor Local APIC/SAPIC Affinity Structure Definition
///
EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE :: struct {
    Type:                 u8;
    Length:               u8;
    ProximityDomain7To0:  u8;
    ApicId:               u8;
    Flags:                u32;
    LocalSapicEid:        u8;
    ProximityDomain31To8: [3] u8;
    ClockDomain:          u32;
}

///
/// Memory Affinity Structure Definition
///
EFI_ACPI_5_1_MEMORY_AFFINITY_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    ProximityDomain: u32 #align 2;
    Reserved1:       u16;
    AddressBaseLow:  u32;
    AddressBaseHigh: u32;
    LengthLow:       u32;
    LengthHigh:      u32;
    Reserved2:       u32;
    Flags:           u32;
    Reserved3:       u64;
}

///
/// Processor Local x2APIC Affinity Structure Definition
///
EFI_ACPI_5_1_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    Reserved1:       [2] u8;
    ProximityDomain: u32;
    X2ApicId:        u32;
    Flags:           u32;
    ClockDomain:     u32;
    Reserved2:       [4] u8;
}

///
/// GICC Affinity Structure Definition
///
EFI_ACPI_5_1_GICC_AFFINITY_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    ProximityDomain:  u32 #align 2;
    AcpiProcessorUid: u32 #align 2;
    Flags:            u32 #align 2;
    ClockDomain:      u32 #align 2;
}

///
/// System Locality Distance Information Table (SLIT).
/// The rest of the table is a matrix.
///
EFI_ACPI_5_1_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER :: struct {
    Header:                   EFI_ACPI_DESCRIPTION_HEADER;
    NumberOfSystemLocalities: u64 #align 4;
}

///
/// Corrected Platform Error Polling Table (CPEP)
///
EFI_ACPI_5_1_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER :: struct {
    Header:   EFI_ACPI_DESCRIPTION_HEADER;
    Reserved: [8] u8;
}

///
/// Corrected Platform Error Polling Processor Structure Definition
///
EFI_ACPI_5_1_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    ProcessorId:     u8;
    ProcessorEid:    u8;
    PollingInterval: u32;
}

///
/// Maximum System Characteristics Table (MSCT)
///
EFI_ACPI_5_1_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER :: struct {
    Header:                          EFI_ACPI_DESCRIPTION_HEADER;
    OffsetProxDomInfo:               u32;
    MaximumNumberOfProximityDomains: u32;
    MaximumNumberOfClockDomains:     u32;
    MaximumPhysicalAddress:          u64;
}

///
/// Maximum Proximity Domain Information Structure Definition
///
EFI_ACPI_5_1_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE :: struct {
    Revision:                 u8;
    Length:                   u8;
    ProximityDomainRangeLow:  u32 #align 2;
    ProximityDomainRangeHigh: u32 #align 2;
    MaximumProcessorCapacity: u32 #align 2;
    MaximumMemoryCapacity:    u64 #align 6;
}

///
/// ACPI RAS Feature Table definition.
///
EFI_ACPI_5_1_RAS_FEATURE_TABLE :: struct {
    Header:                                 EFI_ACPI_DESCRIPTION_HEADER;
    PlatformCommunicationChannelIdentifier: [12] u8;
}

///
/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
///
EFI_ACPI_5_1_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION :: struct {
    Signature:                   u32;
    Command:                     u16;
    Status:                      u16;
    Version:                     u16;
    RASCapabilities:             [16] u8;
    SetRASCapabilities:          [16] u8;
    NumberOfRASFParameterBlocks: u16;
    SetRASCapabilitiesStatus:    u32;
}

///
/// ACPI RASF Parameter Block structure for PATROL_SCRUB
///
EFI_ACPI_5_1_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE :: struct {
    Type:                  u16;
    Version:               u16;
    Length:                u16;
    PatrolScrubCommand:    u16;
    RequestedAddressRange: [2] u64;
    ActualAddressRange:    [2] u64;
    Flags:                 u16;
    RequestedSpeed:        u8;
}

///
/// Memory Power State Table definition.
///
EFI_ACPI_5_1_MEMORY_POWER_STATUS_TABLE :: struct {
    Header:                                 EFI_ACPI_DESCRIPTION_HEADER;
    PlatformCommunicationChannelIdentifier: u8;
    Reserved:                               [3] u8;
}

///
/// MPST Platform Communication Channel Shared Memory Region definition.
///
EFI_ACPI_5_1_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION :: struct {
    Signature:                    u32;
    Command:                      u16;
    Status:                       u16;
    MemoryPowerCommandRegister:   u32;
    MemoryPowerStatusRegister:    u32;
    PowerStateId:                 u32;
    MemoryPowerNodeId:            u32;
    MemoryEnergyConsumed:         u64;
    ExpectedAveragePowerComsuned: u64;
}

///
/// MPST Memory Power Node Table
///
EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE :: struct {
    PowerStateValue:            u8;
    PowerStateInformationIndex: u8;
}

EFI_ACPI_5_1_MPST_MEMORY_POWER_STRUCTURE :: struct {
    Flag:                       u8;
    Reserved:                   u8;
    MemoryPowerNodeId:          u16;
    Length:                     u32;
    AddressBase:                u64;
    AddressLength:              u64;
    NumberOfPowerStates:        u32;
    NumberOfPhysicalComponents: u32;
}

EFI_ACPI_5_1_MPST_MEMORY_POWER_NODE_TABLE :: struct {
    MemoryPowerNodeCount: u16;
    Reserved:             [2] u8;
}

///
/// MPST Memory Power State Characteristics Table
///
EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE :: struct {
    PowerStateStructureID:      u8;
    Flag:                       u8;
    Reserved:                   u16;
    AveragePowerConsumedInMPS0: u32;
    RelativePowerSavingToMPS0:  u32;
    ExitLatencyToMPS0:          u64 #align 4;
}

EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE :: struct {
    MemoryPowerStateCharacteristicsCount: u16;
    Reserved:                             [2] u8;
}

///
/// Memory Topology Table definition.
///
EFI_ACPI_5_1_MEMORY_TOPOLOGY_TABLE :: struct {
    Header:   EFI_ACPI_DESCRIPTION_HEADER;
    Reserved: u32;
}

///
/// Common Memory Aggregator Device Structure.
///
EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Type:      u8;
    Reserved:  u8;
    Length:    u16;
    Flags:     u16;
    Reserved1: u16;
}

///
/// Socket Memory Aggregator Device Structure.
///
EFI_ACPI_5_1_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Header:           EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
    SocketIdentifier: u16;
    Reserved:         u16;
}

///
/// MemoryController Memory Aggregator Device Structure.
///
EFI_ACPI_5_1_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Header:                   EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
    ReadLatency:              u32;
    WriteLatency:             u32;
    ReadBandwidth:            u32;
    WriteBandwidth:           u32;
    OptimalAccessUnit:        u16;
    OptimalAccessAlignment:   u16;
    Reserved:                 u16;
    NumberOfProximityDomains: u16;
}

///
/// DIMM Memory Aggregator Device Structure.
///
EFI_ACPI_5_1_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Header:                      EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
    PhysicalComponentIdentifier: u16;
    Reserved:                    u16;
    SizeOfDimm:                  u32;
    SmbiosHandle:                u32;
}

///
/// Boot Graphics Resource Table definition.
///
EFI_ACPI_5_1_BOOT_GRAPHICS_RESOURCE_TABLE :: struct {
    Header:       EFI_ACPI_DESCRIPTION_HEADER;

    ///
    /// 2-bytes (16 bit) version ID. This value must be 1.
    ///
    Version:      u16;

    ///
    /// 1-byte status field indicating current status about the table.
    ///     Bits[7:1] = Reserved (must be zero)
    ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
    ///
    Status:       u8;

    ///
    /// 1-byte enumerated type field indicating format of the image.
    ///     0 = Bitmap
    ///     1 - 255  Reserved (for future use)
    ///
    ImageType:    u8;

    ///
    /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
    /// of the image bitmap.
    ///
    ImageAddress: u64;

    ///
    /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
    /// (X, Y) display offset of the top left corner of the boot image.
    /// The top left corner of the display is at offset (0, 0).
    ///
    ImageOffsetX: u32;

    ///
    /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
    /// (X, Y) display offset of the top left corner of the boot image.
    /// The top left corner of the display is at offset (0, 0).
    ///
    ImageOffsetY: u32;
}

///
/// FPDT Performance Record header
///
EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER :: struct {
    Type:     u16;
    Length:   u8;
    Revision: u8;
}

///
/// FPDT Performance Table header
///
EFI_ACPI_5_1_FPDT_PERFORMANCE_TABLE_HEADER :: struct {
    Signature: u32;
    Length:    u32;
}

///
/// FPDT Firmware Basic Boot Performance Pointer Record Structure
///
EFI_ACPI_5_1_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD :: struct {
    Header:                      EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER;
    Reserved:                    u32;

    ///
    /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
    ///
    BootPerformanceTablePointer: u64;
}

///
/// FPDT S3 Performance Table Pointer Record Structure
///
EFI_ACPI_5_1_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD :: struct {
    Header:                    EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER;
    Reserved:                  u32;

    ///
    /// 64-bit processor-relative physical address of the S3 Performance Table.
    ///
    S3PerformanceTablePointer: u64;
}

///
/// FPDT Firmware Basic Boot Performance Record Structure
///
EFI_ACPI_5_1_FPDT_FIRMWARE_BASIC_BOOT_RECORD :: struct {
    Header:                  EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER;
    Reserved:                u32;

    ///
    /// Timer value logged at the beginning of firmware image execution.
    /// This may not always be zero or near zero.
    ///
    ResetEnd:                u64;

    ///
    /// Timer value logged just prior to loading the OS boot loader into memory.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    OsLoaderLoadImageStart:  u64;

    ///
    /// Timer value logged just prior to launching the previously loaded OS boot loader image.
    /// For non-UEFI compatible boots, the timer value logged will be just prior
    /// to the INT 19h handler invocation.
    ///
    OsLoaderStartImageStart: u64;

    ///
    /// Timer value logged at the point when the OS loader calls the
    /// ExitBootServices function for UEFI compatible firmware.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    ExitBootServicesEntry:   u64;

    ///
    /// Timer value logged at the point just prior towhen the OS loader gaining
    /// control back from calls the ExitBootServices function for UEFI compatible firmware.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    ExitBootServicesExit:    u64;
}

//
// FPDT Firmware Basic Boot Performance Table
//
EFI_ACPI_5_1_FPDT_FIRMWARE_BASIC_BOOT_TABLE :: struct {
    Header: EFI_ACPI_5_1_FPDT_PERFORMANCE_TABLE_HEADER;
}

//
// FPDT Firmware S3 Boot Performance Table
//
EFI_ACPI_5_1_FPDT_FIRMWARE_S3_BOOT_TABLE :: struct {
    Header: EFI_ACPI_5_1_FPDT_PERFORMANCE_TABLE_HEADER;
}

///
/// FPDT Basic S3 Resume Performance Record
///
EFI_ACPI_5_1_FPDT_S3_RESUME_RECORD :: struct {
    Header:        EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER;

    ///
    /// A count of the number of S3 resume cycles since the last full boot sequence.
    ///
    ResumeCount:   u32;

    ///
    /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
    /// OS waking vector. Only the most recent resume cycle's time is retained.
    ///
    FullResume:    u64;

    ///
    /// Average timer value of all resume cycles logged since the last full boot
    /// sequence, including the most recent resume.  Note that the entire log of
    /// timer values does not need to be retained in order to calculate this average.
    ///
    AverageResume: u64;
}

///
/// FPDT Basic S3 Suspend Performance Record
///
EFI_ACPI_5_1_FPDT_S3_SUSPEND_RECORD :: struct {
    Header:       EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER;

    ///
    /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
    /// Only the most recent suspend cycle's timer value is retained.
    ///
    SuspendStart: u64 #align 4;

    ///
    /// Timer value recorded at the final firmware write to SLP_TYP (or other
    /// mechanism) used to trigger hardware entry to S3.
    /// Only the most recent suspend cycle's timer value is retained.
    ///
    SuspendEnd:   u64 #align 4;
}

///
/// Firmware Performance Record Table definition.
///
EFI_ACPI_5_1_FIRMWARE_PERFORMANCE_RECORD_TABLE :: struct {
    Header: EFI_ACPI_DESCRIPTION_HEADER;
}

///
/// Generic Timer Description Table definition.
///
EFI_ACPI_5_1_GENERIC_TIMER_DESCRIPTION_TABLE :: struct {
    Header:                        EFI_ACPI_DESCRIPTION_HEADER;
    CntControlBasePhysicalAddress: u64 #align 4;
    Reserved:                      u32;
    SecurePL1TimerGSIV:            u32;
    SecurePL1TimerFlags:           u32;
    NonSecurePL1TimerGSIV:         u32;
    NonSecurePL1TimerFlags:        u32;
    VirtualTimerGSIV:              u32;
    VirtualTimerFlags:             u32;
    NonSecurePL2TimerGSIV:         u32;
    NonSecurePL2TimerFlags:        u32;
    CntReadBasePhysicalAddress:    u64;
    PlatformTimerCount:            u32;
    PlatformTimerOffset:           u32;
}

///
/// GT Block Structure
///
EFI_ACPI_5_1_GTDT_GT_BLOCK_STRUCTURE :: struct {
    Type:               u8;
    Length:             u16 #align 1;
    Reserved:           u8;
    CntCtlBase:         u64 #align 4;
    GTBlockTimerCount:  u32;
    GTBlockTimerOffset: u32;
}

///
/// GT Block Timer Structure
///
EFI_ACPI_5_1_GTDT_GT_BLOCK_TIMER_STRUCTURE :: struct {
    GTFrameNumber:         u8;
    Reserved:              [3] u8;
    CntBaseX:              u64 #align 4;
    CntEL0BaseX:           u64 #align 4;
    GTxPhysicalTimerGSIV:  u32;
    GTxPhysicalTimerFlags: u32;
    GTxVirtualTimerGSIV:   u32;
    GTxVirtualTimerFlags:  u32;
    GTxCommonFlags:        u32;
}

///
/// SBSA Generic Watchdog Structure
///
EFI_ACPI_5_1_GTDT_SBSA_GENERIC_WATCHDOG_STRUCTURE :: struct {
    Type:                                u8;
    Length:                              u16 #align 1;
    Reserved:                            u8;
    RefreshFramePhysicalAddress:         u64 #align 4;
    WatchdogControlFramePhysicalAddress: u64 #align 4;
    WatchdogTimerGSIV:                   u32;
    WatchdogTimerFlags:                  u32;
}

///
/// Boot Error Record Table (BERT)
///
EFI_ACPI_5_1_BOOT_ERROR_RECORD_TABLE_HEADER :: struct {
    Header:                EFI_ACPI_DESCRIPTION_HEADER;
    BootErrorRegionLength: u32;
    BootErrorRegion:       u64;
}

///
/// Boot Error Region Block Status Definition
///
EFI_ACPI_5_1_ERROR_BLOCK_STATUS :: struct {
    UncorrectableErrorValid:     u32;
    #place UncorrectableErrorValid; /*bitfield 1*/ CorrectableErrorValid:       u32;
    #place UncorrectableErrorValid; /*bitfield 2*/ MultipleUncorrectableErrors: u32;
    #place UncorrectableErrorValid; /*bitfield 3*/ MultipleCorrectableErrors:   u32;
    #place UncorrectableErrorValid; /*bitfield 4*/ ErrorDataEntryCount:         u32;
    #place UncorrectableErrorValid; /*bitfield 14*/ Reserved:                    u32;
}

///
/// Boot Error Region Definition
///
EFI_ACPI_5_1_BOOT_ERROR_REGION_STRUCTURE :: struct {
    BlockStatus:   EFI_ACPI_5_1_ERROR_BLOCK_STATUS;
    RawDataOffset: u32;
    RawDataLength: u32;
    DataLength:    u32;
    ErrorSeverity: u32;
}

///
/// Generic Error Data Entry Definition
///
EFI_ACPI_5_1_GENERIC_ERROR_DATA_ENTRY_STRUCTURE :: struct {
    SectionType:     [16] u8;
    ErrorSeverity:   u32;
    Revision:        u16;
    ValidationBits:  u8;
    Flags:           u8;
    ErrorDataLength: u32;
    FruId:           [16] u8;
    FruText:         [20] u8;
}

///
/// HEST - Hardware Error Source Table
///
EFI_ACPI_5_1_HARDWARE_ERROR_SOURCE_TABLE_HEADER :: struct {
    Header:           EFI_ACPI_DESCRIPTION_HEADER;
    ErrorSourceCount: u32;
}

///
/// IA-32 Architecture Machine Check Exception Structure Definition
///
EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    GlobalCapabilityInitData:     u64;
    GlobalControlInitData:        u64;
    NumberOfHardwareBanks:        u8;
    Reserved1:                    [7] u8;
}

///
/// IA-32 Architecture Machine Check Bank Structure Definition
///
EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE :: struct {
    BankNumber:                  u8;
    ClearStatusOnInitialization: u8;
    StatusDataFormat:            u8;
    Reserved0:                   u8;
    ControlRegisterMsrAddress:   u32;
    ControlInitData:             u64;
    StatusRegisterMsrAddress:    u32;
    AddressRegisterMsrAddress:   u32;
    MiscRegisterMsrAddress:      u32;
}

///
/// Hardware Error Notification Configuration Write Enable Structure Definition
///
EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE :: struct {
    Type:                           u16;
    #place Type; /*bitfield 1*/ PollInterval:                   u16;
    #place Type; /*bitfield 2*/ SwitchToPollingThresholdValue:  u16;
    #place Type; /*bitfield 3*/ SwitchToPollingThresholdWindow: u16;
    #place Type; /*bitfield 4*/ ErrorThresholdValue:            u16;
    #place Type; /*bitfield 5*/ ErrorThresholdWindow:           u16;
    #place Type; /*bitfield 6*/ Reserved:                       u16;
}

///
/// Hardware Error Notification Structure Definition
///
EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE :: struct {
    Type:                           u8;
    Length:                         u8;
    ConfigurationWriteEnable:       EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
    PollInterval:                   u32;
    Vector:                         u32;
    SwitchToPollingThresholdValue:  u32;
    SwitchToPollingThresholdWindow: u32;
    ErrorThresholdValue:            u32;
    ErrorThresholdWindow:           u32;
}

///
/// IA-32 Architecture Corrected Machine Check Structure Definition
///
EFI_ACPI_5_1_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    NotificationStructure:        EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
    NumberOfHardwareBanks:        u8;
    Reserved1:                    [3] u8;
}

///
/// IA-32 Architecture NMI Error Structure Definition
///
EFI_ACPI_5_1_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    NumberOfRecordsToPreAllocate: u32 #align 2;
    MaxSectionsPerRecord:         u32 #align 2;
    MaxRawDataLength:             u32 #align 2;
}

///
/// PCI Express Root Port AER Structure Definition
///
EFI_ACPI_5_1_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE :: struct {
    Type:                                u16;
    SourceId:                            u16;
    Reserved0:                           [2] u8;
    Flags:                               u8;
    Enabled:                             u8;
    NumberOfRecordsToPreAllocate:        u32;
    MaxSectionsPerRecord:                u32;
    Bus:                                 u32;
    Device:                              u16;
    Function:                            u16;
    DeviceControl:                       u16;
    Reserved1:                           [2] u8;
    UncorrectableErrorMask:              u32;
    UncorrectableErrorSeverity:          u32;
    CorrectableErrorMask:                u32;
    AdvancedErrorCapabilitiesAndControl: u32;
    RootErrorCommand:                    u32;
}

///
/// PCI Express Device AER Structure Definition
///
EFI_ACPI_5_1_PCI_EXPRESS_DEVICE_AER_STRUCTURE :: struct {
    Type:                                u16;
    SourceId:                            u16;
    Reserved0:                           [2] u8;
    Flags:                               u8;
    Enabled:                             u8;
    NumberOfRecordsToPreAllocate:        u32;
    MaxSectionsPerRecord:                u32;
    Bus:                                 u32;
    Device:                              u16;
    Function:                            u16;
    DeviceControl:                       u16;
    Reserved1:                           [2] u8;
    UncorrectableErrorMask:              u32;
    UncorrectableErrorSeverity:          u32;
    CorrectableErrorMask:                u32;
    AdvancedErrorCapabilitiesAndControl: u32;
}

///
/// PCI Express Bridge AER Structure Definition
///
EFI_ACPI_5_1_PCI_EXPRESS_BRIDGE_AER_STRUCTURE :: struct {
    Type:                                         u16;
    SourceId:                                     u16;
    Reserved0:                                    [2] u8;
    Flags:                                        u8;
    Enabled:                                      u8;
    NumberOfRecordsToPreAllocate:                 u32;
    MaxSectionsPerRecord:                         u32;
    Bus:                                          u32;
    Device:                                       u16;
    Function:                                     u16;
    DeviceControl:                                u16;
    Reserved1:                                    [2] u8;
    UncorrectableErrorMask:                       u32;
    UncorrectableErrorSeverity:                   u32;
    CorrectableErrorMask:                         u32;
    AdvancedErrorCapabilitiesAndControl:          u32;
    SecondaryUncorrectableErrorMask:              u32;
    SecondaryUncorrectableErrorSeverity:          u32;
    SecondaryAdvancedErrorCapabilitiesAndControl: u32;
}

///
/// Generic Hardware Error Source Structure Definition
///
EFI_ACPI_5_1_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    RelatedSourceId:              u16;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    MaxRawDataLength:             u32;
    ErrorStatusAddress:           EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE #align 4;
    NotificationStructure:        EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
    ErrorStatusBlockLength:       u32;
}

///
/// Generic Error Status Definition
///
EFI_ACPI_5_1_GENERIC_ERROR_STATUS_STRUCTURE :: struct {
    BlockStatus:   EFI_ACPI_5_1_ERROR_BLOCK_STATUS;
    RawDataOffset: u32;
    RawDataLength: u32;
    DataLength:    u32;
    ErrorSeverity: u32;
}

///
/// ERST - Error Record Serialization Table
///
EFI_ACPI_5_1_ERROR_RECORD_SERIALIZATION_TABLE_HEADER :: struct {
    Header:                  EFI_ACPI_DESCRIPTION_HEADER;
    SerializationHeaderSize: u32;
    Reserved0:               [4] u8;
    InstructionEntryCount:   u32;
}

///
/// ERST Serialization Instruction Entry
///
EFI_ACPI_5_1_ERST_SERIALIZATION_INSTRUCTION_ENTRY :: struct {
    SerializationAction: u8;
    Instruction:         u8;
    Flags:               u8;
    Reserved0:           u8;
    RegisterRegion:      EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE #align 4;
    Value:               u64;
    Mask:                u64;
}

///
/// EINJ - Error Injection Table
///
EFI_ACPI_5_1_ERROR_INJECTION_TABLE_HEADER :: struct {
    Header:              EFI_ACPI_DESCRIPTION_HEADER;
    InjectionHeaderSize: u32;
    InjectionFlags:      u8;
    Reserved0:           [3] u8;
    InjectionEntryCount: u32;
}

///
/// EINJ Injection Instruction Entry
///
EFI_ACPI_5_1_EINJ_INJECTION_INSTRUCTION_ENTRY :: struct {
    InjectionAction: u8;
    Instruction:     u8;
    Flags:           u8;
    Reserved0:       u8;
    RegisterRegion:  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE #align 4;
    Value:           u64;
    Mask:            u64;
}

///
/// EINJ Trigger Action Table
///
EFI_ACPI_5_1_EINJ_TRIGGER_ACTION_TABLE :: struct {
    HeaderSize: u32;
    Revision:   u32;
    TableSize:  u32;
    EntryCount: u32;
}

///
/// Platform Communications Channel Table (PCCT)
///
EFI_ACPI_5_1_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER :: struct {
    Header:   EFI_ACPI_DESCRIPTION_HEADER;
    Flags:    u32;
    Reserved: u64;
}

///
/// PCC Subspace Structure Header
///
EFI_ACPI_5_1_PCCT_SUBSPACE_HEADER :: struct {
    Type:   u8;
    Length: u8;
}

///
/// Generic Communications Subspace Structure
///
EFI_ACPI_5_1_PCCT_SUBSPACE_GENERIC :: struct {
    Type:                         u8;
    Length:                       u8;
    Reserved:                     [6] u8;
    BaseAddress:                  u64;
    AddressLength:                u64;
    DoorbellRegister:             EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE;
    DoorbellPreserve:             u64 #align 4;
    DoorbellWrite:                u64 #align 4;
    NominalLatency:               u32;
    MaximumPeriodicAccessRate:    u32;
    MinimumRequestTurnaroundTime: u16;
}

///
/// Generic Communications Channel Shared Memory Region
///
EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND :: struct {
    Command:     u8;
    Reserved:    u8;
    #place Reserved; /*bitfield 7*/ GenerateSci: u8;
}

EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS :: struct {
    CommandComplete:      u8;
    #place CommandComplete; /*bitfield 1*/ SciDoorbell:          u8;
    #place CommandComplete; /*bitfield 2*/ Error:                u8;
    #place CommandComplete; /*bitfield 3*/ PlatformNotification: u8;
    #place CommandComplete; /*bitfield 4*/ Reserved:             u8;
    Reserved1:            u8;
}

EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER :: struct {
    Signature: u32;
    Command:   EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;
    Status:    EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;
}

///
/// ACPI 6.0 Generic Address Space definition
///
EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE :: struct {
    AddressSpaceId:    u8;
    RegisterBitWidth:  u8;
    RegisterBitOffset: u8;
    AccessSize:        u8;
    Address:           u64 #align 4;
}

///
/// Root System Description Pointer Structure
///
EFI_ACPI_6_0_ROOT_SYSTEM_DESCRIPTION_POINTER :: struct {
    Signature:        u64;
    Checksum:         u8;
    OemId:            [6] u8;
    Revision:         u8;
    RsdtAddress:      u32;
    Length:           u32;
    XsdtAddress:      u64;
    ExtendedChecksum: u8;
    Reserved:         [3] u8;
}

///
/// Common table header, this prefaces all ACPI tables, including FACS, but
/// excluding the RSD PTR structure
///
EFI_ACPI_6_0_COMMON_HEADER :: struct {
    Signature: u32;
    Length:    u32;
}

///
/// Fixed ACPI Description Table Structure (FADT)
///
EFI_ACPI_6_0_FIXED_ACPI_DESCRIPTION_TABLE :: struct {
    Header:                   EFI_ACPI_DESCRIPTION_HEADER;
    FirmwareCtrl:             u32;
    Dsdt:                     u32;
    Reserved0:                u8;
    PreferredPmProfile:       u8;
    SciInt:                   u16;
    SmiCmd:                   u32;
    AcpiEnable:               u8;
    AcpiDisable:              u8;
    S4BiosReq:                u8;
    PstateCnt:                u8;
    Pm1aEvtBlk:               u32;
    Pm1bEvtBlk:               u32;
    Pm1aCntBlk:               u32;
    Pm1bCntBlk:               u32;
    Pm2CntBlk:                u32;
    PmTmrBlk:                 u32;
    Gpe0Blk:                  u32;
    Gpe1Blk:                  u32;
    Pm1EvtLen:                u8;
    Pm1CntLen:                u8;
    Pm2CntLen:                u8;
    PmTmrLen:                 u8;
    Gpe0BlkLen:               u8;
    Gpe1BlkLen:               u8;
    Gpe1Base:                 u8;
    CstCnt:                   u8;
    PLvl2Lat:                 u16;
    PLvl3Lat:                 u16;
    FlushSize:                u16;
    FlushStride:              u16;
    DutyOffset:               u8;
    DutyWidth:                u8;
    DayAlrm:                  u8;
    MonAlrm:                  u8;
    Century:                  u8;
    IaPcBootArch:             u16 #align 1;
    Reserved1:                u8;
    Flags:                    u32;
    ResetReg:                 EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    ResetValue:               u8;
    ArmBootArch:              u16 #align 1;
    MinorVersion:             u8;
    XFirmwareCtrl:            u64 #align 4;
    XDsdt:                    u64 #align 4;
    XPm1aEvtBlk:              EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bEvtBlk:              EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE;
    XPm1aCntBlk:              EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPm1bCntBlk:              EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE;
    XPm2CntBlk:               EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XPmTmrBlk:                EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE;
    XGpe0Blk:                 EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    XGpe1Blk:                 EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE;
    SleepControlReg:          EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    SleepStatusReg:           EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE;
    HypervisorVendorIdentity: u64 #align 4;
}

///
/// Firmware ACPI Control Structure
///
EFI_ACPI_6_0_FIRMWARE_ACPI_CONTROL_STRUCTURE :: struct {
    Signature:             u32;
    Length:                u32;
    HardwareSignature:     u32;
    FirmwareWakingVector:  u32;
    GlobalLock:            u32;
    Flags:                 u32;
    XFirmwareWakingVector: u64;
    Version:               u8;
    Reserved0:             [3] u8;
    OspmFlags:             u32;
    Reserved1:             [24] u8;
}

///
/// Multiple APIC Description Table header definition.  The rest of the table
/// must be defined in a platform specific manner.
///
EFI_ACPI_6_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER :: struct {
    Header:           EFI_ACPI_DESCRIPTION_HEADER;
    LocalApicAddress: u32;
    Flags:            u32;
}

///
/// Processor Local APIC Structure Definition
///
EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    AcpiProcessorUid: u8;
    ApicId:           u8;
    Flags:            u32;
}

///
/// IO APIC Structure
///
EFI_ACPI_6_0_IO_APIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    IoApicAddress:             u32;
    GlobalSystemInterruptBase: u32;
}

///
/// Interrupt Source Override Structure
///
EFI_ACPI_6_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Bus:                   u8;
    Source:                u8;
    GlobalSystemInterrupt: u32;
    Flags:                 u16;
}

///
/// Platform Interrupt Sources Structure Definition
///
EFI_ACPI_6_0_PLATFORM_INTERRUPT_APIC_STRUCTURE :: struct {
    Type:                         u8;
    Length:                       u8;
    Flags:                        u16;
    InterruptType:                u8;
    ProcessorId:                  u8;
    ProcessorEid:                 u8;
    IoSapicVector:                u8;
    GlobalSystemInterrupt:        u32;
    PlatformInterruptSourceFlags: u32;
    CpeiProcessorOverride:        u8;
    Reserved:                     [31] u8;
}

///
/// Non-Maskable Interrupt Source Structure
///
EFI_ACPI_6_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    Flags:                 u16;
    GlobalSystemInterrupt: u32;
}

///
/// Local APIC NMI Structure
///
EFI_ACPI_6_0_LOCAL_APIC_NMI_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    AcpiProcessorUid: u8;
    Flags:            u16 #align 1;
    LocalApicLint:    u8;
}

///
/// Local APIC Address Override Structure
///
EFI_ACPI_6_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Reserved:         u16;
    LocalApicAddress: u64 #align 4;
}

///
/// IO SAPIC Structure
///
EFI_ACPI_6_0_IO_SAPIC_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    IoApicId:                  u8;
    Reserved:                  u8;
    GlobalSystemInterruptBase: u32;
    IoSapicAddress:            u64;
}

///
/// Local SAPIC Structure
/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
///
EFI_ACPI_6_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE :: struct {
    Type:                  u8;
    Length:                u8;
    AcpiProcessorId:       u8;
    LocalSapicId:          u8;
    LocalSapicEid:         u8;
    Reserved:              [3] u8;
    Flags:                 u32;
    ACPIProcessorUIDValue: u32;
}

///
/// Platform Interrupt Sources Structure
///
EFI_ACPI_6_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE :: struct {
    Type:                         u8;
    Length:                       u8;
    Flags:                        u16;
    InterruptType:                u8;
    ProcessorId:                  u8;
    ProcessorEid:                 u8;
    IoSapicVector:                u8;
    GlobalSystemInterrupt:        u32;
    PlatformInterruptSourceFlags: u32;
}

///
/// Processor Local x2APIC Structure Definition
///
EFI_ACPI_6_0_PROCESSOR_LOCAL_X2APIC_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Reserved:         [2] u8;
    X2ApicId:         u32;
    Flags:            u32;
    AcpiProcessorUid: u32;
}

///
/// Local x2APIC NMI Structure
///
EFI_ACPI_6_0_LOCAL_X2APIC_NMI_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    Flags:            u16;
    AcpiProcessorUid: u32;
    LocalX2ApicLint:  u8;
    Reserved:         [3] u8;
}

///
/// GIC Structure
///
EFI_ACPI_6_0_GIC_STRUCTURE :: struct {
    Type:                          u8;
    Length:                        u8;
    Reserved:                      u16;
    CPUInterfaceNumber:            u32;
    AcpiProcessorUid:              u32;
    Flags:                         u32;
    ParkingProtocolVersion:        u32;
    PerformanceInterruptGsiv:      u32;
    ParkedAddress:                 u64;
    PhysicalBaseAddress:           u64;
    GICV:                          u64;
    GICH:                          u64;
    VGICMaintenanceInterrupt:      u32;
    GICRBaseAddress:               u64 #align 4;
    MPIDR:                         u64 #align 4;
    ProcessorPowerEfficiencyClass: u8;
    Reserved2:                     [3] u8;
}

///
/// GIC Distributor Structure
///
EFI_ACPI_6_0_GIC_DISTRIBUTOR_STRUCTURE :: struct {
    Type:                u8;
    Length:              u8;
    Reserved1:           u16;
    GicId:               u32;
    PhysicalBaseAddress: u64;
    SystemVectorBase:    u32;
    GicVersion:          u8;
    Reserved2:           [3] u8;
}

///
/// GIC MSI Frame Structure
///
EFI_ACPI_6_0_GIC_MSI_FRAME_STRUCTURE :: struct {
    Type:                u8;
    Length:              u8;
    Reserved1:           u16;
    GicMsiFrameId:       u32;
    PhysicalBaseAddress: u64;
    Flags:               u32;
    SPICount:            u16;
    SPIBase:             u16;
}

///
/// GICR Structure
///
EFI_ACPI_6_0_GICR_STRUCTURE :: struct {
    Type:                      u8;
    Length:                    u8;
    Reserved:                  u16;
    DiscoveryRangeBaseAddress: u64 #align 4;
    DiscoveryRangeLength:      u32;
}

///
/// GIC Interrupt Translation Service Structure
///
EFI_ACPI_6_0_GIC_ITS_STRUCTURE :: struct {
    Type:                u8;
    Length:              u8;
    Reserved:            u16;
    GicItsId:            u32;
    PhysicalBaseAddress: u64;
    Reserved2:           u32;
}

///
/// Smart Battery Description Table (SBST)
///
EFI_ACPI_6_0_SMART_BATTERY_DESCRIPTION_TABLE :: struct {
    Header:              EFI_ACPI_DESCRIPTION_HEADER;
    WarningEnergyLevel:  u32;
    LowEnergyLevel:      u32;
    CriticalEnergyLevel: u32;
}

///
/// Embedded Controller Boot Resources Table (ECDT)
/// The table is followed by a null terminated ASCII string that contains
/// a fully qualified reference to the name space object.
///
EFI_ACPI_6_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE :: struct {
    Header:    EFI_ACPI_DESCRIPTION_HEADER;
    EcControl: EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    EcData:    EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE;
    Uid:       u32;
    GpeBit:    u8;
}

///
/// System Resource Affinity Table (SRAT).  The rest of the table
/// must be defined in a platform specific manner.
///
EFI_ACPI_6_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER :: struct {
    Header:    EFI_ACPI_DESCRIPTION_HEADER;
    Reserved1: u32; ///< Must be set to 1
    Reserved2: u64;
}

///
/// Processor Local APIC/SAPIC Affinity Structure Definition
///
EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE :: struct {
    Type:                 u8;
    Length:               u8;
    ProximityDomain7To0:  u8;
    ApicId:               u8;
    Flags:                u32;
    LocalSapicEid:        u8;
    ProximityDomain31To8: [3] u8;
    ClockDomain:          u32;
}

///
/// Memory Affinity Structure Definition
///
EFI_ACPI_6_0_MEMORY_AFFINITY_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    ProximityDomain: u32 #align 2;
    Reserved1:       u16;
    AddressBaseLow:  u32;
    AddressBaseHigh: u32;
    LengthLow:       u32;
    LengthHigh:      u32;
    Reserved2:       u32;
    Flags:           u32;
    Reserved3:       u64;
}

///
/// Processor Local x2APIC Affinity Structure Definition
///
EFI_ACPI_6_0_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    Reserved1:       [2] u8;
    ProximityDomain: u32;
    X2ApicId:        u32;
    Flags:           u32;
    ClockDomain:     u32;
    Reserved2:       [4] u8;
}

///
/// GICC Affinity Structure Definition
///
EFI_ACPI_6_0_GICC_AFFINITY_STRUCTURE :: struct {
    Type:             u8;
    Length:           u8;
    ProximityDomain:  u32 #align 2;
    AcpiProcessorUid: u32 #align 2;
    Flags:            u32 #align 2;
    ClockDomain:      u32 #align 2;
}

///
/// System Locality Distance Information Table (SLIT).
/// The rest of the table is a matrix.
///
EFI_ACPI_6_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER :: struct {
    Header:                   EFI_ACPI_DESCRIPTION_HEADER;
    NumberOfSystemLocalities: u64 #align 4;
}

///
/// Corrected Platform Error Polling Table (CPEP)
///
EFI_ACPI_6_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER :: struct {
    Header:   EFI_ACPI_DESCRIPTION_HEADER;
    Reserved: [8] u8;
}

///
/// Corrected Platform Error Polling Processor Structure Definition
///
EFI_ACPI_6_0_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE :: struct {
    Type:            u8;
    Length:          u8;
    ProcessorId:     u8;
    ProcessorEid:    u8;
    PollingInterval: u32;
}

///
/// Maximum System Characteristics Table (MSCT)
///
EFI_ACPI_6_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER :: struct {
    Header:                          EFI_ACPI_DESCRIPTION_HEADER;
    OffsetProxDomInfo:               u32;
    MaximumNumberOfProximityDomains: u32;
    MaximumNumberOfClockDomains:     u32;
    MaximumPhysicalAddress:          u64;
}

///
/// Maximum Proximity Domain Information Structure Definition
///
EFI_ACPI_6_0_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE :: struct {
    Revision:                 u8;
    Length:                   u8;
    ProximityDomainRangeLow:  u32 #align 2;
    ProximityDomainRangeHigh: u32 #align 2;
    MaximumProcessorCapacity: u32 #align 2;
    MaximumMemoryCapacity:    u64 #align 6;
}

///
/// ACPI RAS Feature Table definition.
///
EFI_ACPI_6_0_RAS_FEATURE_TABLE :: struct {
    Header:                                 EFI_ACPI_DESCRIPTION_HEADER;
    PlatformCommunicationChannelIdentifier: [12] u8;
}

///
/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
///
EFI_ACPI_6_0_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION :: struct {
    Signature:                   u32;
    Command:                     u16;
    Status:                      u16;
    Version:                     u16;
    RASCapabilities:             [16] u8;
    SetRASCapabilities:          [16] u8;
    NumberOfRASFParameterBlocks: u16;
    SetRASCapabilitiesStatus:    u32;
}

///
/// ACPI RASF Parameter Block structure for PATROL_SCRUB
///
EFI_ACPI_6_0_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE :: struct {
    Type:                  u16;
    Version:               u16;
    Length:                u16;
    PatrolScrubCommand:    u16;
    RequestedAddressRange: [2] u64;
    ActualAddressRange:    [2] u64;
    Flags:                 u16;
    RequestedSpeed:        u8;
}

///
/// Memory Power State Table definition.
///
EFI_ACPI_6_0_MEMORY_POWER_STATUS_TABLE :: struct {
    Header:                                 EFI_ACPI_DESCRIPTION_HEADER;
    PlatformCommunicationChannelIdentifier: u8;
    Reserved:                               [3] u8;
}

///
/// MPST Platform Communication Channel Shared Memory Region definition.
///
EFI_ACPI_6_0_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION :: struct {
    Signature:                    u32;
    Command:                      u16;
    Status:                       u16;
    MemoryPowerCommandRegister:   u32;
    MemoryPowerStatusRegister:    u32;
    PowerStateId:                 u32;
    MemoryPowerNodeId:            u32;
    MemoryEnergyConsumed:         u64;
    ExpectedAveragePowerComsuned: u64;
}

///
/// MPST Memory Power Node Table
///
EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE :: struct {
    PowerStateValue:            u8;
    PowerStateInformationIndex: u8;
}

EFI_ACPI_6_0_MPST_MEMORY_POWER_STRUCTURE :: struct {
    Flag:                       u8;
    Reserved:                   u8;
    MemoryPowerNodeId:          u16;
    Length:                     u32;
    AddressBase:                u64;
    AddressLength:              u64;
    NumberOfPowerStates:        u32;
    NumberOfPhysicalComponents: u32;
}

EFI_ACPI_6_0_MPST_MEMORY_POWER_NODE_TABLE :: struct {
    MemoryPowerNodeCount: u16;
    Reserved:             [2] u8;
}

///
/// MPST Memory Power State Characteristics Table
///
EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE :: struct {
    PowerStateStructureID:      u8;
    Flag:                       u8;
    Reserved:                   u16;
    AveragePowerConsumedInMPS0: u32;
    RelativePowerSavingToMPS0:  u32;
    ExitLatencyToMPS0:          u64 #align 4;
}

EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE :: struct {
    MemoryPowerStateCharacteristicsCount: u16;
    Reserved:                             [2] u8;
}

///
/// Memory Topology Table definition.
///
EFI_ACPI_6_0_MEMORY_TOPOLOGY_TABLE :: struct {
    Header:   EFI_ACPI_DESCRIPTION_HEADER;
    Reserved: u32;
}

///
/// Common Memory Aggregator Device Structure.
///
EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Type:      u8;
    Reserved:  u8;
    Length:    u16;
    Flags:     u16;
    Reserved1: u16;
}

///
/// Socket Memory Aggregator Device Structure.
///
EFI_ACPI_6_0_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Header:           EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
    SocketIdentifier: u16;
    Reserved:         u16;
}

///
/// MemoryController Memory Aggregator Device Structure.
///
EFI_ACPI_6_0_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Header:                   EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
    ReadLatency:              u32;
    WriteLatency:             u32;
    ReadBandwidth:            u32;
    WriteBandwidth:           u32;
    OptimalAccessUnit:        u16;
    OptimalAccessAlignment:   u16;
    Reserved:                 u16;
    NumberOfProximityDomains: u16;
}

///
/// DIMM Memory Aggregator Device Structure.
///
EFI_ACPI_6_0_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE :: struct {
    Header:                      EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
    PhysicalComponentIdentifier: u16;
    Reserved:                    u16;
    SizeOfDimm:                  u32;
    SmbiosHandle:                u32;
}

///
/// Boot Graphics Resource Table definition.
///
EFI_ACPI_6_0_BOOT_GRAPHICS_RESOURCE_TABLE :: struct {
    Header:       EFI_ACPI_DESCRIPTION_HEADER;

    ///
    /// 2-bytes (16 bit) version ID. This value must be 1.
    ///
    Version:      u16;

    ///
    /// 1-byte status field indicating current status about the table.
    ///     Bits[7:1] = Reserved (must be zero)
    ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
    ///
    Status:       u8;

    ///
    /// 1-byte enumerated type field indicating format of the image.
    ///     0 = Bitmap
    ///     1 - 255  Reserved (for future use)
    ///
    ImageType:    u8;

    ///
    /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
    /// of the image bitmap.
    ///
    ImageAddress: u64;

    ///
    /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
    /// (X, Y) display offset of the top left corner of the boot image.
    /// The top left corner of the display is at offset (0, 0).
    ///
    ImageOffsetX: u32;

    ///
    /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
    /// (X, Y) display offset of the top left corner of the boot image.
    /// The top left corner of the display is at offset (0, 0).
    ///
    ImageOffsetY: u32;
}

///
/// FPDT Performance Record header
///
EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER :: struct {
    Type:     u16;
    Length:   u8;
    Revision: u8;
}

///
/// FPDT Performance Table header
///
EFI_ACPI_6_0_FPDT_PERFORMANCE_TABLE_HEADER :: struct {
    Signature: u32;
    Length:    u32;
}

///
/// FPDT Firmware Basic Boot Performance Pointer Record Structure
///
EFI_ACPI_6_0_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD :: struct {
    Header:                      EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER;
    Reserved:                    u32;

    ///
    /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
    ///
    BootPerformanceTablePointer: u64;
}

///
/// FPDT S3 Performance Table Pointer Record Structure
///
EFI_ACPI_6_0_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD :: struct {
    Header:                    EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER;
    Reserved:                  u32;

    ///
    /// 64-bit processor-relative physical address of the S3 Performance Table.
    ///
    S3PerformanceTablePointer: u64;
}

///
/// FPDT Firmware Basic Boot Performance Record Structure
///
EFI_ACPI_6_0_FPDT_FIRMWARE_BASIC_BOOT_RECORD :: struct {
    Header:                  EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER;
    Reserved:                u32;

    ///
    /// Timer value logged at the beginning of firmware image execution.
    /// This may not always be zero or near zero.
    ///
    ResetEnd:                u64;

    ///
    /// Timer value logged just prior to loading the OS boot loader into memory.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    OsLoaderLoadImageStart:  u64;

    ///
    /// Timer value logged just prior to launching the previously loaded OS boot loader image.
    /// For non-UEFI compatible boots, the timer value logged will be just prior
    /// to the INT 19h handler invocation.
    ///
    OsLoaderStartImageStart: u64;

    ///
    /// Timer value logged at the point when the OS loader calls the
    /// ExitBootServices function for UEFI compatible firmware.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    ExitBootServicesEntry:   u64;

    ///
    /// Timer value logged at the point just prior towhen the OS loader gaining
    /// control back from calls the ExitBootServices function for UEFI compatible firmware.
    /// For non-UEFI compatible boots, this field must be zero.
    ///
    ExitBootServicesExit:    u64;
}

//
// FPDT Firmware Basic Boot Performance Table
//
EFI_ACPI_6_0_FPDT_FIRMWARE_BASIC_BOOT_TABLE :: struct {
    Header: EFI_ACPI_6_0_FPDT_PERFORMANCE_TABLE_HEADER;
}

//
// FPDT Firmware S3 Boot Performance Table
//
EFI_ACPI_6_0_FPDT_FIRMWARE_S3_BOOT_TABLE :: struct {
    Header: EFI_ACPI_6_0_FPDT_PERFORMANCE_TABLE_HEADER;
}

///
/// FPDT Basic S3 Resume Performance Record
///
EFI_ACPI_6_0_FPDT_S3_RESUME_RECORD :: struct {
    Header:        EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER;

    ///
    /// A count of the number of S3 resume cycles since the last full boot sequence.
    ///
    ResumeCount:   u32;

    ///
    /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
    /// OS waking vector. Only the most recent resume cycle's time is retained.
    ///
    FullResume:    u64;

    ///
    /// Average timer value of all resume cycles logged since the last full boot
    /// sequence, including the most recent resume.  Note that the entire log of
    /// timer values does not need to be retained in order to calculate this average.
    ///
    AverageResume: u64;
}

///
/// FPDT Basic S3 Suspend Performance Record
///
EFI_ACPI_6_0_FPDT_S3_SUSPEND_RECORD :: struct {
    Header:       EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER;

    ///
    /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
    /// Only the most recent suspend cycle's timer value is retained.
    ///
    SuspendStart: u64 #align 4;

    ///
    /// Timer value recorded at the final firmware write to SLP_TYP (or other
    /// mechanism) used to trigger hardware entry to S3.
    /// Only the most recent suspend cycle's timer value is retained.
    ///
    SuspendEnd:   u64 #align 4;
}

///
/// Firmware Performance Record Table definition.
///
EFI_ACPI_6_0_FIRMWARE_PERFORMANCE_RECORD_TABLE :: struct {
    Header: EFI_ACPI_DESCRIPTION_HEADER;
}

///
/// Generic Timer Description Table definition.
///
EFI_ACPI_6_0_GENERIC_TIMER_DESCRIPTION_TABLE :: struct {
    Header:                        EFI_ACPI_DESCRIPTION_HEADER;
    CntControlBasePhysicalAddress: u64 #align 4;
    Reserved:                      u32;
    SecurePL1TimerGSIV:            u32;
    SecurePL1TimerFlags:           u32;
    NonSecurePL1TimerGSIV:         u32;
    NonSecurePL1TimerFlags:        u32;
    VirtualTimerGSIV:              u32;
    VirtualTimerFlags:             u32;
    NonSecurePL2TimerGSIV:         u32;
    NonSecurePL2TimerFlags:        u32;
    CntReadBasePhysicalAddress:    u64;
    PlatformTimerCount:            u32;
    PlatformTimerOffset:           u32;
}

///
/// GT Block Structure
///
EFI_ACPI_6_0_GTDT_GT_BLOCK_STRUCTURE :: struct {
    Type:               u8;
    Length:             u16 #align 1;
    Reserved:           u8;
    CntCtlBase:         u64 #align 4;
    GTBlockTimerCount:  u32;
    GTBlockTimerOffset: u32;
}

///
/// GT Block Timer Structure
///
EFI_ACPI_6_0_GTDT_GT_BLOCK_TIMER_STRUCTURE :: struct {
    GTFrameNumber:         u8;
    Reserved:              [3] u8;
    CntBaseX:              u64 #align 4;
    CntEL0BaseX:           u64 #align 4;
    GTxPhysicalTimerGSIV:  u32;
    GTxPhysicalTimerFlags: u32;
    GTxVirtualTimerGSIV:   u32;
    GTxVirtualTimerFlags:  u32;
    GTxCommonFlags:        u32;
}

///
/// SBSA Generic Watchdog Structure
///
EFI_ACPI_6_0_GTDT_SBSA_GENERIC_WATCHDOG_STRUCTURE :: struct {
    Type:                                u8;
    Length:                              u16 #align 1;
    Reserved:                            u8;
    RefreshFramePhysicalAddress:         u64 #align 4;
    WatchdogControlFramePhysicalAddress: u64 #align 4;
    WatchdogTimerGSIV:                   u32;
    WatchdogTimerFlags:                  u32;
}

//
// NVDIMM Firmware Interface Table definition.
//
EFI_ACPI_6_0_NVDIMM_FIRMWARE_INTERFACE_TABLE :: struct {
    Header:   EFI_ACPI_DESCRIPTION_HEADER;
    Reserved: u32;
}

//
// Definition for NFIT Structure Header
//
EFI_ACPI_6_0_NFIT_STRUCTURE_HEADER :: struct {
    Type:   u16;
    Length: u16;
}

EFI_ACPI_6_0_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE :: struct {
    Type:                               u16;
    Length:                             u16;
    SPARangeStructureIndex:             u16;
    Flags:                              u16;
    Reserved_8:                         u32;
    ProximityDomain:                    u32;
    AddressRangeTypeGUID:               GUID;
    SystemPhysicalAddressRangeBase:     u64;
    SystemPhysicalAddressRangeLength:   u64;
    AddressRangeMemoryMappingAttribute: u64;
}

//
// Definition for Memory Device to System Physical Address Range Mapping Structure
//
EFI_ACPI_6_0_NFIT_DEVICE_HANDLE :: struct {
    DIMMNumber:          u32;
    #place DIMMNumber; /*bitfield 4*/ MemoryChannelNumber: u32;
    #place DIMMNumber; /*bitfield 8*/ MemoryControllerID:  u32;
    #place DIMMNumber; /*bitfield 12*/ SocketID:            u32;
    #place DIMMNumber; /*bitfield 16*/ NodeControllerID:    u32;
    #place DIMMNumber; /*bitfield 28*/ Reserved_28:         u32;
}

EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_TO_SYSTEM_ADDRESS_RANGE_MAP_STRUCTURE :: struct {
    Type:                                  u16;
    Length:                                u16;
    NFITDeviceHandle:                      EFI_ACPI_6_0_NFIT_DEVICE_HANDLE;
    MemoryDevicePhysicalID:                u16;
    MemoryDeviceRegionID:                  u16;
    SPARangeStructureIndex:                u16;
    NVDIMMControlRegionStructureIndex:     u16;
    MemoryDeviceRegionSize:                u64;
    RegionOffset:                          u64;
    MemoryDevicePhysicalAddressRegionBase: u64;
    InterleaveStructureIndex:              u16;
    InterleaveWays:                        u16;
    MemoryDeviceStateFlags:                u16;
    Reserved_46:                           u16;
}

//
// Definition for Interleave Structure
//
EFI_ACPI_6_0_NFIT_INTERLEAVE_STRUCTURE :: struct {
    Type:                     u16;
    Length:                   u16;
    InterleaveStructureIndex: u16;
    Reserved_6:               u16;
    NumberOfLines:            u32;
    LineSize:                 u32;
}

//
// Definition for SMBIOS Management Information Structure
//
EFI_ACPI_6_0_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE :: struct {
    Type:       u16;
    Length:     u16;
    Reserved_4: u32;
}

EFI_ACPI_6_0_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE :: struct {
    Type:                                       u16;
    Length:                                     u16;
    NVDIMMControlRegionStructureIndex:          u16;
    VendorID:                                   u16;
    DeviceID:                                   u16;
    RevisionID:                                 u16;
    SubsystemVendorID:                          u16;
    SubsystemDeviceID:                          u16;
    SubsystemRevisionID:                        u16;
    Reserved_18:                                [6] u8;
    SerialNumber:                               u32;
    RegionFormatInterfaceCode:                  u16;
    NumberOfBlockControlWindows:                u16;
    SizeOfBlockControlWindow:                   u64;
    CommandRegisterOffsetInBlockControlWindow:  u64;
    SizeOfCommandRegisterInBlockControlWindows: u64;
    StatusRegisterOffsetInBlockControlWindow:   u64;
    SizeOfStatusRegisterInBlockControlWindows:  u64;
    NVDIMMControlRegionFlag:                    u16;
    Reserved_74:                                [6] u8;
}

//
// Definition for NVDIMM Block Data Window Region Structure
//
EFI_ACPI_6_0_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE :: struct {
    Type:                                                u16;
    Length:                                              u16;
    NVDIMMControlRegionStructureIndex:                   u16;
    NumberOfBlockDataWindows:                            u16;
    BlockDataWindowStartOffset:                          u64;
    SizeOfBlockDataWindow:                               u64;
    BlockAccessibleMemoryCapacity:                       u64;
    BeginningAddressOfFirstBlockInBlockAccessibleMemory: u64;
}

//
// Definition for Flush Hint Address Structure
//
EFI_ACPI_6_0_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE :: struct {
    Type:                       u16;
    Length:                     u16;
    NFITDeviceHandle:           EFI_ACPI_6_0_NFIT_DEVICE_HANDLE;
    NumberOfFlushHintAddresses: u16;
    Reserved_10:                [6] u8;
}

///
/// Boot Error Record Table (BERT)
///
EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_HEADER :: struct {
    Header:                EFI_ACPI_DESCRIPTION_HEADER;
    BootErrorRegionLength: u32;
    BootErrorRegion:       u64;
}

///
/// Boot Error Region Block Status Definition
///
EFI_ACPI_6_0_ERROR_BLOCK_STATUS :: struct {
    UncorrectableErrorValid:     u32;
    #place UncorrectableErrorValid; /*bitfield 1*/ CorrectableErrorValid:       u32;
    #place UncorrectableErrorValid; /*bitfield 2*/ MultipleUncorrectableErrors: u32;
    #place UncorrectableErrorValid; /*bitfield 3*/ MultipleCorrectableErrors:   u32;
    #place UncorrectableErrorValid; /*bitfield 4*/ ErrorDataEntryCount:         u32;
    #place UncorrectableErrorValid; /*bitfield 14*/ Reserved:                    u32;
}

///
/// Boot Error Region Definition
///
EFI_ACPI_6_0_BOOT_ERROR_REGION_STRUCTURE :: struct {
    BlockStatus:   EFI_ACPI_6_0_ERROR_BLOCK_STATUS;
    RawDataOffset: u32;
    RawDataLength: u32;
    DataLength:    u32;
    ErrorSeverity: u32;
}

///
/// Generic Error Data Entry Definition
///
EFI_ACPI_6_0_GENERIC_ERROR_DATA_ENTRY_STRUCTURE :: struct {
    SectionType:     [16] u8;
    ErrorSeverity:   u32;
    Revision:        u16;
    ValidationBits:  u8;
    Flags:           u8;
    ErrorDataLength: u32;
    FruId:           [16] u8;
    FruText:         [20] u8;
}

///
/// HEST - Hardware Error Source Table
///
EFI_ACPI_6_0_HARDWARE_ERROR_SOURCE_TABLE_HEADER :: struct {
    Header:           EFI_ACPI_DESCRIPTION_HEADER;
    ErrorSourceCount: u32;
}

///
/// IA-32 Architecture Machine Check Exception Structure Definition
///
EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    GlobalCapabilityInitData:     u64;
    GlobalControlInitData:        u64;
    NumberOfHardwareBanks:        u8;
    Reserved1:                    [7] u8;
}

///
/// IA-32 Architecture Machine Check Bank Structure Definition
///
EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE :: struct {
    BankNumber:                  u8;
    ClearStatusOnInitialization: u8;
    StatusDataFormat:            u8;
    Reserved0:                   u8;
    ControlRegisterMsrAddress:   u32;
    ControlInitData:             u64;
    StatusRegisterMsrAddress:    u32;
    AddressRegisterMsrAddress:   u32;
    MiscRegisterMsrAddress:      u32;
}

///
/// Hardware Error Notification Configuration Write Enable Structure Definition
///
EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE :: struct {
    Type:                           u16;
    #place Type; /*bitfield 1*/ PollInterval:                   u16;
    #place Type; /*bitfield 2*/ SwitchToPollingThresholdValue:  u16;
    #place Type; /*bitfield 3*/ SwitchToPollingThresholdWindow: u16;
    #place Type; /*bitfield 4*/ ErrorThresholdValue:            u16;
    #place Type; /*bitfield 5*/ ErrorThresholdWindow:           u16;
    #place Type; /*bitfield 6*/ Reserved:                       u16;
}

///
/// Hardware Error Notification Structure Definition
///
EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE :: struct {
    Type:                           u8;
    Length:                         u8;
    ConfigurationWriteEnable:       EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
    PollInterval:                   u32;
    Vector:                         u32;
    SwitchToPollingThresholdValue:  u32;
    SwitchToPollingThresholdWindow: u32;
    ErrorThresholdValue:            u32;
    ErrorThresholdWindow:           u32;
}

///
/// IA-32 Architecture Corrected Machine Check Structure Definition
///
EFI_ACPI_6_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    NotificationStructure:        EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
    NumberOfHardwareBanks:        u8;
    Reserved1:                    [3] u8;
}

///
/// IA-32 Architecture NMI Error Structure Definition
///
EFI_ACPI_6_0_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    Reserved0:                    [2] u8;
    NumberOfRecordsToPreAllocate: u32 #align 2;
    MaxSectionsPerRecord:         u32 #align 2;
    MaxRawDataLength:             u32 #align 2;
}

///
/// PCI Express Root Port AER Structure Definition
///
EFI_ACPI_6_0_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE :: struct {
    Type:                                u16;
    SourceId:                            u16;
    Reserved0:                           [2] u8;
    Flags:                               u8;
    Enabled:                             u8;
    NumberOfRecordsToPreAllocate:        u32;
    MaxSectionsPerRecord:                u32;
    Bus:                                 u32;
    Device:                              u16;
    Function:                            u16;
    DeviceControl:                       u16;
    Reserved1:                           [2] u8;
    UncorrectableErrorMask:              u32;
    UncorrectableErrorSeverity:          u32;
    CorrectableErrorMask:                u32;
    AdvancedErrorCapabilitiesAndControl: u32;
    RootErrorCommand:                    u32;
}

///
/// PCI Express Device AER Structure Definition
///
EFI_ACPI_6_0_PCI_EXPRESS_DEVICE_AER_STRUCTURE :: struct {
    Type:                                u16;
    SourceId:                            u16;
    Reserved0:                           [2] u8;
    Flags:                               u8;
    Enabled:                             u8;
    NumberOfRecordsToPreAllocate:        u32;
    MaxSectionsPerRecord:                u32;
    Bus:                                 u32;
    Device:                              u16;
    Function:                            u16;
    DeviceControl:                       u16;
    Reserved1:                           [2] u8;
    UncorrectableErrorMask:              u32;
    UncorrectableErrorSeverity:          u32;
    CorrectableErrorMask:                u32;
    AdvancedErrorCapabilitiesAndControl: u32;
}

///
/// PCI Express Bridge AER Structure Definition
///
EFI_ACPI_6_0_PCI_EXPRESS_BRIDGE_AER_STRUCTURE :: struct {
    Type:                                         u16;
    SourceId:                                     u16;
    Reserved0:                                    [2] u8;
    Flags:                                        u8;
    Enabled:                                      u8;
    NumberOfRecordsToPreAllocate:                 u32;
    MaxSectionsPerRecord:                         u32;
    Bus:                                          u32;
    Device:                                       u16;
    Function:                                     u16;
    DeviceControl:                                u16;
    Reserved1:                                    [2] u8;
    UncorrectableErrorMask:                       u32;
    UncorrectableErrorSeverity:                   u32;
    CorrectableErrorMask:                         u32;
    AdvancedErrorCapabilitiesAndControl:          u32;
    SecondaryUncorrectableErrorMask:              u32;
    SecondaryUncorrectableErrorSeverity:          u32;
    SecondaryAdvancedErrorCapabilitiesAndControl: u32;
}

///
/// Generic Hardware Error Source Structure Definition
///
EFI_ACPI_6_0_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE :: struct {
    Type:                         u16;
    SourceId:                     u16;
    RelatedSourceId:              u16;
    Flags:                        u8;
    Enabled:                      u8;
    NumberOfRecordsToPreAllocate: u32;
    MaxSectionsPerRecord:         u32;
    MaxRawDataLength:             u32;
    ErrorStatusAddress:           EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    NotificationStructure:        EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
    ErrorStatusBlockLength:       u32;
}

///
/// Generic Error Status Definition
///
EFI_ACPI_6_0_GENERIC_ERROR_STATUS_STRUCTURE :: struct {
    BlockStatus:   EFI_ACPI_6_0_ERROR_BLOCK_STATUS;
    RawDataOffset: u32;
    RawDataLength: u32;
    DataLength:    u32;
    ErrorSeverity: u32;
}

///
/// ERST - Error Record Serialization Table
///
EFI_ACPI_6_0_ERROR_RECORD_SERIALIZATION_TABLE_HEADER :: struct {
    Header:                  EFI_ACPI_DESCRIPTION_HEADER;
    SerializationHeaderSize: u32;
    Reserved0:               [4] u8;
    InstructionEntryCount:   u32;
}

///
/// ERST Serialization Instruction Entry
///
EFI_ACPI_6_0_ERST_SERIALIZATION_INSTRUCTION_ENTRY :: struct {
    SerializationAction: u8;
    Instruction:         u8;
    Flags:               u8;
    Reserved0:           u8;
    RegisterRegion:      EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    Value:               u64;
    Mask:                u64;
}

///
/// EINJ - Error Injection Table
///
EFI_ACPI_6_0_ERROR_INJECTION_TABLE_HEADER :: struct {
    Header:              EFI_ACPI_DESCRIPTION_HEADER;
    InjectionHeaderSize: u32;
    InjectionFlags:      u8;
    Reserved0:           [3] u8;
    InjectionEntryCount: u32;
}

///
/// EINJ Injection Instruction Entry
///
EFI_ACPI_6_0_EINJ_INJECTION_INSTRUCTION_ENTRY :: struct {
    InjectionAction: u8;
    Instruction:     u8;
    Flags:           u8;
    Reserved0:       u8;
    RegisterRegion:  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE #align 4;
    Value:           u64;
    Mask:            u64;
}

///
/// EINJ Trigger Action Table
///
EFI_ACPI_6_0_EINJ_TRIGGER_ACTION_TABLE :: struct {
    HeaderSize: u32;
    Revision:   u32;
    TableSize:  u32;
    EntryCount: u32;
}

///
/// Platform Communications Channel Table (PCCT)
///
EFI_ACPI_6_0_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER :: struct {
    Header:   EFI_ACPI_DESCRIPTION_HEADER;
    Flags:    u32;
    Reserved: u64;
}

///
/// PCC Subspace Structure Header
///
EFI_ACPI_6_0_PCCT_SUBSPACE_HEADER :: struct {
    Type:   u8;
    Length: u8;
}

///
/// Generic Communications Subspace Structure
///
EFI_ACPI_6_0_PCCT_SUBSPACE_GENERIC :: struct {
    Type:                         u8;
    Length:                       u8;
    Reserved:                     [6] u8;
    BaseAddress:                  u64;
    AddressLength:                u64;
    DoorbellRegister:             EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE;
    DoorbellPreserve:             u64 #align 4;
    DoorbellWrite:                u64 #align 4;
    NominalLatency:               u32;
    MaximumPeriodicAccessRate:    u32;
    MinimumRequestTurnaroundTime: u16;
}

///
/// Generic Communications Channel Shared Memory Region
///
EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND :: struct {
    Command:     u8;
    Reserved:    u8;
    #place Reserved; /*bitfield 7*/ GenerateSci: u8;
}

EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS :: struct {
    CommandComplete:      u8;
    #place CommandComplete; /*bitfield 1*/ SciDoorbell:          u8;
    #place CommandComplete; /*bitfield 2*/ Error:                u8;
    #place CommandComplete; /*bitfield 3*/ PlatformNotification: u8;
    #place CommandComplete; /*bitfield 4*/ Reserved:             u8;
    Reserved1:            u8;
}

EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER :: struct {
    Signature: u32;
    Command:   EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;
    Status:    EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;
}

///
/// Type 1 HW-Reduced Communications Subspace Structure
///
EFI_ACPI_6_0_PCCT_SUBSPACE_1_HW_REDUCED_COMMUNICATIONS :: struct {
    Type:                         u8;
    Length:                       u8;
    DoorbellInterrupt:            u32 #align 2;
    DoorbellInterruptFlags:       u8;
    Reserved:                     u8;
    BaseAddress:                  u64;
    AddressLength:                u64;
    DoorbellRegister:             EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE;
    DoorbellPreserve:             u64 #align 4;
    DoorbellWrite:                u64 #align 4;
    NominalLatency:               u32;
    MaximumPeriodicAccessRate:    u32;
    MinimumRequestTurnaroundTime: u16;
}

///
/// Type 2 HW-Reduced Communications Subspace Structure
///
EFI_ACPI_6_0_PCCT_SUBSPACE_2_HW_REDUCED_COMMUNICATIONS :: struct {
    Type:                         u8;
    Length:                       u8;
    DoorbellInterrupt:            u32 #align 2;
    DoorbellInterruptFlags:       u8;
    Reserved:                     u8;
    BaseAddress:                  u64;
    AddressLength:                u64;
    DoorbellRegister:             EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE;
    DoorbellPreserve:             u64 #align 4;
    DoorbellWrite:                u64 #align 4;
    NominalLatency:               u32;
    MaximumPeriodicAccessRate:    u32;
    MinimumRequestTurnaroundTime: u16;
    DoorbellAckRegister:          EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE #align 6;
    DoorbellAckPreserve:          u64 #align 2;
    DoorbellAckWrite:             u64 #align 2;
}

/**
This protocol can be used on any device handle to obtain generic path/location
information concerning the physical device or logical device. If the handle does
not logically map to a physical device, the handle may not necessarily support
the device path protocol. The device path describes the location of the device
the handle is for. The size of the Device Path can be determined from the structures
that make up the Device Path.
**/
EFI_DEVICE_PATH_PROTOCOL :: struct {
    ///< 0x01 Hardware Device Path.
    ///< 0x02 ACPI Device Path.
    ///< 0x03 Messaging Device Path.
    ///< 0x04 Media Device Path.
    ///< 0x05 BIOS Boot Specification Device Path.
    ///< 0x7F End of Hardware Device Path.
    Type:    u8;

    ///< Varies by Type
    ///< 0xFF End Entire Device Path, or
    ///< 0x01 End This Instance of a Device Path and start a new
    ///< Device Path.
    SubType: u8;

    ///< Specific Device Path data. Type and Sub-Type define
    ///< type of data. Size of data is included in Length.
    Length:  [2] u8;
}

///
/// Device Path protocol definition for backward-compatible with EFI1.1.
///
EFI_DEVICE_PATH :: EFI_DEVICE_PATH_PROTOCOL;

///
/// PCI Device Path.
///
PCI_DEVICE_PATH :: struct {
    Header:   EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// PCI Function Number.
    ///
    Function: u8;

    ///
    /// PCI Device Number.
    ///
    Device:   u8;
}

///
/// PCCARD Device Path.
///
PCCARD_DEVICE_PATH :: struct {
    Header:         EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Function Number (0 = First Function).
    ///
    FunctionNumber: u8;
}

///
/// Memory Mapped Device Path.
///
MEMMAP_DEVICE_PATH :: struct {
    Header:          EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// EFI_MEMORY_TYPE
    ///
    MemoryType:      u32;

    ///
    /// Starting Memory Address.
    ///
    StartingAddress: EFI_PHYSICAL_ADDRESS;

    ///
    /// Ending Memory Address.
    ///
    EndingAddress:   EFI_PHYSICAL_ADDRESS;
}

///
/// The Vendor Device Path allows the creation of vendor-defined Device Paths. A vendor must
/// allocate a Vendor GUID for a Device Path. The Vendor GUID can then be used to define the
/// contents on the n bytes that follow in the Vendor Device Path node.
///
VENDOR_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Vendor-assigned GUID that defines the data that follows.
    ///
    Guid:   EFI_GUID;
}

///
/// Controller Device Path.
///
CONTROLLER_DEVICE_PATH :: struct {
    Header:           EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Controller number.
    ///
    ControllerNumber: u32;
}

///
/// BMC Device Path.
///
BMC_DEVICE_PATH :: struct {
    Header:        EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Interface Type.
    ///
    InterfaceType: u8;

    ///
    /// Base Address.
    ///
    BaseAddress:   [8] u8;
}

ACPI_HID_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Device's PnP hardware ID stored in a numeric 32-bit
    /// compressed EISA-type ID. This value must match the
    /// corresponding _HID in the ACPI name space.
    ///
    HID:    u32;

    ///
    /// Unique ID that is required by ACPI if two devices have the
    /// same _HID. This value must also match the corresponding
    /// _UID/_HID pair in the ACPI name space. Only the 32-bit
    /// numeric value type of _UID is supported. Thus, strings must
    /// not be used for the _UID in the ACPI name space.
    ///
    UID:    u32;
}

ACPI_EXTENDED_HID_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Device's PnP hardware ID stored in a numeric 32-bit
    /// compressed EISA-type ID. This value must match the
    /// corresponding _HID in the ACPI name space.
    ///
    HID:    u32;

    ///
    /// Unique ID that is required by ACPI if two devices have the
    /// same _HID. This value must also match the corresponding
    /// _UID/_HID pair in the ACPI name space.
    ///
    UID:    u32;

    ///
    /// Device's compatible PnP hardware ID stored in a numeric
    /// 32-bit compressed EISA-type ID. This value must match at
    /// least one of the compatible device IDs returned by the
    /// corresponding _CID in the ACPI name space.
    ///
    CID:    u32;
}

///
/// The _ADR device path is used to contain video output device attributes to support the Graphics
/// Output Protocol. The device path can contain multiple _ADR entries if multiple video output
/// devices are displaying the same output.
///
ACPI_ADR_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// _ADR value. For video output devices the value of this
    /// field comes from Table B-2 of the ACPI 3.0 specification. At
    /// least one _ADR value is required.
    ///
    ADR:    u32;
}

ATAPI_DEVICE_PATH :: struct {
    Header:           EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Set to zero for primary, or one for secondary.
    ///
    PrimarySecondary: u8;

    ///
    /// Set to zero for master, or one for slave mode.
    ///
    SlaveMaster:      u8;

    ///
    /// Logical Unit Number.
    ///
    Lun:              u16;
}

SCSI_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Target ID on the SCSI bus (PUN).
    ///
    Pun:    u16;

    ///
    /// Logical Unit Number (LUN).
    ///
    Lun:    u16;
}

FIBRECHANNEL_DEVICE_PATH :: struct {
    Header:   EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Reserved for the future.
    ///
    Reserved: u32;

    ///
    /// Fibre Channel World Wide Number.
    ///
    WWN:      u64;

    ///
    /// Fibre Channel Logical Unit Number.
    ///
    Lun:      u64;
}

FIBRECHANNELEX_DEVICE_PATH :: struct {
    Header:   EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Reserved for the future.
    ///
    Reserved: u32;

    ///
    /// 8 byte array containing Fibre Channel End Device Port Name.
    ///
    WWN:      [8] u8;

    ///
    /// 8 byte array containing Fibre Channel Logical Unit Number.
    ///
    Lun:      [8] u8;
}

F1394_DEVICE_PATH :: struct {
    Header:   EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Reserved for the future.
    ///
    Reserved: u32;

    ///
    /// 1394 Global Unique ID (GUID).
    ///
    Guid:     u64;
}

USB_DEVICE_PATH :: struct {
    Header:           EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// USB Parent Port Number.
    ///
    ParentPortNumber: u8;

    ///
    /// USB Interface Number.
    ///
    InterfaceNumber:  u8;
}

USB_CLASS_DEVICE_PATH :: struct {
    Header:         EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Vendor ID assigned by USB-IF. A value of 0xFFFF will
    /// match any Vendor ID.
    ///
    VendorId:       u16;

    ///
    /// Product ID assigned by USB-IF. A value of 0xFFFF will
    /// match any Product ID.
    ///
    ProductId:      u16;

    ///
    /// The class code assigned by the USB-IF. A value of 0xFF
    /// will match any class code.
    ///
    DeviceClass:    u8;

    ///
    /// The subclass code assigned by the USB-IF. A value of
    /// 0xFF will match any subclass code.
    ///
    DeviceSubClass: u8;

    ///
    /// The protocol code assigned by the USB-IF. A value of
    /// 0xFF will match any protocol code.
    ///
    DeviceProtocol: u8;
}

///
/// This device path describes a USB device using its serial number.
///
USB_WWID_DEVICE_PATH :: struct {
    Header:          EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// USB interface number.
    ///
    InterfaceNumber: u16;

    ///
    /// USB vendor id of the device.
    ///
    VendorId:        u16;

    ///
    /// USB product id of the device.
    ///
    ProductId:       u16;
}

DEVICE_LOGICAL_UNIT_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Logical Unit Number for the interface.
    ///
    Lun:    u8;
}

SATA_DEVICE_PATH :: struct {
    Header:                   EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// The HBA port number that facilitates the connection to the
    /// device or a port multiplier. The value 0xFFFF is reserved.
    ///
    HBAPortNumber:            u16;

    ///
    /// The Port multiplier port number that facilitates the connection
    /// to the device. Must be set to 0xFFFF if the device is directly
    /// connected to the HBA.
    ///
    PortMultiplierPortNumber: u16;

    ///
    /// Logical Unit Number.
    ///
    Lun:                      u16;
}

I2O_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Target ID (TID) for a device.
    ///
    Tid:    u32;
}

MAC_ADDR_DEVICE_PATH :: struct {
    Header:     EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// The MAC address for a network interface padded with 0s.
    ///
    MacAddress: EFI_MAC_ADDRESS;

    ///
    /// Network interface type(i.e. 802.3, FDDI).
    ///
    IfType:     u8;
}

IPv4_DEVICE_PATH :: struct {
    Header:           EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// The local IPv4 address.
    ///
    LocalIpAddress:   EFI_IPv4_ADDRESS;

    ///
    /// The remote IPv4 address.
    ///
    RemoteIpAddress:  EFI_IPv4_ADDRESS;

    ///
    /// The local port number.
    ///
    LocalPort:        u16;

    ///
    /// The remote port number.
    ///
    RemotePort:       u16;

    ///
    /// The network protocol(i.e. UDP, TCP).
    ///
    Protocol:         u16;

    ///
    /// 0x00 - The Source IP Address was assigned though DHCP.
    /// 0x01 - The Source IP Address is statically bound.
    ///
    StaticIpAddress:  BOOLEAN;

    ///
    /// The gateway IP address
    ///
    GatewayIpAddress: EFI_IPv4_ADDRESS;

    ///
    /// The subnet mask
    ///
    SubnetMask:       EFI_IPv4_ADDRESS;
}

IPv6_DEVICE_PATH :: struct {
    Header:           EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// The local IPv6 address.
    ///
    LocalIpAddress:   EFI_IPv6_ADDRESS;

    ///
    /// The remote IPv6 address.
    ///
    RemoteIpAddress:  EFI_IPv6_ADDRESS;

    ///
    /// The local port number.
    ///
    LocalPort:        u16;

    ///
    /// The remote port number.
    ///
    RemotePort:       u16;

    ///
    /// The network protocol(i.e. UDP, TCP).
    ///
    Protocol:         u16;

    ///
    /// 0x00 - The Local IP Address was manually configured.
    /// 0x01 - The Local IP Address is assigned through IPv6
    /// stateless auto-configuration.
    /// 0x02 - The Local IP Address is assigned through IPv6
    /// stateful configuration.
    ///
    IpAddressOrigin:  u8;

    ///
    /// The prefix length
    ///
    PrefixLength:     u8;

    ///
    /// The gateway IP address
    ///
    GatewayIpAddress: EFI_IPv6_ADDRESS;
}

INFINIBAND_DEVICE_PATH :: struct {
    Header:        EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Flags to help identify/manage InfiniBand device path elements:
    /// Bit 0 - IOC/Service (0b = IOC, 1b = Service).
    /// Bit 1 - Extend Boot Environment.
    /// Bit 2 - Console Protocol.
    /// Bit 3 - Storage Protocol.
    /// Bit 4 - Network Protocol.
    /// All other bits are reserved.
    ///
    ResourceFlags: u32;

    ///
    /// 128-bit Global Identifier for remote fabric port.
    ///
    PortGid:       [16] u8;

    ///
    /// 64-bit unique identifier to remote IOC or server process.
    /// Interpretation of field specified by Resource Flags (bit 0).
    ///
    ServiceId:     u64;

    ///
    /// 64-bit persistent ID of remote IOC port.
    ///
    TargetPortId:  u64;

    ///
    /// 64-bit persistent ID of remote device.
    ///
    DeviceId:      u64;
}

UART_DEVICE_PATH :: struct {
    Header:   EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Reserved.
    ///
    Reserved: u32;

    ///
    /// The baud rate setting for the UART style device. A value of 0
    /// means that the device's default baud rate will be used.
    ///
    BaudRate: u64;

    ///
    /// The number of data bits for the UART style device. A value
    /// of 0 means that the device's default number of data bits will be used.
    ///
    DataBits: u8;

    ///
    /// The parity setting for the UART style device.
    /// Parity 0x00 - Default Parity.
    /// Parity 0x01 - No Parity.
    /// Parity 0x02 - Even Parity.
    /// Parity 0x03 - Odd Parity.
    /// Parity 0x04 - Mark Parity.
    /// Parity 0x05 - Space Parity.
    ///
    Parity:   u8;

    ///
    /// The number of stop bits for the UART style device.
    /// Stop Bits 0x00 - Default Stop Bits.
    /// Stop Bits 0x01 - 1 Stop Bit.
    /// Stop Bits 0x02 - 1.5 Stop Bits.
    /// Stop Bits 0x03 - 2 Stop Bits.
    ///
    StopBits: u8;
}

VENDOR_DEFINED_DEVICE_PATH :: VENDOR_DEVICE_PATH;

///
/// A new device path node is defined to declare flow control characteristics.
/// UART Flow Control Messaging Device Path
///
UART_FLOW_CONTROL_DEVICE_PATH :: struct {
    Header:         EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// DEVICE_PATH_MESSAGING_UART_FLOW_CONTROL GUID.
    ///
    Guid:           EFI_GUID;

    ///
    /// Bitmap of supported flow control types.
    /// Bit 0 set indicates hardware flow control.
    /// Bit 1 set indicates Xon/Xoff flow control.
    /// All other bits are reserved and are clear.
    ///
    FlowControlMap: u32;
}

///
/// Serial Attached SCSI (SAS) Device Path.
///
SAS_DEVICE_PATH :: struct {
    Header:             EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// DEVICE_PATH_MESSAGING_SAS GUID.
    ///
    Guid:               EFI_GUID;

    ///
    /// Reserved for future use.
    ///
    Reserved:           u32;

    ///
    /// SAS Address for Serial Attached SCSI Target.
    ///
    SasAddress:         u64;

    ///
    /// SAS Logical Unit Number.
    ///
    Lun:                u64;

    ///
    /// More Information about the device and its interconnect.
    ///
    DeviceTopology:     u16;

    ///
    /// Relative Target Port (RTP).
    ///
    RelativeTargetPort: u16;
}

SASEX_DEVICE_PATH :: struct {
    Header:             EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// 8-byte array of the SAS Address for Serial Attached SCSI Target Port.
    ///
    SasAddress:         [8] u8;

    ///
    /// 8-byte array of the SAS Logical Unit Number.
    ///
    Lun:                [8] u8;

    ///
    /// More Information about the device and its interconnect.
    ///
    DeviceTopology:     u16;

    ///
    /// Relative Target Port (RTP).
    ///
    RelativeTargetPort: u16;
}

NVME_NAMESPACE_DEVICE_PATH :: struct {
    Header:        EFI_DEVICE_PATH_PROTOCOL;
    NamespaceId:   u32;
    NamespaceUuid: u64;
}

DNS_DEVICE_PATH :: struct {
    Header:      EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Indicates the DNS server address is IPv4 or IPv6 address.
    ///
    IsIPv6:      u8;

//     ///
    /// Instance of the DNS server address.
    ///
    DnsServerIp: *EFI_IP_ADDRESS #align 1;// Incomplete array in C (zero-sized)
}

URI_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

//     ///
    /// Instance of the URI pursuant to RFC 3986.
    ///
    Uri:    *CHAR8;// Incomplete array in C (zero-sized)
}

UFS_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Target ID on the UFS bus (PUN).
    ///
    Pun:    u8;

    ///
    /// Logical Unit Number (LUN).
    ///
    Lun:    u8;
}

SD_DEVICE_PATH :: struct {
    Header:     EFI_DEVICE_PATH_PROTOCOL;
    SlotNumber: u8;
}

EMMC_DEVICE_PATH :: struct {
    Header:     EFI_DEVICE_PATH_PROTOCOL;
    SlotNumber: u8;
}

ISCSI_DEVICE_PATH :: struct {
    Header:               EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Network Protocol (0 = TCP, 1+ = reserved).
    ///
    NetworkProtocol:      u16;

    ///
    /// iSCSI Login Options.
    ///
    LoginOption:          u16;

    ///
    /// iSCSI Logical Unit Number.
    ///
    Lun:                  u64;

    ///
    /// iSCSI Target Portal group tag the initiator intends
    /// to establish a session with.
    ///
    TargetPortalGroupTag: u16;
}

VLAN_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// VLAN identifier (0-4094).
    ///
    VlanId: u16;
}

BLUETOOTH_DEVICE_PATH :: struct {
    Header:  EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// 48bit Bluetooth device address.
    ///
    BD_ADDR: BLUETOOTH_ADDRESS;
}

WIFI_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Service set identifier. A 32-byte octets string.
    ///
    SSId:   [32] u8;
}

BLUETOOTH_LE_DEVICE_PATH :: struct {
    Header:  EFI_DEVICE_PATH_PROTOCOL;
    Address: BLUETOOTH_LE_ADDRESS;
}

///
/// The Hard Drive Media Device Path is used to represent a partition on a hard drive.
///
HARDDRIVE_DEVICE_PATH :: struct {
    Header:          EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Describes the entry in a partition table, starting with entry 1.
    /// Partition number zero represents the entire device. Valid
    /// partition numbers for a MBR partition are [1, 4]. Valid
    /// partition numbers for a GPT partition are [1, NumberOfPartitionEntries].
    ///
    PartitionNumber: u32;

    ///
    /// Starting LBA of the partition on the hard drive.
    ///
    PartitionStart:  u64;

    ///
    /// Size of the partition in units of Logical Blocks.
    ///
    PartitionSize:   u64;

    ///
    /// Signature unique to this partition:
    /// If SignatureType is 0, this field has to be initialized with 16 zeros.
    /// If SignatureType is 1, the MBR signature is stored in the first 4 bytes of this field.
    /// The other 12 bytes are initialized with zeros.
    /// If SignatureType is 2, this field contains a 16 byte signature.
    ///
    Signature:       [16] u8;

    ///
    /// Partition Format: (Unused values reserved).
    /// 0x01 - PC-AT compatible legacy MBR.
    /// 0x02 - GUID Partition Table.
    ///
    MBRType:         u8;

    ///
    /// Type of Disk Signature: (Unused values reserved).
    /// 0x00 - No Disk Signature.
    /// 0x01 - 32-bit signature from address 0x1b8 of the type 0x01 MBR.
    /// 0x02 - GUID signature.
    ///
    SignatureType:   u8;
}

///
/// The CD-ROM Media Device Path is used to define a system partition that exists on a CD-ROM.
///
CDROM_DEVICE_PATH :: struct {
    Header:         EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Boot Entry number from the Boot Catalog. The Initial/Default entry is defined as zero.
    ///
    BootEntry:      u32;

    ///
    /// Starting RBA of the partition on the medium. CD-ROMs use Relative logical Block Addressing.
    ///
    PartitionStart: u64;

    ///
    /// Size of the partition in units of Blocks, also called Sectors.
    ///
    PartitionSize:  u64;
}

FILEPATH_DEVICE_PATH :: struct {
    Header:   EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// A NULL-terminated Path string including directory and file names.
    ///
    PathName: [1] CHAR16;
}

///
/// The Media Protocol Device Path is used to denote the protocol that is being
/// used in a device path at the location of the path specified.
/// Many protocols are inherent to the style of device path.
///
MEDIA_PROTOCOL_DEVICE_PATH :: struct {
    Header:   EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// The ID of the protocol.
    ///
    Protocol: EFI_GUID;
}

///
/// This device path is used by systems implementing the UEFI PI Specification 1.0 to describe a firmware file.
///
MEDIA_FW_VOL_FILEPATH_DEVICE_PATH :: struct {
    Header:     EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Firmware file name
    ///
    FvFileName: EFI_GUID;
}

///
/// This device path is used by systems implementing the UEFI PI Specification 1.0 to describe a firmware volume.
///
MEDIA_FW_VOL_DEVICE_PATH :: struct {
    Header: EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Firmware volume name.
    ///
    FvName: EFI_GUID;
}

///
/// Used to describe the offset range of media relative.
///
MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH :: struct {
    Header:         EFI_DEVICE_PATH_PROTOCOL;
    Reserved:       u32;
    StartingOffset: u64;
    EndingOffset:   u64;
}

///
/// Used to describe the ram disk device path.
///
MEDIA_RAM_DISK_DEVICE_PATH :: struct {
    Header:       EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Starting Memory Address.
    ///
    StartingAddr: [2] u32;

    ///
    /// Ending Memory Address.
    ///
    EndingAddr:   [2] u32;

    ///
    /// GUID that defines the type of the RAM Disk.
    ///
    TypeGuid:     EFI_GUID;

    ///
    /// RAM Diskinstance number, if supported. The default value is zero.
    ///
    Instance:     u16;
}

///
/// This Device Path is used to describe the booting of non-EFI-aware operating systems.
///
BBS_BBS_DEVICE_PATH :: struct {
    Header:     EFI_DEVICE_PATH_PROTOCOL;

    ///
    /// Device Type as defined by the BIOS Boot Specification.
    ///
    DeviceType: u16;

    ///
    /// Status Flags as defined by the BIOS Boot Specification.
    ///
    StatusFlag: u16;

    ///
    /// Null-terminated ASCII string that describes the boot device to a user.
    ///
    String:     [1] CHAR8;
}

///
/// Union of all possible Device Paths and pointers to Device Paths.
///
EFI_DEV_PATH :: union {
    DevPath:         EFI_DEVICE_PATH_PROTOCOL;
    Pci:             PCI_DEVICE_PATH;
    PcCard:          PCCARD_DEVICE_PATH;
    MemMap:          MEMMAP_DEVICE_PATH;
    Vendor:          VENDOR_DEVICE_PATH;

    Controller:      CONTROLLER_DEVICE_PATH;
    Bmc:             BMC_DEVICE_PATH;
    Acpi:            ACPI_HID_DEVICE_PATH;
    ExtendedAcpi:    ACPI_EXTENDED_HID_DEVICE_PATH;
    AcpiAdr:         ACPI_ADR_DEVICE_PATH;

    Atapi:           ATAPI_DEVICE_PATH;
    Scsi:            SCSI_DEVICE_PATH;
    Iscsi:           ISCSI_DEVICE_PATH;
    FibreChannel:    FIBRECHANNEL_DEVICE_PATH;
    FibreChannelEx:  FIBRECHANNELEX_DEVICE_PATH;

    F1394:           F1394_DEVICE_PATH;
    Usb:             USB_DEVICE_PATH;
    Sata:            SATA_DEVICE_PATH;
    UsbClass:        USB_CLASS_DEVICE_PATH;
    UsbWwid:         USB_WWID_DEVICE_PATH;
    LogicUnit:       DEVICE_LOGICAL_UNIT_DEVICE_PATH;
    I2O:             I2O_DEVICE_PATH;
    MacAddr:         MAC_ADDR_DEVICE_PATH;
    Ipv4:            IPv4_DEVICE_PATH;
    Ipv6:            IPv6_DEVICE_PATH;
    Vlan:            VLAN_DEVICE_PATH;
    InfiniBand:      INFINIBAND_DEVICE_PATH;
    Uart:            UART_DEVICE_PATH;
    UartFlowControl: UART_FLOW_CONTROL_DEVICE_PATH;
    Sas:             SAS_DEVICE_PATH;
    SasEx:           SASEX_DEVICE_PATH;
    NvmeNamespace:   NVME_NAMESPACE_DEVICE_PATH;
    Dns:             DNS_DEVICE_PATH;
    Uri:             URI_DEVICE_PATH;
    Bluetooth:       BLUETOOTH_DEVICE_PATH;
    WiFi:            WIFI_DEVICE_PATH;
    Ufs:             UFS_DEVICE_PATH;
    Sd:              SD_DEVICE_PATH;
    Emmc:            EMMC_DEVICE_PATH;
    HardDrive:       HARDDRIVE_DEVICE_PATH;
    CD:              CDROM_DEVICE_PATH;

    FilePath:        FILEPATH_DEVICE_PATH;
    MediaProtocol:   MEDIA_PROTOCOL_DEVICE_PATH;

    FirmwareVolume:  MEDIA_FW_VOL_DEVICE_PATH;
    FirmwareFile:    MEDIA_FW_VOL_FILEPATH_DEVICE_PATH;
    Offset:          MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH;
    RamDisk:         MEDIA_RAM_DISK_DEVICE_PATH;
    Bbs:             BBS_BBS_DEVICE_PATH;
}

EFI_DEV_PATH_PTR :: union {
    DevPath:         *EFI_DEVICE_PATH_PROTOCOL;
    Pci:             *PCI_DEVICE_PATH;
    PcCard:          *PCCARD_DEVICE_PATH;
    MemMap:          *MEMMAP_DEVICE_PATH;
    Vendor:          *VENDOR_DEVICE_PATH;

    Controller:      *CONTROLLER_DEVICE_PATH;
    Bmc:             *BMC_DEVICE_PATH;
    Acpi:            *ACPI_HID_DEVICE_PATH;
    ExtendedAcpi:    *ACPI_EXTENDED_HID_DEVICE_PATH;
    AcpiAdr:         *ACPI_ADR_DEVICE_PATH;

    Atapi:           *ATAPI_DEVICE_PATH;
    Scsi:            *SCSI_DEVICE_PATH;
    Iscsi:           *ISCSI_DEVICE_PATH;
    FibreChannel:    *FIBRECHANNEL_DEVICE_PATH;
    FibreChannelEx:  *FIBRECHANNELEX_DEVICE_PATH;

    F1394:           *F1394_DEVICE_PATH;
    Usb:             *USB_DEVICE_PATH;
    Sata:            *SATA_DEVICE_PATH;
    UsbClass:        *USB_CLASS_DEVICE_PATH;
    UsbWwid:         *USB_WWID_DEVICE_PATH;
    LogicUnit:       *DEVICE_LOGICAL_UNIT_DEVICE_PATH;
    I2O:             *I2O_DEVICE_PATH;
    MacAddr:         *MAC_ADDR_DEVICE_PATH;
    Ipv4:            *IPv4_DEVICE_PATH;
    Ipv6:            *IPv6_DEVICE_PATH;
    Vlan:            *VLAN_DEVICE_PATH;
    InfiniBand:      *INFINIBAND_DEVICE_PATH;
    Uart:            *UART_DEVICE_PATH;
    UartFlowControl: *UART_FLOW_CONTROL_DEVICE_PATH;
    Sas:             *SAS_DEVICE_PATH;
    SasEx:           *SASEX_DEVICE_PATH;
    NvmeNamespace:   *NVME_NAMESPACE_DEVICE_PATH;
    Dns:             *DNS_DEVICE_PATH;
    Uri:             *URI_DEVICE_PATH;
    Bluetooth:       *BLUETOOTH_DEVICE_PATH;
    WiFi:            *WIFI_DEVICE_PATH;
    Ufs:             *UFS_DEVICE_PATH;
    Sd:              *SD_DEVICE_PATH;
    Emmc:            *EMMC_DEVICE_PATH;
    HardDrive:       *HARDDRIVE_DEVICE_PATH;
    CD:              *CDROM_DEVICE_PATH;

    FilePath:        *FILEPATH_DEVICE_PATH;
    MediaProtocol:   *MEDIA_PROTOCOL_DEVICE_PATH;

    FirmwareVolume:  *MEDIA_FW_VOL_DEVICE_PATH;
    FirmwareFile:    *MEDIA_FW_VOL_FILEPATH_DEVICE_PATH;
    Offset:          *MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH;
    RamDisk:         *MEDIA_RAM_DISK_DEVICE_PATH;
    Bbs:             *BBS_BBS_DEVICE_PATH;
    Raw:             *u8;
}

EFI_SIMPLE_TEXT_INPUT_PROTOCOL :: _EFI_SIMPLE_TEXT_INPUT_PROTOCOL;

///
/// Protocol name in EFI1.1 for backward-compatible.
///
SIMPLE_INPUT_INTERFACE :: _EFI_SIMPLE_TEXT_INPUT_PROTOCOL;

///
/// The keystroke information for the key that was pressed.
///
EFI_INPUT_KEY :: struct {
    ScanCode:    u16;
    UnicodeChar: CHAR16;
}

/**
Reset the input device and optionally run diagnostics

@param  This                 Protocol instance pointer.
@param  ExtendedVerification Driver may perform diagnostics on reset.

@retval EFI_SUCCESS          The device was reset.
@retval EFI_DEVICE_ERROR     The device is not functioning properly and could not be reset.

**/
EFI_INPUT_RESET :: #type (This: *EFI_SIMPLE_TEXT_INPUT_PROTOCOL, ExtendedVerification: BOOLEAN) -> EFI_STATUS #c_call;

/**
Reads the next keystroke from the input device. The WaitForKey Event can
be used to test for existence of a keystroke via WaitForEvent () call.

@param  This  Protocol instance pointer.
@param  Key   A pointer to a buffer that is filled in with the keystroke
information for the key that was pressed.

@retval EFI_SUCCESS      The keystroke information was returned.
@retval EFI_NOT_READY    There was no keystroke data available.
@retval EFI_DEVICE_ERROR The keystroke information was not returned due to
hardware errors.

**/
EFI_INPUT_READ_KEY :: #type (This: *EFI_SIMPLE_TEXT_INPUT_PROTOCOL, Key: *EFI_INPUT_KEY) -> EFI_STATUS #c_call;

///
/// The EFI_SIMPLE_TEXT_INPUT_PROTOCOL is used on the ConsoleIn device.
/// It is the minimum required protocol for ConsoleIn.
///
_EFI_SIMPLE_TEXT_INPUT_PROTOCOL :: struct {
    Reset:         EFI_INPUT_RESET;
    ReadKeyStroke: EFI_INPUT_READ_KEY;

    ///
    /// Event to use with WaitForEvent() to wait for a key to be available
    ///
    WaitForKey:    EFI_EVENT;
}

EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL :: _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL;

/**
The Reset() function resets the input device hardware. As part
of initialization process, the firmware/device will make a quick
but reasonable attempt to verify that the device is functioning.
If the ExtendedVerification flag is TRUE the firmware may take
an extended amount of time to verify the device is operating on
reset. Otherwise the reset operation is to occur as quickly as
possible. The hardware verification process is not defined by
this specification and is left up to the platform firmware or
driver to implement.

@param This                 A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.

@param ExtendedVerification Indicates that the driver may
perform a more exhaustive
verification operation of the
device during reset.


@retval EFI_SUCCESS       The device was reset.

@retval EFI_DEVICE_ERROR  The device is not functioning
correctly and could not be reset.

**/
EFI_INPUT_RESET_EX :: #type (This: *EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL, ExtendedVerification: BOOLEAN) -> EFI_STATUS #c_call;

///
/// EFI_KEY_TOGGLE_STATE. The toggle states are defined.
/// They are: EFI_TOGGLE_STATE_VALID, EFI_SCROLL_LOCK_ACTIVE
/// EFI_NUM_LOCK_ACTIVE, EFI_CAPS_LOCK_ACTIVE
///
EFI_KEY_TOGGLE_STATE :: u8;

_EFI_KEY_STATE :: struct {
    ///
    /// Reflects the currently pressed shift
    /// modifiers for the input device. The
    /// returned value is valid only if the high
    /// order bit has been set.
    ///
    KeyShiftState:  u32;

    ///
    /// Reflects the current internal state of
    /// various toggled attributes. The returned
    /// value is valid only if the high order
    /// bit has been set.
    ///
    KeyToggleState: EFI_KEY_TOGGLE_STATE;
}

EFI_KEY_STATE :: _EFI_KEY_STATE;

EFI_KEY_DATA :: struct {
    ///
    /// The EFI scan code and Unicode value returned from the input device.
    ///
    Key:      EFI_INPUT_KEY;

    ///
    /// The current state of various toggled attributes as well as input modifier values.
    ///
    KeyState: EFI_KEY_STATE;
}

/**
The function reads the next keystroke from the input device. If
there is no pending keystroke the function returns
EFI_NOT_READY. If there is a pending keystroke, then
KeyData.Key.ScanCode is the EFI scan code defined in Error!
Reference source not found. The KeyData.Key.UnicodeChar is the
actual printable character or is zero if the key does not
represent a printable character (control key, function key,
etc.). The KeyData.KeyState is shift state for the character
reflected in KeyData.Key.UnicodeChar or KeyData.Key.ScanCode .
When interpreting the data from this function, it should be
noted that if a class of printable characters that are
normally adjusted by shift modifiers (e.g. Shift Key + "f"
key) would be presented solely as a KeyData.Key.UnicodeChar
without the associated shift state. So in the previous example
of a Shift Key + "f" key being pressed, the only pertinent
data returned would be KeyData.Key.UnicodeChar with the value
of "F". This of course would not typically be the case for
non-printable characters such as the pressing of the Right
Shift Key + F10 key since the corresponding returned data
would be reflected both in the KeyData.KeyState.KeyShiftState
and KeyData.Key.ScanCode values. UEFI drivers which implement
the EFI_SIMPLE_TEXT_INPUT_EX protocol are required to return
KeyData.Key and KeyData.KeyState values. These drivers must
always return the most current state of
KeyData.KeyState.KeyShiftState and
KeyData.KeyState.KeyToggleState. It should also be noted that
certain input devices may not be able to produce shift or toggle
state information, and in those cases the high order bit in the
respective Toggle and Shift state fields should not be active.


@param This     A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.

@param KeyData  A pointer to a buffer that is filled in with
the keystroke state data for the key that was
pressed.


@retval EFI_SUCCESS      The keystroke information was returned.
@retval EFI_NOT_READY    There was no keystroke data available.
@retval EFI_DEVICE_ERROR The keystroke information was not returned due to
hardware errors.


**/
EFI_INPUT_READ_KEY_EX :: #type (This: *EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL, KeyData: *EFI_KEY_DATA) -> EFI_STATUS #c_call;

/**
The SetState() function allows the input device hardware to
have state settings adjusted.

@param This           A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.

@param KeyToggleState Pointer to the EFI_KEY_TOGGLE_STATE to
set the state for the input device.


@retval EFI_SUCCESS       The device state was set appropriately.

@retval EFI_DEVICE_ERROR  The device is not functioning
correctly and could not have the
setting adjusted.

@retval EFI_UNSUPPORTED   The device does not support the
ability to have its state set.

**/
EFI_SET_STATE :: #type (This: *EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL, KeyToggleState: *EFI_KEY_TOGGLE_STATE) -> EFI_STATUS #c_call;

///
/// The function will be called when the key sequence is typed specified by KeyData.
///
EFI_KEY_NOTIFY_FUNCTION :: #type (KeyData: *EFI_KEY_DATA) -> EFI_STATUS #c_call;

/**
The RegisterKeystrokeNotify() function registers a function
which will be called when a specified keystroke will occur.

@param This                     A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.

@param KeyData                  A pointer to a buffer that is filled in with
the keystroke information for the key that was
pressed. If KeyData.Key, KeyData.KeyState.KeyToggleState
and KeyData.KeyState.KeyShiftState are 0, then any incomplete
keystroke will trigger a notification of the KeyNotificationFunction.

@param KeyNotificationFunction  Points to the function to be called when the key sequence
is typed specified by KeyData. This notification function
should be called at <=TPL_CALLBACK.


@param NotifyHandle             Points to the unique handle assigned to
the registered notification.

@retval EFI_SUCCESS           Key notify was registered successfully.

@retval EFI_OUT_OF_RESOURCES  Unable to allocate necessary
data structures.

**/
EFI_REGISTER_KEYSTROKE_NOTIFY :: #type (This: *EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL, KeyData: *EFI_KEY_DATA, KeyNotificationFunction: EFI_KEY_NOTIFY_FUNCTION, NotifyHandle: **void) -> EFI_STATUS #c_call;

/**
The UnregisterKeystrokeNotify() function removes the
notification which was previously registered.

@param This               A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.

@param NotificationHandle The handle of the notification
function being unregistered.

@retval EFI_SUCCESS           Key notify was unregistered successfully.

@retval EFI_INVALID_PARAMETER The NotificationHandle is
invalid.

**/
EFI_UNREGISTER_KEYSTROKE_NOTIFY :: #type (This: *EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL, NotificationHandle: *void) -> EFI_STATUS #c_call;

///
/// The EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL is used on the ConsoleIn
/// device. It is an extension to the Simple Text Input protocol
/// which allows a variety of extended shift state information to be
/// returned.
///
_EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL :: struct {
    Reset:               EFI_INPUT_RESET_EX;
    ReadKeyStrokeEx:     EFI_INPUT_READ_KEY_EX;

    ///
    /// Event to use with WaitForEvent() to wait for a key to be available.
    ///
    WaitForKeyEx:        EFI_EVENT;
    SetState:            EFI_SET_STATE;
    RegisterKeyNotify:   EFI_REGISTER_KEYSTROKE_NOTIFY;
    UnregisterKeyNotify: EFI_UNREGISTER_KEYSTROKE_NOTIFY;
}

EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL :: _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL;

///
/// Backward-compatible with EFI1.1.
///
SIMPLE_TEXT_OUTPUT_INTERFACE :: EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL;

/**
Reset the text output device hardware and optionaly run diagnostics

@param  This                 The protocol instance pointer.
@param  ExtendedVerification Driver may perform more exhaustive verification
operation of the device during reset.

@retval EFI_SUCCESS          The text output device was reset.
@retval EFI_DEVICE_ERROR     The text output device is not functioning correctly and
could not be reset.

**/
EFI_TEXT_RESET :: #type (This: *EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL, ExtendedVerification: BOOLEAN) -> EFI_STATUS #c_call;

/**
Write a string to the output device.

@param  This   The protocol instance pointer.
@param  String The NULL-terminated string to be displayed on the output
device(s). All output devices must also support the Unicode
drawing character codes defined in this file.

@retval EFI_SUCCESS             The string was output to the device.
@retval EFI_DEVICE_ERROR        The device reported an error while attempting to output
the text.
@retval EFI_UNSUPPORTED         The output device's mode is not currently in a
defined text mode.
@retval EFI_WARN_UNKNOWN_GLYPH  This warning code indicates that some of the
characters in the string could not be
rendered and were skipped.

**/
EFI_TEXT_STRING :: #type (This: *EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL, String: *CHAR16) -> EFI_STATUS #c_call;

/**
Verifies that all characters in a string can be output to the
target device.

@param  This   The protocol instance pointer.
@param  String The NULL-terminated string to be examined for the output
device(s).

@retval EFI_SUCCESS      The device(s) are capable of rendering the output string.
@retval EFI_UNSUPPORTED  Some of the characters in the string cannot be
rendered by one or more of the output devices mapped
by the EFI handle.

**/
EFI_TEXT_TEST_STRING :: #type (This: *EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL, String: *CHAR16) -> EFI_STATUS #c_call;

/**
Returns information for an available text mode that the output device(s)
supports.

@param  This       The protocol instance pointer.
@param  ModeNumber The mode number to return information on.
@param  Columns    Returns the geometry of the text output device for the
requested ModeNumber.
@param  Rows       Returns the geometry of the text output device for the
requested ModeNumber.

@retval EFI_SUCCESS      The requested mode information was returned.
@retval EFI_DEVICE_ERROR The device had an error and could not complete the request.
@retval EFI_UNSUPPORTED  The mode number was not valid.

**/
EFI_TEXT_QUERY_MODE :: #type (This: *EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL, ModeNumber: UINTN, Columns: *UINTN, Rows: *UINTN) -> EFI_STATUS #c_call;

/**
Sets the output device(s) to a specified mode.

@param  This       The protocol instance pointer.
@param  ModeNumber The mode number to set.

@retval EFI_SUCCESS      The requested text mode was set.
@retval EFI_DEVICE_ERROR The device had an error and could not complete the request.
@retval EFI_UNSUPPORTED  The mode number was not valid.

**/
EFI_TEXT_SET_MODE :: #type (This: *EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL, ModeNumber: UINTN) -> EFI_STATUS #c_call;

/**
Sets the background and foreground colors for the OutputString () and
ClearScreen () functions.

@param  This      The protocol instance pointer.
@param  Attribute The attribute to set. Bits 0..3 are the foreground color, and
bits 4..6 are the background color. All other bits are undefined
and must be zero. The valid Attributes are defined in this file.

@retval EFI_SUCCESS       The attribute was set.
@retval EFI_DEVICE_ERROR  The device had an error and could not complete the request.
@retval EFI_UNSUPPORTED   The attribute requested is not defined.

**/
EFI_TEXT_SET_ATTRIBUTE :: #type (This: *EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL, Attribute: UINTN) -> EFI_STATUS #c_call;

/**
Clears the output device(s) display to the currently selected background
color.

@param  This              The protocol instance pointer.

@retval  EFI_SUCCESS      The operation completed successfully.
@retval  EFI_DEVICE_ERROR The device had an error and could not complete the request.
@retval  EFI_UNSUPPORTED  The output device is not in a valid text mode.

**/
EFI_TEXT_CLEAR_SCREEN :: #type (This: *EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL) -> EFI_STATUS #c_call;

/**
Sets the current coordinates of the cursor position

@param  This        The protocol instance pointer.
@param  Column      The position to set the cursor to. Must be greater than or
equal to zero and less than the number of columns and rows
by QueryMode ().
@param  Row         The position to set the cursor to. Must be greater than or
equal to zero and less than the number of columns and rows
by QueryMode ().

@retval EFI_SUCCESS      The operation completed successfully.
@retval EFI_DEVICE_ERROR The device had an error and could not complete the request.
@retval EFI_UNSUPPORTED  The output device is not in a valid text mode, or the
cursor position is invalid for the current mode.

**/
EFI_TEXT_SET_CURSOR_POSITION :: #type (This: *EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL, Column: UINTN, Row: UINTN) -> EFI_STATUS #c_call;

/**
Makes the cursor visible or invisible

@param  This    The protocol instance pointer.
@param  Visible If TRUE, the cursor is set to be visible. If FALSE, the cursor is
set to be invisible.

@retval EFI_SUCCESS      The operation completed successfully.
@retval EFI_DEVICE_ERROR The device had an error and could not complete the
request, or the device does not support changing
the cursor mode.
@retval EFI_UNSUPPORTED  The output device is not in a valid text mode.

**/
EFI_TEXT_ENABLE_CURSOR :: #type (This: *EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL, Visible: BOOLEAN) -> EFI_STATUS #c_call;

/**
@par Data Structure Description:
Mode Structure pointed to by Simple Text Out protocol.
**/
EFI_SIMPLE_TEXT_OUTPUT_MODE :: struct {
    ///
    /// The number of modes supported by QueryMode () and SetMode ().
    ///
    MaxMode:       s32;

    ///
    /// The text mode of the output device(s).
    ///
    Mode:          s32;

    ///
    /// The current character output attribute.
    ///
    Attribute:     s32;

    ///
    /// The cursor's column.
    ///
    CursorColumn:  s32;

    ///
    /// The cursor's row.
    ///
    CursorRow:     s32;

    ///
    /// The cursor is currently visbile or not.
    ///
    CursorVisible: BOOLEAN;
}

///
/// The SIMPLE_TEXT_OUTPUT protocol is used to control text-based output devices.
/// It is the minimum required protocol for any handle supplied as the ConsoleOut
/// or StandardError device. In addition, the minimum supported text mode of such
/// devices is at least 80 x 25 characters.
///
_EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL :: struct {
    Reset:             EFI_TEXT_RESET;

    OutputString:      EFI_TEXT_STRING;
    TestString:        EFI_TEXT_TEST_STRING;

    QueryMode:         EFI_TEXT_QUERY_MODE;
    SetMode:           EFI_TEXT_SET_MODE;
    SetAttribute:      EFI_TEXT_SET_ATTRIBUTE;

    ClearScreen:       EFI_TEXT_CLEAR_SCREEN;
    SetCursorPosition: EFI_TEXT_SET_CURSOR_POSITION;
    EnableCursor:      EFI_TEXT_ENABLE_CURSOR;

    ///
    /// Pointer to SIMPLE_TEXT_OUTPUT_MODE data.
    ///
    Mode:              *EFI_SIMPLE_TEXT_OUTPUT_MODE;
}

///
/// Enumeration of EFI memory allocation types.
///
EFI_ALLOCATE_TYPE :: enum s32 {
    AllocateAnyPages   :: 0;

    AllocateMaxAddress :: 1;

    AllocateAddress    :: 2;

    MaxAllocateType    :: 3;
}

///
/// Definition of an EFI memory descriptor.
///
EFI_MEMORY_DESCRIPTOR :: struct {
    ///
    /// Type of the memory region.
    /// Type EFI_MEMORY_TYPE is defined in the
    /// AllocatePages() function description.
    ///
    Type:          u32;

    ///
    /// Physical address of the first byte in the memory region. PhysicalStart must be
    /// aligned on a 4 KiB boundary, and must not be above 0xfffffffffffff000. Type
    /// EFI_PHYSICAL_ADDRESS is defined in the AllocatePages() function description
    ///
    PhysicalStart: EFI_PHYSICAL_ADDRESS;

    ///
    /// Virtual address of the first byte in the memory region.
    /// VirtualStart must be aligned on a 4 KiB boundary,
    /// and must not be above 0xfffffffffffff000.
    ///
    VirtualStart:  EFI_VIRTUAL_ADDRESS;

    ///
    /// NumberOfPagesNumber of 4 KiB pages in the memory region.
    /// NumberOfPages must not be 0, and must not be any value
    /// that would represent a memory page with a start address,
    /// either physical or virtual, above 0xfffffffffffff000.
    ///
    NumberOfPages: u64;

    ///
    /// Attributes of the memory region that describe the bit mask of capabilities
    /// for that memory region, and not necessarily the current settings for that
    /// memory region.
    ///
    Attribute:     u64;
}

/**
Allocates memory pages from the system.

@param[in]       Type         The type of allocation to perform.
@param[in]       MemoryType   The type of memory to allocate.
MemoryType values in the range 0x70000000..0x7FFFFFFF
are reserved for OEM use. MemoryType values in the range
0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders
that are provided by operating system vendors.
@param[in]       Pages        The number of contiguous 4 KB pages to allocate.
@param[in, out]  Memory       The pointer to a physical address. On input, the way in which the address is
used depends on the value of Type.

@retval EFI_SUCCESS           The requested pages were allocated.
@retval EFI_INVALID_PARAMETER 1) Type is not AllocateAnyPages or
AllocateMaxAddress or AllocateAddress.
2) MemoryType is in the range
EfiMaxMemoryType..0x6FFFFFFF.
3) Memory is NULL.
4) MemoryType is EfiPersistentMemory.
@retval EFI_OUT_OF_RESOURCES  The pages could not be allocated.
@retval EFI_NOT_FOUND         The requested pages could not be found.

**/
EFI_ALLOCATE_PAGES :: #type (Type: EFI_ALLOCATE_TYPE, MemoryType: EFI_MEMORY_TYPE, Pages: UINTN, Memory: *EFI_PHYSICAL_ADDRESS) -> EFI_STATUS #c_call;

/**
Frees memory pages.

@param[in]  Memory      The base physical address of the pages to be freed.
@param[in]  Pages       The number of contiguous 4 KB pages to free.

@retval EFI_SUCCESS           The requested pages were freed.
@retval EFI_INVALID_PARAMETER Memory is not a page-aligned address or Pages is invalid.
@retval EFI_NOT_FOUND         The requested memory pages were not allocated with
AllocatePages().

**/
EFI_FREE_PAGES :: #type (Memory: EFI_PHYSICAL_ADDRESS, Pages: UINTN) -> EFI_STATUS #c_call;

/**
Returns the current memory map.

@param[in, out]  MemoryMapSize         A pointer to the size, in bytes, of the MemoryMap buffer.
On input, this is the size of the buffer allocated by the caller.
On output, it is the size of the buffer returned by the firmware if
the buffer was large enough, or the size of the buffer needed to contain
the map if the buffer was too small.
@param[in, out]  MemoryMap             A pointer to the buffer in which firmware places the current memory
map.
@param[out]      MapKey                A pointer to the location in which firmware returns the key for the
current memory map.
@param[out]      DescriptorSize        A pointer to the location in which firmware returns the size, in bytes, of
an individual EFI_MEMORY_DESCRIPTOR.
@param[out]      DescriptorVersion     A pointer to the location in which firmware returns the version number
associated with the EFI_MEMORY_DESCRIPTOR.

@retval EFI_SUCCESS           The memory map was returned in the MemoryMap buffer.
@retval EFI_BUFFER_TOO_SMALL  The MemoryMap buffer was too small. The current buffer size
needed to hold the memory map is returned in MemoryMapSize.
@retval EFI_INVALID_PARAMETER 1) MemoryMapSize is NULL.
2) The MemoryMap buffer is not too small and MemoryMap is
NULL.

**/
EFI_GET_MEMORY_MAP :: #type (MemoryMapSize: *UINTN, MemoryMap: *EFI_MEMORY_DESCRIPTOR, MapKey: *UINTN, DescriptorSize: *UINTN, DescriptorVersion: *u32) -> EFI_STATUS #c_call;

/**
Allocates pool memory.

@param[in]   PoolType         The type of pool to allocate.
MemoryType values in the range 0x70000000..0x7FFFFFFF
are reserved for OEM use. MemoryType values in the range
0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders
that are provided by operating system vendors.
@param[in]   Size             The number of bytes to allocate from the pool.
@param[out]  Buffer           A pointer to a pointer to the allocated buffer if the call succeeds;
undefined otherwise.

@retval EFI_SUCCESS           The requested number of bytes was allocated.
@retval EFI_OUT_OF_RESOURCES  The pool requested could not be allocated.
@retval EFI_INVALID_PARAMETER Buffer is NULL.
PoolType is in the range EfiMaxMemoryType..0x6FFFFFFF.
PoolType is EfiPersistentMemory.

**/
EFI_ALLOCATE_POOL :: #type (PoolType: EFI_MEMORY_TYPE, Size: UINTN, Buffer: **void) -> EFI_STATUS #c_call;

/**
Returns pool memory to the system.

@param[in]  Buffer            The pointer to the buffer to free.

@retval EFI_SUCCESS           The memory was returned to the system.
@retval EFI_INVALID_PARAMETER Buffer was invalid.

**/
EFI_FREE_POOL :: #type (Buffer: *void) -> EFI_STATUS #c_call;

/**
Changes the runtime addressing mode of EFI firmware from physical to virtual.

@param[in]  MemoryMapSize     The size in bytes of VirtualMap.
@param[in]  DescriptorSize    The size in bytes of an entry in the VirtualMap.
@param[in]  DescriptorVersion The version of the structure entries in VirtualMap.
@param[in]  VirtualMap        An array of memory descriptors which contain new virtual
address mapping information for all runtime ranges.

@retval EFI_SUCCESS           The virtual address map has been applied.
@retval EFI_UNSUPPORTED       EFI firmware is not at runtime, or the EFI firmware is already in
virtual address mapped mode.
@retval EFI_INVALID_PARAMETER DescriptorSize or DescriptorVersion is invalid.
@retval EFI_NO_MAPPING        A virtual address was not supplied for a range in the memory
map that requires a mapping.
@retval EFI_NOT_FOUND         A virtual address was supplied for an address that is not found
in the memory map.

**/
EFI_SET_VIRTUAL_ADDRESS_MAP :: #type (MemoryMapSize: UINTN, DescriptorSize: UINTN, DescriptorVersion: u32, VirtualMap: *EFI_MEMORY_DESCRIPTOR) -> EFI_STATUS #c_call;

/**
Connects one or more drivers to a controller.

@param[in]  ControllerHandle      The handle of the controller to which driver(s) are to be connected.
@param[in]  DriverImageHandle     A pointer to an ordered list handles that support the
EFI_DRIVER_BINDING_PROTOCOL.
@param[in]  RemainingDevicePath   A pointer to the device path that specifies a child of the
controller specified by ControllerHandle.
@param[in]  Recursive             If TRUE, then ConnectController() is called recursively
until the entire tree of controllers below the controller specified
by ControllerHandle have been created. If FALSE, then
the tree of controllers is only expanded one level.

@retval EFI_SUCCESS           1) One or more drivers were connected to ControllerHandle.
2) No drivers were connected to ControllerHandle, but
RemainingDevicePath is not NULL, and it is an End Device
Path Node.
@retval EFI_INVALID_PARAMETER ControllerHandle is NULL.
@retval EFI_NOT_FOUND         1) There are no EFI_DRIVER_BINDING_PROTOCOL instances
present in the system.
2) No drivers were connected to ControllerHandle.
@retval EFI_SECURITY_VIOLATION
The user has no permission to start UEFI device drivers on the device path
associated with the ControllerHandle or specified by the RemainingDevicePath.
**/
EFI_CONNECT_CONTROLLER :: #type (ControllerHandle: EFI_HANDLE, DriverImageHandle: *EFI_HANDLE, RemainingDevicePath: *EFI_DEVICE_PATH_PROTOCOL, Recursive: BOOLEAN) -> EFI_STATUS #c_call;

/**
Disconnects one or more drivers from a controller.

@param[in]  ControllerHandle      The handle of the controller from which driver(s) are to be disconnected.
@param[in]  DriverImageHandle     The driver to disconnect from ControllerHandle.
If DriverImageHandle is NULL, then all the drivers currently managing
ControllerHandle are disconnected from ControllerHandle.
@param[in]  ChildHandle           The handle of the child to destroy.
If ChildHandle is NULL, then all the children of ControllerHandle are
destroyed before the drivers are disconnected from ControllerHandle.

@retval EFI_SUCCESS           1) One or more drivers were disconnected from the controller.
2) On entry, no drivers are managing ControllerHandle.
3) DriverImageHandle is not NULL, and on entry
DriverImageHandle is not managing ControllerHandle.
@retval EFI_INVALID_PARAMETER 1) ControllerHandle is NULL.
2) DriverImageHandle is not NULL, and it is not a valid EFI_HANDLE.
3) ChildHandle is not NULL, and it is not a valid EFI_HANDLE.
4) DriverImageHandle does not support the EFI_DRIVER_BINDING_PROTOCOL.
@retval EFI_OUT_OF_RESOURCES  There are not enough resources available to disconnect any drivers from
ControllerHandle.
@retval EFI_DEVICE_ERROR      The controller could not be disconnected because of a device error.

**/
EFI_DISCONNECT_CONTROLLER :: #type (ControllerHandle: EFI_HANDLE, DriverImageHandle: EFI_HANDLE, ChildHandle: EFI_HANDLE) -> EFI_STATUS #c_call;

/**
Determines the new virtual address that is to be used on subsequent memory accesses.

@param[in]       DebugDisposition  Supplies type information for the pointer being converted.
@param[in, out]  Address           A pointer to a pointer that is to be fixed to be the value needed
for the new virtual address mappings being applied.

@retval EFI_SUCCESS           The pointer pointed to by Address was modified.
@retval EFI_INVALID_PARAMETER 1) Address is NULL.
2) *Address is NULL and DebugDisposition does
not have the EFI_OPTIONAL_PTR bit set.
@retval EFI_NOT_FOUND         The pointer pointed to by Address was not found to be part
of the current memory map. This is normally fatal.

**/
EFI_CONVERT_POINTER :: #type (DebugDisposition: UINTN, Address: **void) -> EFI_STATUS #c_call;

/**
Invoke a notification event

@param[in]  Event                 Event whose notification function is being invoked.
@param[in]  Context               The pointer to the notification function's context,
which is implementation-dependent.

**/
EFI_EVENT_NOTIFY :: #type (Event: EFI_EVENT, Context: *void) -> void #c_call;

/**
Creates an event.

@param[in]   Type             The type of event to create and its mode and attributes.
@param[in]   NotifyTpl        The task priority level of event notifications, if needed.
@param[in]   NotifyFunction   The pointer to the event's notification function, if any.
@param[in]   NotifyContext    The pointer to the notification function's context; corresponds to parameter
Context in the notification function.
@param[out]  Event            The pointer to the newly created event if the call succeeds; undefined
otherwise.

@retval EFI_SUCCESS           The event structure was created.
@retval EFI_INVALID_PARAMETER One or more parameters are invalid.
@retval EFI_OUT_OF_RESOURCES  The event could not be allocated.

**/
EFI_CREATE_EVENT :: #type (Type: u32, NotifyTpl: EFI_TPL, NotifyFunction: EFI_EVENT_NOTIFY, NotifyContext: *void, Event: *EFI_EVENT) -> EFI_STATUS #c_call;

/**
Creates an event in a group.

@param[in]   Type             The type of event to create and its mode and attributes.
@param[in]   NotifyTpl        The task priority level of event notifications,if needed.
@param[in]   NotifyFunction   The pointer to the event's notification function, if any.
@param[in]   NotifyContext    The pointer to the notification function's context; corresponds to parameter
Context in the notification function.
@param[in]   EventGroup       The pointer to the unique identifier of the group to which this event belongs.
If this is NULL, then the function behaves as if the parameters were passed
to CreateEvent.
@param[out]  Event            The pointer to the newly created event if the call succeeds; undefined
otherwise.

@retval EFI_SUCCESS           The event structure was created.
@retval EFI_INVALID_PARAMETER One or more parameters are invalid.
@retval EFI_OUT_OF_RESOURCES  The event could not be allocated.

**/
EFI_CREATE_EVENT_EX :: #type (Type: u32, NotifyTpl: EFI_TPL, NotifyFunction: EFI_EVENT_NOTIFY, NotifyContext: *void, EventGroup: *EFI_GUID, Event: *EFI_EVENT) -> EFI_STATUS #c_call;

///
/// Timer delay types
///
EFI_TIMER_DELAY :: enum s32 {
    Cancel   :: 0;

    Periodic :: 1;

    Relative :: 2;

    TimerCancel   :: Cancel;

    TimerPeriodic :: Periodic;

    TimerRelative :: Relative;
}

/**
Sets the type of timer and the trigger time for a timer event.

@param[in]  Event             The timer event that is to be signaled at the specified time.
@param[in]  Type              The type of time that is specified in TriggerTime.
@param[in]  TriggerTime       The number of 100ns units until the timer expires.
A TriggerTime of 0 is legal.
If Type is TimerRelative and TriggerTime is 0, then the timer
event will be signaled on the next timer tick.
If Type is TimerPeriodic and TriggerTime is 0, then the timer
event will be signaled on every timer tick.

@retval EFI_SUCCESS           The event has been set to be signaled at the requested time.
@retval EFI_INVALID_PARAMETER Event or Type is not valid.

**/
EFI_SET_TIMER :: #type (Event: EFI_EVENT, Type: EFI_TIMER_DELAY, TriggerTime: u64) -> EFI_STATUS #c_call;

/**
Signals an event.

@param[in]  Event             The event to signal.

@retval EFI_SUCCESS           The event has been signaled.

**/
EFI_SIGNAL_EVENT :: #type (Event: EFI_EVENT) -> EFI_STATUS #c_call;

/**
Stops execution until an event is signaled.

@param[in]   NumberOfEvents   The number of events in the Event array.
@param[in]   Event            An array of EFI_EVENT.
@param[out]  Index            The pointer to the index of the event which satisfied the wait condition.

@retval EFI_SUCCESS           The event indicated by Index was signaled.
@retval EFI_INVALID_PARAMETER 1) NumberOfEvents is 0.
2) The event indicated by Index is of type
EVT_NOTIFY_SIGNAL.
@retval EFI_UNSUPPORTED       The current TPL is not TPL_APPLICATION.

**/
EFI_WAIT_FOR_EVENT :: #type (NumberOfEvents: UINTN, Event: *EFI_EVENT, Index: *UINTN) -> EFI_STATUS #c_call;

/**
Closes an event.

@param[in]  Event             The event to close.

@retval EFI_SUCCESS           The event has been closed.

**/
EFI_CLOSE_EVENT :: #type (Event: EFI_EVENT) -> EFI_STATUS #c_call;

/**
Checks whether an event is in the signaled state.

@param[in]  Event             The event to check.

@retval EFI_SUCCESS           The event is in the signaled state.
@retval EFI_NOT_READY         The event is not in the signaled state.
@retval EFI_INVALID_PARAMETER Event is of type EVT_NOTIFY_SIGNAL.

**/
EFI_CHECK_EVENT :: #type (Event: EFI_EVENT) -> EFI_STATUS #c_call;

/**
Raises a task's priority level and returns its previous level.

@param[in]  NewTpl          The new task priority level.

@return Previous task priority level

**/
EFI_RAISE_TPL :: #type (NewTpl: EFI_TPL) -> EFI_TPL #c_call;

/**
Restores a task's priority level to its previous value.

@param[in]  OldTpl          The previous task priority level to restore.

**/
EFI_RESTORE_TPL :: #type (OldTpl: EFI_TPL) -> void #c_call;

/**
Returns the value of a variable.

@param[in]       VariableName  A Null-terminated string that is the name of the vendor's
variable.
@param[in]       VendorGuid    A unique identifier for the vendor.
@param[out]      Attributes    If not NULL, a pointer to the memory location to return the
attributes bitmask for the variable.
@param[in, out]  DataSize      On input, the size in bytes of the return Data buffer.
On output the size of data returned in Data.
@param[out]      Data          The buffer to return the contents of the variable. May be NULL
with a zero DataSize in order to determine the size buffer needed.

@retval EFI_SUCCESS            The function completed successfully.
@retval EFI_NOT_FOUND          The variable was not found.
@retval EFI_BUFFER_TOO_SMALL   The DataSize is too small for the result.
@retval EFI_INVALID_PARAMETER  VariableName is NULL.
@retval EFI_INVALID_PARAMETER  VendorGuid is NULL.
@retval EFI_INVALID_PARAMETER  DataSize is NULL.
@retval EFI_INVALID_PARAMETER  The DataSize is not too small and Data is NULL.
@retval EFI_DEVICE_ERROR       The variable could not be retrieved due to a hardware error.
@retval EFI_SECURITY_VIOLATION The variable could not be retrieved due to an authentication failure.

**/
EFI_GET_VARIABLE :: #type (VariableName: *CHAR16, VendorGuid: *EFI_GUID, Attributes: *u32, DataSize: *UINTN, Data: *void) -> EFI_STATUS #c_call;

/**
Enumerates the current variable names.

@param[in, out]  VariableNameSize The size of the VariableName buffer. The size must be large
enough to fit input string supplied in VariableName buffer.
@param[in, out]  VariableName     On input, supplies the last VariableName that was returned
by GetNextVariableName(). On output, returns the Nullterminated
string of the current variable.
@param[in, out]  VendorGuid       On input, supplies the last VendorGuid that was returned by
GetNextVariableName(). On output, returns the
VendorGuid of the current variable.

@retval EFI_SUCCESS           The function completed successfully.
@retval EFI_NOT_FOUND         The next variable was not found.
@retval EFI_BUFFER_TOO_SMALL  The VariableNameSize is too small for the result.
VariableNameSize has been updated with the size needed to complete the request.
@retval EFI_INVALID_PARAMETER VariableNameSize is NULL.
@retval EFI_INVALID_PARAMETER VariableName is NULL.
@retval EFI_INVALID_PARAMETER VendorGuid is NULL.
@retval EFI_INVALID_PARAMETER The input values of VariableName and VendorGuid are not a name and
GUID of an existing variable.
@retval EFI_INVALID_PARAMETER Null-terminator is not found in the first VariableNameSize bytes of
the input VariableName buffer.
@retval EFI_DEVICE_ERROR      The variable could not be retrieved due to a hardware error.

**/
EFI_GET_NEXT_VARIABLE_NAME :: #type (VariableNameSize: *UINTN, VariableName: *CHAR16, VendorGuid: *EFI_GUID) -> EFI_STATUS #c_call;

/**
Sets the value of a variable.

@param[in]  VariableName       A Null-terminated string that is the name of the vendor's variable.
Each VariableName is unique for each VendorGuid. VariableName must
contain 1 or more characters. If VariableName is an empty string,
then EFI_INVALID_PARAMETER is returned.
@param[in]  VendorGuid         A unique identifier for the vendor.
@param[in]  Attributes         Attributes bitmask to set for the variable.
@param[in]  DataSize           The size in bytes of the Data buffer. Unless the EFI_VARIABLE_APPEND_WRITE or
EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS attribute is set, a size of zero
causes the variable to be deleted. When the EFI_VARIABLE_APPEND_WRITE attribute is
set, then a SetVariable() call with a DataSize of zero will not cause any change to
the variable value (the timestamp associated with the variable may be updated however
even if no new data value is provided,see the description of the
EFI_VARIABLE_AUTHENTICATION_2 descriptor below. In this case the DataSize will not
be zero since the EFI_VARIABLE_AUTHENTICATION_2 descriptor will be populated).
@param[in]  Data               The contents for the variable.

@retval EFI_SUCCESS            The firmware has successfully stored the variable and its data as
defined by the Attributes.
@retval EFI_INVALID_PARAMETER  An invalid combination of attribute bits, name, and GUID was supplied, or the
DataSize exceeds the maximum allowed.
@retval EFI_INVALID_PARAMETER  VariableName is an empty string.
@retval EFI_OUT_OF_RESOURCES   Not enough storage is available to hold the variable and its data.
@retval EFI_DEVICE_ERROR       The variable could not be retrieved due to a hardware error.
@retval EFI_WRITE_PROTECTED    The variable in question is read-only.
@retval EFI_WRITE_PROTECTED    The variable in question cannot be deleted.
@retval EFI_SECURITY_VIOLATION The variable could not be written due to EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACESS being set,
but the AuthInfo does NOT pass the validation check carried out by the firmware.

@retval EFI_NOT_FOUND          The variable trying to be updated or deleted was not found.

**/
EFI_SET_VARIABLE :: #type (VariableName: *CHAR16, VendorGuid: *EFI_GUID, Attributes: u32, DataSize: UINTN, Data: *void) -> EFI_STATUS #c_call;

///
/// This provides the capabilities of the
/// real time clock device as exposed through the EFI interfaces.
///
EFI_TIME_CAPABILITIES :: struct {
    ///
    /// Provides the reporting resolution of the real-time clock device in
    /// counts per second. For a normal PC-AT CMOS RTC device, this
    /// value would be 1 Hz, or 1, to indicate that the device only reports
    /// the time to the resolution of 1 second.
    ///
    Resolution: u32;

    ///
    /// Provides the timekeeping accuracy of the real-time clock in an
    /// error rate of 1E-6 parts per million. For a clock with an accuracy
    /// of 50 parts per million, the value in this field would be
    /// 50,000,000.
    ///
    Accuracy:   u32;

    ///
    /// A TRUE indicates that a time set operation clears the device's
    /// time below the Resolution reporting level. A FALSE
    /// indicates that the state below the Resolution level of the
    /// device is not cleared when the time is set. Normal PC-AT CMOS
    /// RTC devices set this value to FALSE.
    ///
    SetsToZero: BOOLEAN;
}

/**
Returns the current time and date information, and the time-keeping capabilities
of the hardware platform.

@param[out]  Time             A pointer to storage to receive a snapshot of the current time.
@param[out]  Capabilities     An optional pointer to a buffer to receive the real time clock
device's capabilities.

@retval EFI_SUCCESS           The operation completed successfully.
@retval EFI_INVALID_PARAMETER Time is NULL.
@retval EFI_DEVICE_ERROR      The time could not be retrieved due to hardware error.

**/
EFI_GET_TIME :: #type (Time: *EFI_TIME, Capabilities: *EFI_TIME_CAPABILITIES) -> EFI_STATUS #c_call;

/**
Sets the current local time and date information.

@param[in]  Time              A pointer to the current time.

@retval EFI_SUCCESS           The operation completed successfully.
@retval EFI_INVALID_PARAMETER A time field is out of range.
@retval EFI_DEVICE_ERROR      The time could not be set due due to hardware error.

**/
EFI_SET_TIME :: #type (Time: *EFI_TIME) -> EFI_STATUS #c_call;

/**
Returns the current wakeup alarm clock setting.

@param[out]  Enabled          Indicates if the alarm is currently enabled or disabled.
@param[out]  Pending          Indicates if the alarm signal is pending and requires acknowledgement.
@param[out]  Time             The current alarm setting.

@retval EFI_SUCCESS           The alarm settings were returned.
@retval EFI_INVALID_PARAMETER Enabled is NULL.
@retval EFI_INVALID_PARAMETER Pending is NULL.
@retval EFI_INVALID_PARAMETER Time is NULL.
@retval EFI_DEVICE_ERROR      The wakeup time could not be retrieved due to a hardware error.
@retval EFI_UNSUPPORTED       A wakeup timer is not supported on this platform.

**/
EFI_GET_WAKEUP_TIME :: #type (Enabled: *BOOLEAN, Pending: *BOOLEAN, Time: *EFI_TIME) -> EFI_STATUS #c_call;

/**
Sets the system wakeup alarm clock time.

@param[in]  Enable            Enable or disable the wakeup alarm.
@param[in]  Time              If Enable is TRUE, the time to set the wakeup alarm for.
If Enable is FALSE, then this parameter is optional, and may be NULL.

@retval EFI_SUCCESS           If Enable is TRUE, then the wakeup alarm was enabled. If
Enable is FALSE, then the wakeup alarm was disabled.
@retval EFI_INVALID_PARAMETER A time field is out of range.
@retval EFI_DEVICE_ERROR      The wakeup time could not be set due to a hardware error.
@retval EFI_UNSUPPORTED       A wakeup timer is not supported on this platform.

**/
EFI_SET_WAKEUP_TIME :: #type (Enable: BOOLEAN, Time: *EFI_TIME) -> EFI_STATUS #c_call;

/**
Loads an EFI image into memory.

@param[in]   BootPolicy        If TRUE, indicates that the request originates from the boot
manager, and that the boot manager is attempting to load
FilePath as a boot selection. Ignored if SourceBuffer is
not NULL.
@param[in]   ParentImageHandle The caller's image handle.
@param[in]   DevicePath        The DeviceHandle specific file path from which the image is
loaded.
@param[in]   SourceBuffer      If not NULL, a pointer to the memory location containing a copy
of the image to be loaded.
@param[in]   SourceSize        The size in bytes of SourceBuffer. Ignored if SourceBuffer is NULL.
@param[out]  ImageHandle       The pointer to the returned image handle that is created when the
image is successfully loaded.

@retval EFI_SUCCESS            Image was loaded into memory correctly.
@retval EFI_NOT_FOUND          Both SourceBuffer and DevicePath are NULL.
@retval EFI_INVALID_PARAMETER  One or more parametes are invalid.
@retval EFI_UNSUPPORTED        The image type is not supported.
@retval EFI_OUT_OF_RESOURCES   Image was not loaded due to insufficient resources.
@retval EFI_LOAD_ERROR         Image was not loaded because the image format was corrupt or not
understood.
@retval EFI_DEVICE_ERROR       Image was not loaded because the device returned a read error.
@retval EFI_ACCESS_DENIED      Image was not loaded because the platform policy prohibits the
image from being loaded. NULL is returned in *ImageHandle.
@retval EFI_SECURITY_VIOLATION Image was loaded and an ImageHandle was created with a
valid EFI_LOADED_IMAGE_PROTOCOL. However, the current
platform policy specifies that the image should not be started.
**/
EFI_IMAGE_LOAD :: #type (BootPolicy: BOOLEAN, ParentImageHandle: EFI_HANDLE, DevicePath: *EFI_DEVICE_PATH_PROTOCOL, SourceBuffer: *void, SourceSize: UINTN, ImageHandle: *EFI_HANDLE) -> EFI_STATUS #c_call;

/**
Transfers control to a loaded image's entry point.

@param[in]   ImageHandle       Handle of image to be started.
@param[out]  ExitDataSize      The pointer to the size, in bytes, of ExitData.
@param[out]  ExitData          The pointer to a pointer to a data buffer that includes a Null-terminated
string, optionally followed by additional binary data.

@retval EFI_INVALID_PARAMETER  ImageHandle is either an invalid image handle or the image
has already been initialized with StartImage.
@retval EFI_SECURITY_VIOLATION The current platform policy specifies that the image should not be started.
@return Exit code from image

**/
EFI_IMAGE_START :: #type (ImageHandle: EFI_HANDLE, ExitDataSize: *UINTN, ExitData: **CHAR16) -> EFI_STATUS #c_call;

/**
Terminates a loaded EFI image and returns control to boot services.

@param[in]  ImageHandle       Handle that identifies the image. This parameter is passed to the
image on entry.
@param[in]  ExitStatus        The image's exit code.
@param[in]  ExitDataSize      The size, in bytes, of ExitData. Ignored if ExitStatus is EFI_SUCCESS.
@param[in]  ExitData          The pointer to a data buffer that includes a Null-terminated string,
optionally followed by additional binary data. The string is a
description that the caller may use to further indicate the reason
for the image's exit. ExitData is only valid if ExitStatus
is something other than EFI_SUCCESS. The ExitData buffer
must be allocated by calling AllocatePool().

@retval EFI_SUCCESS           The image specified by ImageHandle was unloaded.
@retval EFI_INVALID_PARAMETER The image specified by ImageHandle has been loaded and
started with LoadImage() and StartImage(), but the
image is not the currently executing image.

**/
EFI_EXIT :: #type (ImageHandle: EFI_HANDLE, ExitStatus: EFI_STATUS, ExitDataSize: UINTN, ExitData: *CHAR16) -> EFI_STATUS #c_call;

/**
Unloads an image.

@param[in]  ImageHandle       Handle that identifies the image to be unloaded.

@retval EFI_SUCCESS           The image has been unloaded.
@retval EFI_INVALID_PARAMETER ImageHandle is not a valid image handle.

**/
EFI_IMAGE_UNLOAD :: #type (ImageHandle: EFI_HANDLE) -> EFI_STATUS #c_call;

/**
Terminates all boot services.

@param[in]  ImageHandle       Handle that identifies the exiting image.
@param[in]  MapKey            Key to the latest memory map.

@retval EFI_SUCCESS           Boot services have been terminated.
@retval EFI_INVALID_PARAMETER MapKey is incorrect.

**/
EFI_EXIT_BOOT_SERVICES :: #type (ImageHandle: EFI_HANDLE, MapKey: UINTN) -> EFI_STATUS #c_call;

/**
Induces a fine-grained stall.

@param[in]  Microseconds      The number of microseconds to stall execution.

@retval EFI_SUCCESS           Execution was stalled at least the requested number of
Microseconds.

**/
EFI_STALL :: #type (Microseconds: UINTN) -> EFI_STATUS #c_call;

/**
Sets the system's watchdog timer.

@param[in]  Timeout           The number of seconds to set the watchdog timer to.
@param[in]  WatchdogCode      The numeric code to log on a watchdog timer timeout event.
@param[in]  DataSize          The size, in bytes, of WatchdogData.
@param[in]  WatchdogData      A data buffer that includes a Null-terminated string, optionally
followed by additional binary data.

@retval EFI_SUCCESS           The timeout has been set.
@retval EFI_INVALID_PARAMETER The supplied WatchdogCode is invalid.
@retval EFI_UNSUPPORTED       The system does not have a watchdog timer.
@retval EFI_DEVICE_ERROR      The watchdog timer could not be programmed due to a hardware
error.

**/
EFI_SET_WATCHDOG_TIMER :: #type (Timeout: UINTN, WatchdogCode: u64, DataSize: UINTN, WatchdogData: *CHAR16) -> EFI_STATUS #c_call;

/**
Resets the entire platform.

@param[in]  ResetType         The type of reset to perform.
@param[in]  ResetStatus       The status code for the reset.
@param[in]  DataSize          The size, in bytes, of ResetData.
@param[in]  ResetData         For a ResetType of EfiResetCold, EfiResetWarm, or
EfiResetShutdown the data buffer starts with a Null-terminated
string, optionally followed by additional binary data.
The string is a description that the caller may use to further
indicate the reason for the system reset. ResetData is only
valid if ResetStatus is something other than EFI_SUCCESS
unless the ResetType is EfiResetPlatformSpecific
where a minimum amount of ResetData is always required.
For a ResetType of EfiResetPlatformSpecific the data buffer
also starts with a Null-terminated string that is followed
by an EFI_GUID that describes the specific type of reset to perform.
**/
EFI_RESET_SYSTEM :: #type (ResetType: EFI_RESET_TYPE, ResetStatus: EFI_STATUS, DataSize: UINTN, ResetData: *void) -> void #c_call;

/**
Returns a monotonically increasing count for the platform.

@param[out]  Count            The pointer to returned value.

@retval EFI_SUCCESS           The next monotonic count was returned.
@retval EFI_INVALID_PARAMETER Count is NULL.
@retval EFI_DEVICE_ERROR      The device is not functioning properly.

**/
EFI_GET_NEXT_MONOTONIC_COUNT :: #type (Count: *u64) -> EFI_STATUS #c_call;

/**
Returns the next high 32 bits of the platform's monotonic counter.

@param[out]  HighCount        The pointer to returned value.

@retval EFI_SUCCESS           The next high monotonic count was returned.
@retval EFI_INVALID_PARAMETER HighCount is NULL.
@retval EFI_DEVICE_ERROR      The device is not functioning properly.

**/
EFI_GET_NEXT_HIGH_MONO_COUNT :: #type (HighCount: *u32) -> EFI_STATUS #c_call;

/**
Computes and returns a 32-bit CRC for a data buffer.

@param[in]   Data             A pointer to the buffer on which the 32-bit CRC is to be computed.
@param[in]   DataSize         The number of bytes in the buffer Data.
@param[out]  Crc32            The 32-bit CRC that was computed for the data buffer specified by Data
and DataSize.

@retval EFI_SUCCESS           The 32-bit CRC was computed for the data buffer and returned in
Crc32.
@retval EFI_INVALID_PARAMETER Data is NULL.
@retval EFI_INVALID_PARAMETER Crc32 is NULL.
@retval EFI_INVALID_PARAMETER DataSize is 0.

**/
EFI_CALCULATE_CRC32 :: #type (Data: *void, DataSize: UINTN, Crc32: *u32) -> EFI_STATUS #c_call;

/**
Copies the contents of one buffer to another buffer.

@param[in]  Destination       The pointer to the destination buffer of the memory copy.
@param[in]  Source            The pointer to the source buffer of the memory copy.
@param[in]  Length            Number of bytes to copy from Source to Destination.

**/
EFI_COPY_MEM :: #type (Destination: *void, Source: *void, Length: UINTN) -> void #c_call;

/**
The SetMem() function fills a buffer with a specified value.

@param[in]  Buffer            The pointer to the buffer to fill.
@param[in]  Size              Number of bytes in Buffer to fill.
@param[in]  Value             Value to fill Buffer with.

**/
EFI_SET_MEM :: #type (Buffer: *void, Size: UINTN, Value: u8) -> void #c_call;

///
/// Enumeration of EFI Interface Types
///
EFI_INTERFACE_TYPE :: enum s32 {
    EFI_NATIVE_INTERFACE :: 0;
}

/**
Installs a protocol interface on a device handle. If the handle does not exist, it is created and added
to the list of handles in the system. InstallMultipleProtocolInterfaces() performs
more error checking than InstallProtocolInterface(), so it is recommended that
InstallMultipleProtocolInterfaces() be used in place of
InstallProtocolInterface()

@param[in, out]  Handle         A pointer to the EFI_HANDLE on which the interface is to be installed.
@param[in]       Protocol       The numeric ID of the protocol interface.
@param[in]       InterfaceType  Indicates whether Interface is supplied in native form.
@param[in]       Interface      A pointer to the protocol interface.

@retval EFI_SUCCESS           The protocol interface was installed.
@retval EFI_OUT_OF_RESOURCES  Space for a new handle could not be allocated.
@retval EFI_INVALID_PARAMETER Handle is NULL.
@retval EFI_INVALID_PARAMETER Protocol is NULL.
@retval EFI_INVALID_PARAMETER InterfaceType is not EFI_NATIVE_INTERFACE.
@retval EFI_INVALID_PARAMETER Protocol is already installed on the handle specified by Handle.

**/
EFI_INSTALL_PROTOCOL_INTERFACE :: #type (Handle: *EFI_HANDLE, Protocol: *EFI_GUID, InterfaceType: EFI_INTERFACE_TYPE, Interface: *void) -> EFI_STATUS #c_call;

/**
Installs one or more protocol interfaces into the boot services environment.

@param[in, out]  Handle       The pointer to a handle to install the new protocol interfaces on,
or a pointer to NULL if a new handle is to be allocated.
@param  ...                   A variable argument list containing pairs of protocol GUIDs and protocol
interfaces.

@retval EFI_SUCCESS           All the protocol interface was installed.
@retval EFI_OUT_OF_RESOURCES  There was not enough memory in pool to install all the protocols.
@retval EFI_ALREADY_STARTED   A Device Path Protocol instance was passed in that is already present in
the handle database.
@retval EFI_INVALID_PARAMETER Handle is NULL.
@retval EFI_INVALID_PARAMETER Protocol is already installed on the handle specified by Handle.

**/
EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES :: #type (Handle: *EFI_HANDLE, __args: ..Any) -> EFI_STATUS #c_call;

/**
Reinstalls a protocol interface on a device handle.

@param[in]  Handle            Handle on which the interface is to be reinstalled.
@param[in]  Protocol          The numeric ID of the interface.
@param[in]  OldInterface      A pointer to the old interface. NULL can be used if a structure is not
associated with Protocol.
@param[in]  NewInterface      A pointer to the new interface.

@retval EFI_SUCCESS           The protocol interface was reinstalled.
@retval EFI_NOT_FOUND         The OldInterface on the handle was not found.
@retval EFI_ACCESS_DENIED     The protocol interface could not be reinstalled,
because OldInterface is still being used by a
driver that will not release it.
@retval EFI_INVALID_PARAMETER Handle is NULL.
@retval EFI_INVALID_PARAMETER Protocol is NULL.

**/
EFI_REINSTALL_PROTOCOL_INTERFACE :: #type (Handle: EFI_HANDLE, Protocol: *EFI_GUID, OldInterface: *void, NewInterface: *void) -> EFI_STATUS #c_call;

/**
Removes a protocol interface from a device handle. It is recommended that
UninstallMultipleProtocolInterfaces() be used in place of
UninstallProtocolInterface().

@param[in]  Handle            The handle on which the interface was installed.
@param[in]  Protocol          The numeric ID of the interface.
@param[in]  Interface         A pointer to the interface.

@retval EFI_SUCCESS           The interface was removed.
@retval EFI_NOT_FOUND         The interface was not found.
@retval EFI_ACCESS_DENIED     The interface was not removed because the interface
is still being used by a driver.
@retval EFI_INVALID_PARAMETER Handle is NULL.
@retval EFI_INVALID_PARAMETER Protocol is NULL.

**/
EFI_UNINSTALL_PROTOCOL_INTERFACE :: #type (Handle: EFI_HANDLE, Protocol: *EFI_GUID, Interface: *void) -> EFI_STATUS #c_call;

/**
Removes one or more protocol interfaces into the boot services environment.

@param[in]  Handle            The handle to remove the protocol interfaces from.
@param  ...                   A variable argument list containing pairs of protocol GUIDs and
protocol interfaces.

@retval EFI_SUCCESS           All the protocol interfaces were removed.
@retval EFI_INVALID_PARAMETER One of the protocol interfaces was not previously installed on Handle.

**/
EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES :: #type (Handle: EFI_HANDLE, __args: ..Any) -> EFI_STATUS #c_call;

/**
Queries a handle to determine if it supports a specified protocol.

@param[in]   Handle           The handle being queried.
@param[in]   Protocol         The published unique identifier of the protocol.
@param[out]  Interface        Supplies the address where a pointer to the corresponding Protocol
Interface is returned.

@retval EFI_SUCCESS           The interface information for the specified protocol was returned.
@retval EFI_UNSUPPORTED       The device does not support the specified protocol.
@retval EFI_INVALID_PARAMETER Handle is NULL.
@retval EFI_INVALID_PARAMETER Protocol is NULL.
@retval EFI_INVALID_PARAMETER Interface is NULL.

**/
EFI_HANDLE_PROTOCOL :: #type (Handle: EFI_HANDLE, Protocol: *EFI_GUID, Interface: **void) -> EFI_STATUS #c_call;

/**
Queries a handle to determine if it supports a specified protocol. If the protocol is supported by the
handle, it opens the protocol on behalf of the calling agent.

@param[in]   Handle           The handle for the protocol interface that is being opened.
@param[in]   Protocol         The published unique identifier of the protocol.
@param[out]  Interface        Supplies the address where a pointer to the corresponding Protocol
Interface is returned.
@param[in]   AgentHandle      The handle of the agent that is opening the protocol interface
specified by Protocol and Interface.
@param[in]   ControllerHandle If the agent that is opening a protocol is a driver that follows the
UEFI Driver Model, then this parameter is the controller handle
that requires the protocol interface. If the agent does not follow
the UEFI Driver Model, then this parameter is optional and may
be NULL.
@param[in]   Attributes       The open mode of the protocol interface specified by Handle
and Protocol.

@retval EFI_SUCCESS           An item was added to the open list for the protocol interface, and the
protocol interface was returned in Interface.
@retval EFI_UNSUPPORTED       Handle does not support Protocol.
@retval EFI_INVALID_PARAMETER One or more parameters are invalid.
@retval EFI_ACCESS_DENIED     Required attributes can't be supported in current environment.
@retval EFI_ALREADY_STARTED   Item on the open list already has requierd attributes whose agent
handle is the same as AgentHandle.

**/
EFI_OPEN_PROTOCOL :: #type (Handle: EFI_HANDLE, Protocol: *EFI_GUID, Interface: **void, AgentHandle: EFI_HANDLE, ControllerHandle: EFI_HANDLE, Attributes: u32) -> EFI_STATUS #c_call;

/**
Closes a protocol on a handle that was opened using OpenProtocol().

@param[in]  Handle            The handle for the protocol interface that was previously opened
with OpenProtocol(), and is now being closed.
@param[in]  Protocol          The published unique identifier of the protocol.
@param[in]  AgentHandle       The handle of the agent that is closing the protocol interface.
@param[in]  ControllerHandle  If the agent that opened a protocol is a driver that follows the
UEFI Driver Model, then this parameter is the controller handle
that required the protocol interface.

@retval EFI_SUCCESS           The protocol instance was closed.
@retval EFI_INVALID_PARAMETER 1) Handle is NULL.
2) AgentHandle is NULL.
3) ControllerHandle is not NULL and ControllerHandle is not a valid EFI_HANDLE.
4) Protocol is NULL.
@retval EFI_NOT_FOUND         1) Handle does not support the protocol specified by Protocol.
2) The protocol interface specified by Handle and Protocol is not
currently open by AgentHandle and ControllerHandle.

**/
EFI_CLOSE_PROTOCOL :: #type (Handle: EFI_HANDLE, Protocol: *EFI_GUID, AgentHandle: EFI_HANDLE, ControllerHandle: EFI_HANDLE) -> EFI_STATUS #c_call;

///
/// EFI Oprn Protocol Information Entry
///
EFI_OPEN_PROTOCOL_INFORMATION_ENTRY :: struct {
    AgentHandle:      EFI_HANDLE;
    ControllerHandle: EFI_HANDLE;
    Attributes:       u32;
    OpenCount:        u32;
}

/**
Retrieves the list of agents that currently have a protocol interface opened.

@param[in]   Handle           The handle for the protocol interface that is being queried.
@param[in]   Protocol         The published unique identifier of the protocol.
@param[out]  EntryBuffer      A pointer to a buffer of open protocol information in the form of
EFI_OPEN_PROTOCOL_INFORMATION_ENTRY structures.
@param[out]  EntryCount       A pointer to the number of entries in EntryBuffer.

@retval EFI_SUCCESS           The open protocol information was returned in EntryBuffer, and the
number of entries was returned EntryCount.
@retval EFI_OUT_OF_RESOURCES  There are not enough resources available to allocate EntryBuffer.
@retval EFI_NOT_FOUND         Handle does not support the protocol specified by Protocol.

**/
EFI_OPEN_PROTOCOL_INFORMATION :: #type (Handle: EFI_HANDLE, Protocol: *EFI_GUID, EntryBuffer: **EFI_OPEN_PROTOCOL_INFORMATION_ENTRY, EntryCount: *UINTN) -> EFI_STATUS #c_call;

/**
Retrieves the list of protocol interface GUIDs that are installed on a handle in a buffer allocated
from pool.

@param[in]   Handle              The handle from which to retrieve the list of protocol interface
GUIDs.
@param[out]  ProtocolBuffer      A pointer to the list of protocol interface GUID pointers that are
installed on Handle.
@param[out]  ProtocolBufferCount A pointer to the number of GUID pointers present in
ProtocolBuffer.

@retval EFI_SUCCESS           The list of protocol interface GUIDs installed on Handle was returned in
ProtocolBuffer. The number of protocol interface GUIDs was
returned in ProtocolBufferCount.
@retval EFI_OUT_OF_RESOURCES  There is not enough pool memory to store the results.
@retval EFI_INVALID_PARAMETER Handle is NULL.
@retval EFI_INVALID_PARAMETER Handle is not a valid EFI_HANDLE.
@retval EFI_INVALID_PARAMETER ProtocolBuffer is NULL.
@retval EFI_INVALID_PARAMETER ProtocolBufferCount is NULL.

**/
EFI_PROTOCOLS_PER_HANDLE :: #type (Handle: EFI_HANDLE, ProtocolBuffer: ***EFI_GUID, ProtocolBufferCount: *UINTN) -> EFI_STATUS #c_call;

/**
Creates an event that is to be signaled whenever an interface is installed for a specified protocol.

@param[in]   Protocol         The numeric ID of the protocol for which the event is to be registered.
@param[in]   Event            Event that is to be signaled whenever a protocol interface is registered
for Protocol.
@param[out]  Registration     A pointer to a memory location to receive the registration value.

@retval EFI_SUCCESS           The notification event has been registered.
@retval EFI_OUT_OF_RESOURCES  Space for the notification event could not be allocated.
@retval EFI_INVALID_PARAMETER Protocol is NULL.
@retval EFI_INVALID_PARAMETER Event is NULL.
@retval EFI_INVALID_PARAMETER Registration is NULL.

**/
EFI_REGISTER_PROTOCOL_NOTIFY :: #type (Protocol: *EFI_GUID, Event: EFI_EVENT, Registration: **void) -> EFI_STATUS #c_call;

///
/// Enumeration of EFI Locate Search Types
///
EFI_LOCATE_SEARCH_TYPE :: enum s32 {
    AllHandles       :: 0;

    ByRegisterNotify :: 1;

    ByProtocol       :: 2;
}

/**
Returns an array of handles that support a specified protocol.

@param[in]       SearchType   Specifies which handle(s) are to be returned.
@param[in]       Protocol     Specifies the protocol to search by.
@param[in]       SearchKey    Specifies the search key.
@param[in, out]  BufferSize   On input, the size in bytes of Buffer. On output, the size in bytes of
the array returned in Buffer (if the buffer was large enough) or the
size, in bytes, of the buffer needed to obtain the array (if the buffer was
not large enough).
@param[out]      Buffer       The buffer in which the array is returned.

@retval EFI_SUCCESS           The array of handles was returned.
@retval EFI_NOT_FOUND         No handles match the search.
@retval EFI_BUFFER_TOO_SMALL  The BufferSize is too small for the result.
@retval EFI_INVALID_PARAMETER SearchType is not a member of EFI_LOCATE_SEARCH_TYPE.
@retval EFI_INVALID_PARAMETER SearchType is ByRegisterNotify and SearchKey is NULL.
@retval EFI_INVALID_PARAMETER SearchType is ByProtocol and Protocol is NULL.
@retval EFI_INVALID_PARAMETER One or more matches are found and BufferSize is NULL.
@retval EFI_INVALID_PARAMETER BufferSize is large enough for the result and Buffer is NULL.

**/
EFI_LOCATE_HANDLE :: #type (SearchType: EFI_LOCATE_SEARCH_TYPE, Protocol: *EFI_GUID, SearchKey: *void, BufferSize: *UINTN, Buffer: *EFI_HANDLE) -> EFI_STATUS #c_call;

/**
Locates the handle to a device on the device path that supports the specified protocol.

@param[in]       Protocol     Specifies the protocol to search for.
@param[in, out]  DevicePath   On input, a pointer to a pointer to the device path. On output, the device
path pointer is modified to point to the remaining part of the device
path.
@param[out]      Device       A pointer to the returned device handle.

@retval EFI_SUCCESS           The resulting handle was returned.
@retval EFI_NOT_FOUND         No handles match the search.
@retval EFI_INVALID_PARAMETER Protocol is NULL.
@retval EFI_INVALID_PARAMETER DevicePath is NULL.
@retval EFI_INVALID_PARAMETER A handle matched the search and Device is NULL.

**/
EFI_LOCATE_DEVICE_PATH :: #type (Protocol: *EFI_GUID, DevicePath: **EFI_DEVICE_PATH_PROTOCOL, Device: *EFI_HANDLE) -> EFI_STATUS #c_call;

/**
Adds, updates, or removes a configuration table entry from the EFI System Table.

@param[in]  Guid              A pointer to the GUID for the entry to add, update, or remove.
@param[in]  Table             A pointer to the configuration table for the entry to add, update, or
remove. May be NULL.

@retval EFI_SUCCESS           The (Guid, Table) pair was added, updated, or removed.
@retval EFI_NOT_FOUND         An attempt was made to delete a nonexistent entry.
@retval EFI_INVALID_PARAMETER Guid is NULL.
@retval EFI_OUT_OF_RESOURCES  There is not enough memory available to complete the operation.

**/
EFI_INSTALL_CONFIGURATION_TABLE :: #type (Guid: *EFI_GUID, Table: *void) -> EFI_STATUS #c_call;

/**
Returns an array of handles that support the requested protocol in a buffer allocated from pool.

@param[in]       SearchType   Specifies which handle(s) are to be returned.
@param[in]       Protocol     Provides the protocol to search by.
This parameter is only valid for a SearchType of ByProtocol.
@param[in]       SearchKey    Supplies the search key depending on the SearchType.
@param[in, out]  NoHandles    The number of handles returned in Buffer.
@param[out]      Buffer       A pointer to the buffer to return the requested array of handles that
support Protocol.

@retval EFI_SUCCESS           The array of handles was returned in Buffer, and the number of
handles in Buffer was returned in NoHandles.
@retval EFI_NOT_FOUND         No handles match the search.
@retval EFI_OUT_OF_RESOURCES  There is not enough pool memory to store the matching results.
@retval EFI_INVALID_PARAMETER NoHandles is NULL.
@retval EFI_INVALID_PARAMETER Buffer is NULL.

**/
EFI_LOCATE_HANDLE_BUFFER :: #type (SearchType: EFI_LOCATE_SEARCH_TYPE, Protocol: *EFI_GUID, SearchKey: *void, NoHandles: *UINTN, Buffer: **EFI_HANDLE) -> EFI_STATUS #c_call;

/**
Returns the first protocol instance that matches the given protocol.

@param[in]  Protocol          Provides the protocol to search for.
@param[in]  Registration      Optional registration key returned from
RegisterProtocolNotify().
@param[out]  Interface        On return, a pointer to the first interface that matches Protocol and
Registration.

@retval EFI_SUCCESS           A protocol instance matching Protocol was found and returned in
Interface.
@retval EFI_NOT_FOUND         No protocol instances were found that match Protocol and
Registration.
@retval EFI_INVALID_PARAMETER Interface is NULL.
Protocol is NULL.

**/
EFI_LOCATE_PROTOCOL :: #type (Protocol: *EFI_GUID, Registration: *void, Interface: **void) -> EFI_STATUS #c_call;

///
/// EFI Capsule Block Descriptor
///
EFI_CAPSULE_BLOCK_DESCRIPTOR :: struct {
    ///
    /// Length in bytes of the data pointed to by DataBlock/ContinuationPointer.
    ///
    Length: u64;
    Union:  union {
        ///
        /// Physical address of the data block. This member of the union is
        /// used if Length is not equal to zero.
        ///
        DataBlock:           EFI_PHYSICAL_ADDRESS;

        ///
        /// Physical address of another block of
        /// EFI_CAPSULE_BLOCK_DESCRIPTOR structures. This
        /// member of the union is used if Length is equal to zero. If
        /// ContinuationPointer is zero this entry represents the end of the list.
        ///
        ContinuationPointer: EFI_PHYSICAL_ADDRESS;
    };
}

///
/// EFI Capsule Header.
///
EFI_CAPSULE_HEADER :: struct {
    ///
    /// A GUID that defines the contents of a capsule.
    ///
    CapsuleGuid:      EFI_GUID;

    ///
    /// The size of the capsule header. This may be larger than the size of
    /// the EFI_CAPSULE_HEADER since CapsuleGuid may imply
    /// extended header entries
    ///
    HeaderSize:       u32;

    ///
    /// Bit-mapped list describing the capsule attributes. The Flag values
    /// of 0x0000 - 0xFFFF are defined by CapsuleGuid. Flag values
    /// of 0x10000 - 0xFFFFFFFF are defined by this specification
    ///
    Flags:            u32;

    ///
    /// Size in bytes of the capsule.
    ///
    CapsuleImageSize: u32;
}

///
/// The EFI System Table entry must point to an array of capsules
/// that contain the same CapsuleGuid value. The array must be
/// prefixed by a UINT32 that represents the size of the array of capsules.
///
EFI_CAPSULE_TABLE :: struct {
    ///
    /// the size of the array of capsules.
    ///
    CapsuleArrayNumber: u32;

    ///
    /// Point to an array of capsules that contain the same CapsuleGuid value.
    ///
    CapsulePtr:         [1] *void;
}

/**
Passes capsules to the firmware with both virtual and physical mapping. Depending on the intended
consumption, the firmware may process the capsule immediately. If the payload should persist
across a system reset, the reset value returned from EFI_QueryCapsuleCapabilities must
be passed into ResetSystem() and will cause the capsule to be processed by the firmware as
part of the reset process.

@param[in]  CapsuleHeaderArray Virtual pointer to an array of virtual pointers to the capsules
being passed into update capsule.
@param[in]  CapsuleCount       Number of pointers to EFI_CAPSULE_HEADER in
CaspuleHeaderArray.
@param[in]  ScatterGatherList  Physical pointer to a set of
EFI_CAPSULE_BLOCK_DESCRIPTOR that describes the
location in physical memory of a set of capsules.

@retval EFI_SUCCESS           Valid capsule was passed. If
CAPSULE_FLAGS_PERSIT_ACROSS_RESET is not set, the
capsule has been successfully processed by the firmware.
@retval EFI_INVALID_PARAMETER CapsuleSize is NULL, or an incompatible set of flags were
set in the capsule header.
@retval EFI_INVALID_PARAMETER CapsuleCount is 0.
@retval EFI_DEVICE_ERROR      The capsule update was started, but failed due to a device error.
@retval EFI_UNSUPPORTED       The capsule type is not supported on this platform.
@retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has been previously called this error indicates the capsule
is compatible with this platform but is not capable of being submitted or processed
in runtime. The caller may resubmit the capsule prior to ExitBootServices().
@retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has not been previously called then this error indicates
the capsule is compatible with this platform but there are insufficient resources to process.

**/
EFI_UPDATE_CAPSULE :: #type (CapsuleHeaderArray: **EFI_CAPSULE_HEADER, CapsuleCount: UINTN, ScatterGatherList: EFI_PHYSICAL_ADDRESS) -> EFI_STATUS #c_call;

/**
Returns if the capsule can be supported via UpdateCapsule().

@param[in]   CapsuleHeaderArray  Virtual pointer to an array of virtual pointers to the capsules
being passed into update capsule.
@param[in]   CapsuleCount        Number of pointers to EFI_CAPSULE_HEADER in
CaspuleHeaderArray.
@param[out]  MaxiumCapsuleSize   On output the maximum size that UpdateCapsule() can
support as an argument to UpdateCapsule() via
CapsuleHeaderArray and ScatterGatherList.
@param[out]  ResetType           Returns the type of reset required for the capsule update.

@retval EFI_SUCCESS           Valid answer returned.
@retval EFI_UNSUPPORTED       The capsule type is not supported on this platform, and
MaximumCapsuleSize and ResetType are undefined.
@retval EFI_INVALID_PARAMETER MaximumCapsuleSize is NULL.
@retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has been previously called this error indicates the capsule
is compatible with this platform but is not capable of being submitted or processed
in runtime. The caller may resubmit the capsule prior to ExitBootServices().
@retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has not been previously called then this error indicates
the capsule is compatible with this platform but there are insufficient resources to process.

**/
EFI_QUERY_CAPSULE_CAPABILITIES :: #type (CapsuleHeaderArray: **EFI_CAPSULE_HEADER, CapsuleCount: UINTN, MaximumCapsuleSize: *u64, ResetType: *EFI_RESET_TYPE) -> EFI_STATUS #c_call;

/**
Returns information about the EFI variables.

@param[in]   Attributes                   Attributes bitmask to specify the type of variables on
which to return information.
@param[out]  MaximumVariableStorageSize   On output the maximum size of the storage space
available for the EFI variables associated with the
attributes specified.
@param[out]  RemainingVariableStorageSize Returns the remaining size of the storage space
available for the EFI variables associated with the
attributes specified.
@param[out]  MaximumVariableSize          Returns the maximum size of the individual EFI
variables associated with the attributes specified.

@retval EFI_SUCCESS                  Valid answer returned.
@retval EFI_INVALID_PARAMETER        An invalid combination of attribute bits was supplied
@retval EFI_UNSUPPORTED              The attribute is not supported on this platform, and the
MaximumVariableStorageSize,
RemainingVariableStorageSize, MaximumVariableSize
are undefined.

**/
EFI_QUERY_VARIABLE_INFO :: #type (Attributes: u32, MaximumVariableStorageSize: *u64, RemainingVariableStorageSize: *u64, MaximumVariableSize: *u64) -> EFI_STATUS #c_call;

///
/// EFI Runtime Services Table.
///
EFI_RUNTIME_SERVICES :: struct {
    ///
    /// The table header for the EFI Runtime Services Table.
    ///
    Hdr:                       EFI_TABLE_HEADER;

    //
    // Time Services
    //
    GetTime:                   EFI_GET_TIME;
    SetTime:                   EFI_SET_TIME;
    GetWakeupTime:             EFI_GET_WAKEUP_TIME;
    SetWakeupTime:             EFI_SET_WAKEUP_TIME;

    //
    // Virtual Memory Services
    //
    SetVirtualAddressMap:      EFI_SET_VIRTUAL_ADDRESS_MAP;
    ConvertPointer:            EFI_CONVERT_POINTER;

    //
    // Variable Services
    //
    GetVariable:               EFI_GET_VARIABLE;
    GetNextVariableName:       EFI_GET_NEXT_VARIABLE_NAME;
    SetVariable:               EFI_SET_VARIABLE;

    //
    // Miscellaneous Services
    //
    GetNextHighMonotonicCount: EFI_GET_NEXT_HIGH_MONO_COUNT;
    ResetSystem:               EFI_RESET_SYSTEM;

    //
    // UEFI 2.0 Capsule Services
    //
    UpdateCapsule:             EFI_UPDATE_CAPSULE;
    QueryCapsuleCapabilities:  EFI_QUERY_CAPSULE_CAPABILITIES;

    //
    // Miscellaneous UEFI 2.0 Service
    //
    QueryVariableInfo:         EFI_QUERY_VARIABLE_INFO;
}

///
/// EFI Boot Services Table.
///
EFI_BOOT_SERVICES :: struct {
    ///
    /// The table header for the EFI Boot Services Table.
    ///
    Hdr:                                 EFI_TABLE_HEADER;

    //
    // Task Priority Services
    //
    RaiseTPL:                            EFI_RAISE_TPL;
    RestoreTPL:                          EFI_RESTORE_TPL;

    //
    // Memory Services
    //
    AllocatePages:                       EFI_ALLOCATE_PAGES;
    FreePages:                           EFI_FREE_PAGES;
    GetMemoryMap:                        EFI_GET_MEMORY_MAP;
    AllocatePool:                        EFI_ALLOCATE_POOL;
    FreePool:                            EFI_FREE_POOL;

    //
    // Event & Timer Services
    //
    CreateEvent:                         EFI_CREATE_EVENT;
    SetTimer:                            EFI_SET_TIMER;
    WaitForEvent:                        EFI_WAIT_FOR_EVENT;
    SignalEvent:                         EFI_SIGNAL_EVENT;
    CloseEvent:                          EFI_CLOSE_EVENT;
    CheckEvent:                          EFI_CHECK_EVENT;

    //
    // Protocol Handler Services
    //
    InstallProtocolInterface:            EFI_INSTALL_PROTOCOL_INTERFACE;
    ReinstallProtocolInterface:          EFI_REINSTALL_PROTOCOL_INTERFACE;
    UninstallProtocolInterface:          EFI_UNINSTALL_PROTOCOL_INTERFACE;
    HandleProtocol:                      EFI_HANDLE_PROTOCOL;
    Reserved:                            *void;
    RegisterProtocolNotify:              EFI_REGISTER_PROTOCOL_NOTIFY;
    LocateHandle:                        EFI_LOCATE_HANDLE;
    LocateDevicePath:                    EFI_LOCATE_DEVICE_PATH;
    InstallConfigurationTable:           EFI_INSTALL_CONFIGURATION_TABLE;

    //
    // Image Services
    //
    LoadImage:                           EFI_IMAGE_LOAD;
    StartImage:                          EFI_IMAGE_START;
    Exit:                                EFI_EXIT;
    UnloadImage:                         EFI_IMAGE_UNLOAD;
    ExitBootServices:                    EFI_EXIT_BOOT_SERVICES;

    //
    // Miscellaneous Services
    //
    GetNextMonotonicCount:               EFI_GET_NEXT_MONOTONIC_COUNT;
    Stall:                               EFI_STALL;
    SetWatchdogTimer:                    EFI_SET_WATCHDOG_TIMER;

    //
    // DriverSupport Services
    //
    ConnectController:                   EFI_CONNECT_CONTROLLER;
    DisconnectController:                EFI_DISCONNECT_CONTROLLER;

    //
    // Open and Close Protocol Services
    //
    OpenProtocol:                        EFI_OPEN_PROTOCOL;
    CloseProtocol:                       EFI_CLOSE_PROTOCOL;
    OpenProtocolInformation:             EFI_OPEN_PROTOCOL_INFORMATION;

    //
    // Library Services
    //
    ProtocolsPerHandle:                  EFI_PROTOCOLS_PER_HANDLE;
    LocateHandleBuffer:                  EFI_LOCATE_HANDLE_BUFFER;
    LocateProtocol:                      EFI_LOCATE_PROTOCOL;
    InstallMultipleProtocolInterfaces:   EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES;
    UninstallMultipleProtocolInterfaces: EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES;

    //
    // 32-bit CRC Services
    //
    CalculateCrc32:                      EFI_CALCULATE_CRC32;

    //
    // Miscellaneous Services
    //
    CopyMem:                             EFI_COPY_MEM;
    SetMem:                              EFI_SET_MEM;
    CreateEventEx:                       EFI_CREATE_EVENT_EX;
}

///
/// Contains a set of GUID/pointer pairs comprised of the ConfigurationTable field in the
/// EFI System Table.
///
EFI_CONFIGURATION_TABLE :: struct {
    ///
    /// The 128-bit GUID value that uniquely identifies the system configuration table.
    ///
    VendorGuid:  EFI_GUID;

    ///
    /// A pointer to the table associated with VendorGuid.
    ///
    VendorTable: *void;
}

///
/// EFI System Table
///
EFI_SYSTEM_TABLE :: struct {
    ///
    /// The table header for the EFI System Table.
    ///
    Hdr:                  EFI_TABLE_HEADER;

    ///
    /// A pointer to a null terminated string that identifies the vendor
    /// that produces the system firmware for the platform.
    ///
    FirmwareVendor:       *CHAR16;

    ///
    /// A firmware vendor specific value that identifies the revision
    /// of the system firmware for the platform.
    ///
    FirmwareRevision:     u32;

    ///
    /// The handle for the active console input device. This handle must support
    /// EFI_SIMPLE_TEXT_INPUT_PROTOCOL and EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL.
    ///
    ConsoleInHandle:      EFI_HANDLE;

    ///
    /// A pointer to the EFI_SIMPLE_TEXT_INPUT_PROTOCOL interface that is
    /// associated with ConsoleInHandle.
    ///
    ConIn:                *EFI_SIMPLE_TEXT_INPUT_PROTOCOL;

    ///
    /// The handle for the active console output device.
    ///
    ConsoleOutHandle:     EFI_HANDLE;

    ///
    /// A pointer to the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL interface
    /// that is associated with ConsoleOutHandle.
    ///
    ConOut:               *EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL;

    ///
    /// The handle for the active standard error console device.
    /// This handle must support the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.
    ///
    StandardErrorHandle:  EFI_HANDLE;

    ///
    /// A pointer to the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL interface
    /// that is associated with StandardErrorHandle.
    ///
    StdErr:               *EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL;

    ///
    /// A pointer to the EFI Runtime Services Table.
    ///
    RuntimeServices:      *EFI_RUNTIME_SERVICES;

    ///
    /// A pointer to the EFI Boot Services Table.
    ///
    BootServices:         *EFI_BOOT_SERVICES;

    ///
    /// The number of system configuration tables in the buffer ConfigurationTable.
    ///
    NumberOfTableEntries: UINTN;

    ///
    /// A pointer to the system configuration tables.
    /// The number of entries in the table is NumberOfTableEntries.
    ///
    ConfigurationTable:   *EFI_CONFIGURATION_TABLE;
}

/**
This is the declaration of an EFI image entry point. This entry point is
the same for UEFI Applications, UEFI OS Loaders, and UEFI Drivers including
both device drivers and bus drivers.

@param[in]  ImageHandle       The firmware allocated handle for the UEFI image.
@param[in]  SystemTable       A pointer to the EFI System Table.

@retval EFI_SUCCESS           The operation completed successfully.
@retval Others                An unexpected error occurred.
**/
EFI_IMAGE_ENTRY_POINT :: #type (ImageHandle: EFI_HANDLE, SystemTable: *EFI_SYSTEM_TABLE) -> EFI_STATUS #c_call;

_EFI_LOAD_OPTION :: struct {
    ///
    /// The attributes for this load option entry. All unused bits must be zero
    /// and are reserved by the UEFI specification for future growth.
    ///
    Attributes:         u32;

    ///
    /// Length in bytes of the FilePathList. OptionalData starts at offset
    /// sizeof(UINT32) + sizeof(UINT16) + StrSize(Description) + FilePathListLength
    /// of the EFI_LOAD_OPTION descriptor.
    ///
    FilePathListLength: u16;
}

EFI_LOAD_OPTION :: _EFI_LOAD_OPTION;

///
/// EFI Boot Key Data
///
EFI_BOOT_KEY_DATA :: union {
    Options:     struct {
        ///
        /// Indicates the revision of the EFI_KEY_OPTION structure. This revision level should be 0.
        ///
        Revision:       u32;

        ///
        /// Either the left or right Shift keys must be pressed (1) or must not be pressed (0).
        ///
        #place Revision; /*bitfield 8*/ ShiftPressed:   u32;

        ///
        /// Either the left or right Control keys must be pressed (1) or must not be pressed (0).
        ///
        #place Revision; /*bitfield 9*/ ControlPressed: u32;

        ///
        /// Either the left or right Alt keys must be pressed (1) or must not be pressed (0).
        ///
        #place Revision; /*bitfield 10*/ AltPressed:     u32;

        ///
        /// Either the left or right Logo keys must be pressed (1) or must not be pressed (0).
        ///
        #place Revision; /*bitfield 11*/ LogoPressed:    u32;

        ///
        /// The Menu key must be pressed (1) or must not be pressed (0).
        ///
        #place Revision; /*bitfield 12*/ MenuPressed:    u32;

        ///
        /// The SysReq key must be pressed (1) or must not be pressed (0).
        ///
        #place Revision; /*bitfield 13*/ SysReqPressed:  u32;
        #place Revision; /*bitfield 14*/ Reserved:       u32;

        ///
        /// Specifies the actual number of entries in EFI_KEY_OPTION.Keys, from 0-3. If
        /// zero, then only the shift state is considered. If more than one, then the boot option will
        /// only be launched if all of the specified keys are pressed with the same shift state.
        ///
        #place Revision; /*bitfield 30*/ InputKeyCount:  u32;
    };

    PackedValue: u32;
}

EFI_KEY_OPTION :: struct {
    ///
    /// Specifies options about how the key will be processed.
    ///
    KeyData:       EFI_BOOT_KEY_DATA;

    ///
    /// The CRC-32 which should match the CRC-32 of the entire EFI_LOAD_OPTION to
    /// which BootOption refers. If the CRC-32s do not match this value, then this key
    /// option is ignored.
    ///
    BootOptionCrc: u32;

    ///
    /// The Boot#### option which will be invoked if this key is pressed and the boot option
    /// is active (LOAD_OPTION_ACTIVE is set).
    ///
    BootOption:    u16;
}

PXE_VOID :: void;
PXE_UINT8 :: u8;
PXE_UINT16 :: u16;
PXE_UINT32 :: u32;
PXE_UINTN :: UINTN;

///
/// Typedef unsigned long PXE_UINT64.
///
PXE_UINT64 :: u64;

PXE_BOOL :: PXE_UINT8;

PXE_OPCODE :: PXE_UINT16;

PXE_OPFLAGS :: PXE_UINT16;

///
/// PXE STATFLAGS.
///
PXE_STATFLAGS :: PXE_UINT16;

///
/// No additional StatFlags.
///
PXE_STATCODE :: PXE_UINT16;

PXE_IFNUM :: PXE_UINT16;

PXE_CONTROL :: PXE_UINT16;

PXE_FRAME_TYPE :: PXE_UINT8;

PXE_IPV4 :: PXE_UINT32;

PXE_IPV6 :: [4] PXE_UINT32;

PXE_MAC_ADDR :: [32] PXE_UINT8;

PXE_IFTYPE :: PXE_UINT8;
PXE_MEDIA_PROTOCOL :: u16;

s_pxe_hw_undi :: struct {
    Signature:      PXE_UINT32; ///< PXE_ROMID_SIGNATURE.
    Len:            PXE_UINT8; ///< sizeof(PXE_HW_UNDI).
    Fudge:          PXE_UINT8; ///< makes 8-bit cksum equal zero.
    Rev:            PXE_UINT8; ///< PXE_ROMID_REV.
    IFcnt:          PXE_UINT8; ///< physical connector count lower byte.
    MajorVer:       PXE_UINT8; ///< PXE_ROMID_MAJORVER.
    MinorVer:       PXE_UINT8; ///< PXE_ROMID_MINORVER.
    IFcntExt:       PXE_UINT8; ///< physical connector count upper byte.
    reserved:       PXE_UINT8; ///< zero, not used.
    ///< implementation flags.
    ///< reserved             ///< vendor use.
    ///< UINT32 Status;       ///< status port.
    ///< UINT32 Command;      ///< command port.
    ///< UINT64 CDBaddr;      ///< CDB address port.
    ///<
    Implementation: PXE_UINT32;
}

PXE_HW_UNDI :: s_pxe_hw_undi;

s_pxe_sw_undi :: struct {
    Signature:      PXE_UINT32; ///< PXE_ROMID_SIGNATURE.
    Len:            PXE_UINT8; ///< sizeof(PXE_SW_UNDI).
    Fudge:          PXE_UINT8; ///< makes 8-bit cksum zero.
    Rev:            PXE_UINT8; ///< PXE_ROMID_REV.
    IFcnt:          PXE_UINT8; ///< physical connector count lower byte.
    MajorVer:       PXE_UINT8; ///< PXE_ROMID_MAJORVER.
    MinorVer:       PXE_UINT8; ///< PXE_ROMID_MINORVER.
    IFcntExt:       PXE_UINT8; ///< physical connector count upper byte.
    reserved1:      PXE_UINT8; ///< zero, not used.
    Implementation: PXE_UINT32; ///< Implementation flags.
    EntryPoint:     PXE_UINT64; ///< API entry point.
    reserved2:      [3] PXE_UINT8; ///< zero, not used.
    BusCnt:         PXE_UINT8; ///< number of bustypes supported.
    BusType:        [1] PXE_UINT32; ///< list of supported bustypes.
}

PXE_SW_UNDI :: s_pxe_sw_undi;

u_pxe_undi :: union {
    hw: PXE_HW_UNDI;
    sw: PXE_SW_UNDI;
}

PXE_UNDI :: u_pxe_undi;

s_pxe_cdb :: struct {
    OpCode:    PXE_OPCODE;
    OpFlags:   PXE_OPFLAGS;
    CPBsize:   PXE_UINT16;
    DBsize:    PXE_UINT16;
    CPBaddr:   PXE_UINT64;
    DBaddr:    PXE_UINT64;
    StatCode:  PXE_STATCODE;
    StatFlags: PXE_STATFLAGS;
    IFnum:     PXE_UINT16;
    Control:   PXE_CONTROL;
}

PXE_CDB :: s_pxe_cdb;

u_pxe_ip_addr :: union {
    IPv6: PXE_IPV6;
    IPv4: PXE_IPV4;
}

PXE_IP_ADDR :: u_pxe_ip_addr;

pxe_device :: union {
    PCI: struct {
        ///
        /// See S/W UNDI ROMID structure definition for PCI and
        /// PCC BusType definitions.
        ///
        BusType:  PXE_UINT32;

        ///
        /// Bus, device & function numbers that locate this device.
        ///
        Bus:      PXE_UINT16;
        Device:   PXE_UINT8;
        Function: PXE_UINT8;
    };
    PCC: struct {
        ///
        /// See S/W UNDI ROMID structure definition for PCI and
        /// PCC BusType definitions.
        ///
        BusType:  PXE_UINT32;

        ///
        /// Bus, device & function numbers that locate this device.
        ///
        Bus:      PXE_UINT16;
        Device:   PXE_UINT8;
        Function: PXE_UINT8;
    };
}

PXE_DEVICE :: pxe_device;

s_pxe_cpb_start_30 :: struct {
    ///
    /// PXE_VOID Delay(UINTN microseconds);
    ///
    /// UNDI will never request a delay smaller than 10 microseconds
    /// and will always request delays in increments of 10 microseconds.
    /// The Delay() CallBack routine must delay between n and n + 10
    /// microseconds before returning control to the UNDI.
    ///
    /// This field cannot be set to zero.
    ///
    Delay:     u64;

    ///
    /// PXE_VOID Block(UINT32 enable);
    ///
    /// UNDI may need to block multi-threaded/multi-processor access to
    /// critical code sections when programming or accessing the network
    /// device.  To this end, a blocking service is needed by the UNDI.
    /// When UNDI needs a block, it will call Block() passing a non-zero
    /// value.  When UNDI no longer needs a block, it will call Block()
    /// with a zero value.  When called, if the Block() is already enabled,
    /// do not return control to the UNDI until the previous Block() is
    /// disabled.
    ///
    /// This field cannot be set to zero.
    ///
    Block:     u64;

    ///
    /// PXE_VOID Virt2Phys(UINT64 virtual, UINT64 physical_ptr);
    ///
    /// UNDI will pass the virtual address of a buffer and the virtual
    /// address of a 64-bit physical buffer.  Convert the virtual address
    /// to a physical address and write the result to the physical address
    /// buffer.  If virtual and physical addresses are the same, just
    /// copy the virtual address to the physical address buffer.
    ///
    /// This field can be set to zero if virtual and physical addresses
    /// are equal.
    ///
    Virt2Phys: u64;

    ///
    /// PXE_VOID Mem_IO(UINT8 read_write, UINT8 len, UINT64 port,
    ///              UINT64 buf_addr);
    ///
    /// UNDI will read or write the device io space using this call back
    /// function. It passes the number of bytes as the len parameter and it
    /// will be either 1,2,4 or 8.
    ///
    /// This field can not be set to zero.
    ///
    Mem_IO:    u64;
}

PXE_CPB_START_30 :: s_pxe_cpb_start_30;

s_pxe_cpb_start_31 :: struct {
    ///
    /// PXE_VOID Delay(UINT64 UnqId, UINTN microseconds);
    ///
    /// UNDI will never request a delay smaller than 10 microseconds
    /// and will always request delays in increments of 10 microseconds.
    /// The Delay() CallBack routine must delay between n and n + 10
    /// microseconds before returning control to the UNDI.
    ///
    /// This field cannot be set to zero.
    ///
    Delay:     u64;

    ///
    /// PXE_VOID Block(UINT64 unq_id, UINT32 enable);
    ///
    /// UNDI may need to block multi-threaded/multi-processor access to
    /// critical code sections when programming or accessing the network
    /// device.  To this end, a blocking service is needed by the UNDI.
    /// When UNDI needs a block, it will call Block() passing a non-zero
    /// value.  When UNDI no longer needs a block, it will call Block()
    /// with a zero value.  When called, if the Block() is already enabled,
    /// do not return control to the UNDI until the previous Block() is
    /// disabled.
    ///
    /// This field cannot be set to zero.
    ///
    Block:     u64;

    ///
    /// PXE_VOID Virt2Phys(UINT64 UnqId, UINT64 virtual, UINT64 physical_ptr);
    ///
    /// UNDI will pass the virtual address of a buffer and the virtual
    /// address of a 64-bit physical buffer.  Convert the virtual address
    /// to a physical address and write the result to the physical address
    /// buffer.  If virtual and physical addresses are the same, just
    /// copy the virtual address to the physical address buffer.
    ///
    /// This field can be set to zero if virtual and physical addresses
    /// are equal.
    ///
    Virt2Phys: u64;

    ///
    /// PXE_VOID Mem_IO(UINT64 UnqId, UINT8 read_write, UINT8 len, UINT64 port,
    ///              UINT64 buf_addr);
    ///
    /// UNDI will read or write the device io space using this call back
    /// function. It passes the number of bytes as the len parameter and it
    /// will be either 1,2,4 or 8.
    ///
    /// This field can not be set to zero.
    ///
    Mem_IO:    u64;

    ///
    /// PXE_VOID Map_Mem(UINT64 unq_id, UINT64 virtual_addr, UINT32 size,
    ///                 UINT32 Direction, UINT64 mapped_addr);
    ///
    /// UNDI will pass the virtual address of a buffer, direction of the data
    /// flow from/to the mapped buffer (the constants are defined below)
    /// and a place holder (pointer) for the mapped address.
    /// This call will Map the given address to a physical DMA address and write
    /// the result to the mapped_addr pointer.  If there is no need to
    /// map the given address to a lower address (i.e. the given address is
    /// associated with a physical address that is already compatible to be
    /// used with the DMA, it converts the given virtual address to it's
    /// physical address and write that in the mapped address pointer.
    ///
    /// This field can be set to zero if there is no mapping service available.
    ///
    Map_Mem:   u64;

    ///
    /// PXE_VOID UnMap_Mem(UINT64 unq_id, UINT64 virtual_addr, UINT32 size,
    ///            UINT32 Direction, UINT64 mapped_addr);
    ///
    /// UNDI will pass the virtual and mapped addresses of a buffer.
    /// This call will un map the given address.
    ///
    /// This field can be set to zero if there is no unmapping service available.
    ///
    UnMap_Mem: u64;

    ///
    /// PXE_VOID Sync_Mem(UINT64 unq_id, UINT64 virtual,
    ///            UINT32 size, UINT32 Direction, UINT64 mapped_addr);
    ///
    /// UNDI will pass the virtual and mapped addresses of a buffer.
    /// This call will synchronize the contents of both the virtual and mapped.
    /// buffers for the given Direction.
    ///
    /// This field can be set to zero if there is no service available.
    ///
    Sync_Mem:  u64;

    ///
    /// protocol driver can provide anything for this Unique_ID, UNDI remembers
    /// that as just a 64bit value associated to the interface specified by
    /// the ifnum and gives it back as a parameter to all the call-back routines
    /// when calling for that interface!
    ///
    Unique_ID: u64;
}

PXE_CPB_START_31 :: s_pxe_cpb_start_31;

s_pxe_db_get_init_info :: struct {
    ///
    /// Minimum length of locked memory buffer that must be given to
    /// the Initialize command. Giving UNDI more memory will generally
    /// give better performance.
    ///
    /// If MemoryRequired is zero, the UNDI does not need and will not
    /// use system memory to receive and transmit packets.
    ///
    MemoryRequired:         PXE_UINT32;

    ///
    /// Maximum frame data length for Tx/Rx excluding the media header.
    ///
    FrameDataLen:           PXE_UINT32;

    ///
    /// Supported link speeds are in units of mega bits.  Common ethernet
    /// values are 10, 100 and 1000.  Unused LinkSpeeds[] entries are zero
    /// filled.
    ///
    LinkSpeeds:             [4] PXE_UINT32;

    ///
    /// Number of non-volatile storage items.
    ///
    NvCount:                PXE_UINT32;

    ///
    /// Width of non-volatile storage item in bytes.  0, 1, 2 or 4
    ///
    NvWidth:                PXE_UINT16;

    ///
    /// Media header length.  This is the typical media header length for
    /// this UNDI.  This information is needed when allocating receive
    /// and transmit buffers.
    ///
    MediaHeaderLen:         PXE_UINT16;

    ///
    /// Number of bytes in the NIC hardware (MAC) address.
    ///
    HWaddrLen:              PXE_UINT16;

    ///
    /// Maximum number of multicast MAC addresses in the multicast
    /// MAC address filter list.
    ///
    MCastFilterCnt:         PXE_UINT16;

    ///
    /// Default number and size of transmit and receive buffers that will
    /// be allocated by the UNDI.  If MemoryRequired is non-zero, this
    /// allocation will come out of the memory buffer given to the Initialize
    /// command.  If MemoryRequired is zero, this allocation will come out of
    /// memory on the NIC.
    ///
    TxBufCnt:               PXE_UINT16;
    TxBufSize:              PXE_UINT16;
    RxBufCnt:               PXE_UINT16;
    RxBufSize:              PXE_UINT16;

    ///
    /// Hardware interface types defined in the Assigned Numbers RFC
    /// and used in DHCP and ARP packets.
    /// See the PXE_IFTYPE typedef and PXE_IFTYPE_xxx macros.
    ///
    IFtype:                 PXE_UINT8;

    ///
    /// Supported duplex.  See PXE_DUPLEX_xxxxx #defines below.
    ///
    SupportedDuplexModes:   PXE_UINT8;

    ///
    /// Supported loopback options.  See PXE_LOOPBACK_xxxxx #defines below.
    ///
    SupportedLoopBackModes: PXE_UINT8;
}

PXE_DB_GET_INIT_INFO :: s_pxe_db_get_init_info;

s_pxe_pci_config_info :: struct {
    ///
    /// This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
    /// For PCI bus devices, this field is set to PXE_BUSTYPE_PCI.
    ///
    BusType:  u32;

    ///
    /// This identifies the PCI network device that this UNDI interface.
    /// is bound to.
    ///
    Bus:      u16;
    Device:   u8;
    Function: u8;

    Config:   union {
        Byte:  [256] u8;
        Word:  [128] u16;
        Dword: [64] u32;
    };
}

PXE_PCI_CONFIG_INFO :: s_pxe_pci_config_info;

s_pxe_pcc_config_info :: struct {
    ///
    /// This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
    /// For PCC bus devices, this field is set to PXE_BUSTYPE_PCC.
    ///
    BusType:  PXE_UINT32;

    ///
    /// This identifies the PCC network device that this UNDI interface
    /// is bound to.
    ///
    Bus:      PXE_UINT16;
    Device:   PXE_UINT8;
    Function: PXE_UINT8;

    Config:   union {
        Byte:  [256] PXE_UINT8;
        Word:  [128] PXE_UINT16;
        Dword: [64] PXE_UINT32;
    };
}

PXE_PCC_CONFIG_INFO :: s_pxe_pcc_config_info;

u_pxe_db_get_config_info :: union {
    pci: PXE_PCI_CONFIG_INFO;
    pcc: PXE_PCC_CONFIG_INFO;
}

PXE_DB_GET_CONFIG_INFO :: u_pxe_db_get_config_info;

s_pxe_cpb_initialize :: struct {
    ///
    /// Address of first (lowest) byte of the memory buffer.  This buffer must
    /// be in contiguous physical memory and cannot be swapped out.  The UNDI
    /// will be using this for transmit and receive buffering.
    ///
    MemoryAddr:   PXE_UINT64;

    ///
    /// MemoryLength must be greater than or equal to MemoryRequired
    /// returned by the Get Init Info command.
    ///
    MemoryLength: PXE_UINT32;

    ///
    /// Desired link speed in Mbit/sec.  Common ethernet values are 10, 100
    /// and 1000.  Setting a value of zero will auto-detect and/or use the
    /// default link speed (operation depends on UNDI/NIC functionality).
    ///
    LinkSpeed:    PXE_UINT32;

    ///
    /// Suggested number and size of receive and transmit buffers to
    /// allocate.  If MemoryAddr and MemoryLength are non-zero, this
    /// allocation comes out of the supplied memory buffer.  If MemoryAddr
    /// and MemoryLength are zero, this allocation comes out of memory
    /// on the NIC.
    ///
    /// If these fields are set to zero, the UNDI will allocate buffer
    /// counts and sizes as it sees fit.
    ///
    TxBufCnt:     PXE_UINT16;
    TxBufSize:    PXE_UINT16;
    RxBufCnt:     PXE_UINT16;
    RxBufSize:    PXE_UINT16;

    ///
    /// The following configuration parameters are optional and must be zero
    /// to use the default values.
    ///
    DuplexMode:   PXE_UINT8;

    LoopBackMode: PXE_UINT8;
}

PXE_CPB_INITIALIZE :: s_pxe_cpb_initialize;

s_pxe_db_initialize :: struct {
    ///
    /// Actual amount of memory used from the supplied memory buffer.  This
    /// may be less that the amount of memory suppllied and may be zero if
    /// the UNDI and network device do not use external memory buffers.
    ///
    /// Memory used by the UNDI and network device is allocated from the
    /// lowest memory buffer address.
    ///
    MemoryUsed: PXE_UINT32;

    ///
    /// Actual number and size of receive and transmit buffers that were
    /// allocated.
    ///
    TxBufCnt:   PXE_UINT16;
    TxBufSize:  PXE_UINT16;
    RxBufCnt:   PXE_UINT16;
    RxBufSize:  PXE_UINT16;
}

PXE_DB_INITIALIZE :: s_pxe_db_initialize;

s_pxe_cpb_receive_filters :: struct {
    ///
    /// List of multicast MAC addresses.  This list, if present, will
    /// replace the existing multicast MAC address filter list.
    ///
    MCastList: [8] PXE_MAC_ADDR;
}

PXE_CPB_RECEIVE_FILTERS :: s_pxe_cpb_receive_filters;

s_pxe_db_receive_filters :: struct {
    ///
    /// Filtered multicast MAC address list.
    ///
    MCastList: [8] PXE_MAC_ADDR;
}

PXE_DB_RECEIVE_FILTERS :: s_pxe_db_receive_filters;

s_pxe_cpb_station_address :: struct {
    ///
    /// If supplied and supported, the current station MAC address
    /// will be changed.
    ///
    StationAddr: PXE_MAC_ADDR;
}

PXE_CPB_STATION_ADDRESS :: s_pxe_cpb_station_address;

s_pxe_dpb_station_address :: struct {
    ///
    /// Current station MAC address.
    ///
    StationAddr:   PXE_MAC_ADDR;

    ///
    /// Station broadcast MAC address.
    ///
    BroadcastAddr: PXE_MAC_ADDR;

    ///
    /// Permanent station MAC address.
    ///
    PermanentAddr: PXE_MAC_ADDR;
}

PXE_DB_STATION_ADDRESS :: s_pxe_dpb_station_address;

s_pxe_db_statistics :: struct {
    ///
    /// Bit field identifying what statistic data is collected by the
    /// UNDI/NIC.
    /// If bit 0x00 is set, Data[0x00] is collected.
    /// If bit 0x01 is set, Data[0x01] is collected.
    /// If bit 0x20 is set, Data[0x20] is collected.
    /// If bit 0x21 is set, Data[0x21] is collected.
    /// Etc.
    ///
    Supported: PXE_UINT64;

    ///
    /// Statistic data.
    ///
    Data:      [64] PXE_UINT64;
}

PXE_DB_STATISTICS :: s_pxe_db_statistics;

s_pxe_cpb_mcast_ip_to_mac :: struct {
    ///
    /// Multicast IP address to be converted to multicast MAC address.
    ///
    IP: PXE_IP_ADDR;
}

PXE_CPB_MCAST_IP_TO_MAC :: s_pxe_cpb_mcast_ip_to_mac;

s_pxe_db_mcast_ip_to_mac :: struct {
    ///
    /// Multicast MAC address.
    ///
    MAC: PXE_MAC_ADDR;
}

PXE_DB_MCAST_IP_TO_MAC :: s_pxe_db_mcast_ip_to_mac;

s_pxe_cpb_nvdata_sparse :: struct {
    Item: [128] struct {
        ///
        ///  Non-volatile storage address to be changed.
        ///
        Addr: PXE_UINT32;

        Data: union {
            Byte:  PXE_UINT8;
            Word:  PXE_UINT16;
            Dword: PXE_UINT32;
        };
    };
}

PXE_CPB_NVDATA_SPARSE :: s_pxe_cpb_nvdata_sparse;

///
/// When using bulk update, the size of the CPB structure must be
/// the same size as the non-volatile NIC storage.
///
u_pxe_cpb_nvdata_bulk :: union {
    ///
    /// Array of byte-wide data items.
    ///
    Byte:  [512] PXE_UINT8;

    ///
    /// Array of word-wide data items.
    ///
    Word:  [256] PXE_UINT16;

    ///
    /// Array of dword-wide data items.
    ///
    Dword: [128] PXE_UINT32;
}

///
/// When using bulk update, the size of the CPB structure must be
/// the same size as the non-volatile NIC storage.
///
PXE_CPB_NVDATA_BULK :: u_pxe_cpb_nvdata_bulk;

s_pxe_db_nvdata :: struct {
    Data: union {
        ///
        /// Array of byte-wide data items.
        ///
        Byte:  [512] PXE_UINT8;

        ///
        /// Array of word-wide data items.
        ///
        Word:  [256] PXE_UINT16;

        ///
        /// Array of dword-wide data items.
        ///
        Dword: [128] PXE_UINT32;
    };
}

PXE_DB_NVDATA :: s_pxe_db_nvdata;

s_pxe_db_get_status :: struct {
    ///
    /// Length of next receive frame (header + data).  If this is zero,
    /// there is no next receive frame available.
    ///
    RxFrameLen: PXE_UINT32;

    ///
    /// Reserved, set to zero.
    ///
    reserved:   PXE_UINT32;

    ///
    ///  Addresses of transmitted buffers that need to be recycled.
    ///
    TxBuffer:   [32] PXE_UINT64;
}

PXE_DB_GET_STATUS :: s_pxe_db_get_status;

s_pxe_cpb_fill_header :: struct {
    ///
    /// Source and destination MAC addresses.  These will be copied into
    /// the media header without doing byte swapping.
    ///
    SrcAddr:        PXE_MAC_ADDR;
    DestAddr:       PXE_MAC_ADDR;

    ///
    /// Address of first byte of media header.  The first byte of packet data
    /// follows the last byte of the media header.
    ///
    MediaHeader:    PXE_UINT64;

    ///
    /// Length of packet data in bytes (not including the media header).
    ///
    PacketLen:      PXE_UINT32;

    ///
    /// Protocol type.  This will be copied into the media header without
    /// doing byte swapping.  Protocol type numbers can be obtained from
    /// the Assigned Numbers RFC 1700.
    ///
    Protocol:       PXE_UINT16;

    ///
    /// Length of the media header in bytes.
    ///
    MediaHeaderLen: PXE_UINT16;
}

PXE_CPB_FILL_HEADER :: s_pxe_cpb_fill_header;

s_pxe_cpb_fill_header_fragmented :: struct {
    ///
    /// Source and destination MAC addresses.  These will be copied into
    /// the media header without doing byte swapping.
    ///
    SrcAddr:        PXE_MAC_ADDR;
    DestAddr:       PXE_MAC_ADDR;

    ///
    /// Length of packet data in bytes (not including the media header).
    ///
    PacketLen:      PXE_UINT32;

    ///
    /// Protocol type.  This will be copied into the media header without
    /// doing byte swapping.  Protocol type numbers can be obtained from
    /// the Assigned Numbers RFC 1700.
    ///
    Protocol:       PXE_MEDIA_PROTOCOL;

    ///
    /// Length of the media header in bytes.
    ///
    MediaHeaderLen: PXE_UINT16;

    ///
    /// Number of packet fragment descriptors.
    ///
    FragCnt:        PXE_UINT16;

    ///
    /// Reserved, must be set to zero.
    ///
    reserved:       PXE_UINT16;

    FragDesc:       [16] struct {
        ///
        /// Address of this packet fragment.
        ///
        FragAddr: PXE_UINT64;

        ///
        /// Length of this packet fragment.
        ///
        FragLen:  PXE_UINT32;

        ///
        /// Reserved, must be set to zero.
        ///
        reserved: PXE_UINT32;
    } #align 4;
}

PXE_CPB_FILL_HEADER_FRAGMENTED :: s_pxe_cpb_fill_header_fragmented;

s_pxe_cpb_transmit :: struct {
    ///
    /// Address of first byte of frame buffer.  This is also the first byte
    /// of the media header.
    ///
    FrameAddr:      PXE_UINT64;

    ///
    /// Length of the data portion of the frame buffer in bytes.  Do not
    /// include the length of the media header.
    ///
    DataLen:        PXE_UINT32;

    ///
    /// Length of the media header in bytes.
    ///
    MediaheaderLen: PXE_UINT16;

    ///
    /// Reserved, must be zero.
    ///
    reserved:       PXE_UINT16;
}

PXE_CPB_TRANSMIT :: s_pxe_cpb_transmit;

s_pxe_cpb_transmit_fragments :: struct {
    ///
    /// Length of packet data in bytes (not including the media header).
    ///
    FrameLen:       PXE_UINT32;

    ///
    /// Length of the media header in bytes.
    ///
    MediaheaderLen: PXE_UINT16;

    ///
    /// Number of packet fragment descriptors.
    ///
    FragCnt:        PXE_UINT16;

    FragDesc:       [16] struct {
        ///
        /// Address of this frame fragment.
        ///
        FragAddr: PXE_UINT64;

        ///
        /// Length of this frame fragment.
        ///
        FragLen:  PXE_UINT32;

        ///
        /// Reserved, must be set to zero.
        ///
        reserved: PXE_UINT32;
    };
}

PXE_CPB_TRANSMIT_FRAGMENTS :: s_pxe_cpb_transmit_fragments;

s_pxe_cpb_receive :: struct {
    ///
    /// Address of first byte of receive buffer.  This is also the first byte
    /// of the frame header.
    ///
    BufferAddr: PXE_UINT64;

    ///
    /// Length of receive buffer.  This must be large enough to hold the
    /// received frame (media header + data).  If the length of smaller than
    /// the received frame, data will be lost.
    ///
    BufferLen:  PXE_UINT32;

    ///
    /// Reserved, must be set to zero.
    ///
    reserved:   PXE_UINT32;
}

PXE_CPB_RECEIVE :: s_pxe_cpb_receive;

s_pxe_db_receive :: struct {
    ///
    /// Source and destination MAC addresses from media header.
    ///
    SrcAddr:        PXE_MAC_ADDR;
    DestAddr:       PXE_MAC_ADDR;

    ///
    /// Length of received frame.  May be larger than receive buffer size.
    /// The receive buffer will not be overwritten.  This is how to tell
    /// if data was lost because the receive buffer was too small.
    ///
    FrameLen:       PXE_UINT32;

    ///
    /// Protocol type from media header.
    ///
    Protocol:       PXE_MEDIA_PROTOCOL;

    ///
    /// Length of media header in received frame.
    ///
    MediaHeaderLen: PXE_UINT16;

    ///
    /// Type of receive frame.
    ///
    Type:           PXE_FRAME_TYPE;

    ///
    /// Reserved, must be zero.
    ///
    reserved:       [7] PXE_UINT8;
}

PXE_DB_RECEIVE :: s_pxe_db_receive;

///
/// GPT Partition Table Header.
///
EFI_PARTITION_TABLE_HEADER :: struct {
    ///
    /// The table header for the GPT partition Table.
    /// This header contains EFI_PTAB_HEADER_ID.
    ///
    Header:                   EFI_TABLE_HEADER;

    ///
    /// The LBA that contains this data structure.
    ///
    MyLBA:                    EFI_LBA;

    ///
    /// LBA address of the alternate GUID Partition Table Header.
    ///
    AlternateLBA:             EFI_LBA;

    ///
    /// The first usable logical block that may be used
    /// by a partition described by a GUID Partition Entry.
    ///
    FirstUsableLBA:           EFI_LBA;

    ///
    /// The last usable logical block that may be used
    /// by a partition described by a GUID Partition Entry.
    ///
    LastUsableLBA:            EFI_LBA;

    ///
    /// GUID that can be used to uniquely identify the disk.
    ///
    DiskGUID:                 EFI_GUID;

    ///
    /// The starting LBA of the GUID Partition Entry array.
    ///
    PartitionEntryLBA:        EFI_LBA;

    ///
    /// The number of Partition Entries in the GUID Partition Entry array.
    ///
    NumberOfPartitionEntries: u32;

    ///
    /// The size, in bytes, of each the GUID Partition
    /// Entry structures in the GUID Partition Entry
    /// array. This field shall be set to a value of 128 x 2^n where n is
    /// an integer greater than or equal to zero (e.g., 128, 256, 512, etc.).
    ///
    SizeOfPartitionEntry:     u32;

    ///
    /// The CRC32 of the GUID Partition Entry array.
    /// Starts at PartitionEntryLBA and is
    /// computed over a byte length of
    /// NumberOfPartitionEntries * SizeOfPartitionEntry.
    ///
    PartitionEntryArrayCRC32: u32;
}

///
/// GPT Partition Entry.
///
EFI_PARTITION_ENTRY :: struct {
    ///
    /// Unique ID that defines the purpose and type of this Partition. A value of
    /// zero defines that this partition entry is not being used.
    ///
    PartitionTypeGUID:   EFI_GUID;

    ///
    /// GUID that is unique for every partition entry. Every partition ever
    /// created will have a unique GUID.
    /// This GUID must be assigned when the GUID Partition Entry is created.
    ///
    UniquePartitionGUID: EFI_GUID;

    ///
    /// Starting LBA of the partition defined by this entry
    ///
    StartingLBA:         EFI_LBA;

    ///
    /// Ending LBA of the partition defined by this entry.
    ///
    EndingLBA:           EFI_LBA;

    ///
    /// Attribute bits, all bits reserved by UEFI
    /// Bit 0:      If this bit is set, the partition is required for the platform to function. The owner/creator of the
    ///             partition indicates that deletion or modification of the contents can result in loss of platform
    ///             features or failure for the platform to boot or operate. The system cannot function normally if
    ///             this partition is removed, and it should be considered part of the hardware of the system.
    ///             Actions such as running diagnostics, system recovery, or even OS install or boot, could
    ///             potentially stop working if this partition is removed. Unless OS software or firmware
    ///             recognizes this partition, it should never be removed or modified as the UEFI firmware or
    ///             platform hardware may become non-functional.
    /// Bit 1:      If this bit is set, then firmware must not produce an EFI_BLOCK_IO_PROTOCOL device for
    ///             this partition. By not producing an EFI_BLOCK_IO_PROTOCOL partition, file system
    ///             mappings will not be created for this partition in UEFI.
    /// Bit 2:      This bit is set aside to let systems with traditional PC-AT BIOS firmware implementations
    ///             inform certain limited, special-purpose software running on these systems that a GPT
    ///             partition may be bootable. The UEFI boot manager must ignore this bit when selecting
    ///             a UEFI-compliant application, e.g., an OS loader.
    /// Bits 3-47:  Undefined and must be zero. Reserved for expansion by future versions of the UEFI
    ///             specification.
    /// Bits 48-63: Reserved for GUID specific use. The use of these bits will vary depending on the
    ///             PartitionTypeGUID. Only the owner of the PartitionTypeGUID is allowed
    ///             to modify these bits. They must be preserved if Bits 0-47 are modified..
    ///
    Attributes:          u64;

    ///
    /// Null-terminated name of the partition.
    ///
    PartitionName:       [36] CHAR16;
}

///
/// The following types are currently defined:
///
EFI_HII_HANDLE :: *void;
EFI_STRING :: *CHAR16;
EFI_IMAGE_ID :: u16;
EFI_QUESTION_ID :: u16;
EFI_STRING_ID :: u16;
EFI_FORM_ID :: u16;
EFI_VARSTORE_ID :: u16;
EFI_ANIMATION_ID :: u16;

EFI_DEFAULT_ID :: u16;

EFI_HII_FONT_STYLE :: u32;

///
/// The header found at the start of each package list.
///
EFI_HII_PACKAGE_LIST_HEADER :: struct {
    PackageListGuid: EFI_GUID;
    PackageLength:   u32;
}

///
/// The header found at the start of each package.
///
EFI_HII_PACKAGE_HEADER :: struct {
    Length: u32;
    #place Length; /*bitfield 24*/ Type:   u32;
}

///
/// The EFI_NARROW_GLYPH has a preferred dimension (w x h) of 8 x 19 pixels.
///
EFI_NARROW_GLYPH :: struct {
    ///
    /// The Unicode representation of the glyph. The term weight is the
    /// technical term for a character code.
    ///
    UnicodeWeight: CHAR16;

    ///
    /// The data element containing the glyph definitions.
    ///
    Attributes:    u8;

    ///
    /// The column major glyph representation of the character. Bits
    /// with values of one indicate that the corresponding pixel is to be
    /// on when normally displayed; those with zero are off.
    ///
    GlyphCol1:     [19] u8;
}

///
/// The EFI_WIDE_GLYPH has a preferred dimension (w x h) of 16 x 19 pixels, which is large enough
/// to accommodate logographic characters.
///
EFI_WIDE_GLYPH :: struct {
    ///
    /// The Unicode representation of the glyph. The term weight is the
    /// technical term for a character code.
    ///
    UnicodeWeight: CHAR16;

    ///
    /// The data element containing the glyph definitions.
    ///
    Attributes:    u8;

    ///
    /// The column major glyph representation of the character. Bits
    /// with values of one indicate that the corresponding pixel is to be
    /// on when normally displayed; those with zero are off.
    ///
    GlyphCol1:     [19] u8;

    ///
    /// The column major glyph representation of the character. Bits
    /// with values of one indicate that the corresponding pixel is to be
    /// on when normally displayed; those with zero are off.
    ///
    GlyphCol2:     [19] u8;

    ///
    /// Ensures that sizeof (EFI_WIDE_GLYPH) is twice the
    /// sizeof (EFI_NARROW_GLYPH). The contents of Pad must
    /// be zero.
    ///
    Pad:           [3] u8;
}

///
/// A simplified font package consists of a font header
/// followed by a series of glyph structures.
///
_EFI_HII_SIMPLE_FONT_PACKAGE_HDR :: struct {
    Header:               EFI_HII_PACKAGE_HEADER;
    NumberOfNarrowGlyphs: u16;
    NumberOfWideGlyphs:   u16;
}

///
/// A simplified font package consists of a font header
/// followed by a series of glyph structures.
///
EFI_HII_SIMPLE_FONT_PACKAGE_HDR :: _EFI_HII_SIMPLE_FONT_PACKAGE_HDR;

_EFI_HII_GLYPH_INFO :: struct {
    Width:    u16;
    Height:   u16;
    OffsetX:  s16;
    OffsetY:  s16;
    AdvanceX: s16;
}

EFI_HII_GLYPH_INFO :: _EFI_HII_GLYPH_INFO;

///
/// The fixed header consists of a standard record header,
/// then the character values in this section, the flags
/// (including the encoding method) and the offsets of the glyph
/// information, the glyph bitmaps and the character map.
///
_EFI_HII_FONT_PACKAGE_HDR :: struct {
    Header:           EFI_HII_PACKAGE_HEADER;
    HdrSize:          u32;
    GlyphBlockOffset: u32;
    Cell:             EFI_HII_GLYPH_INFO;
    FontStyle:        EFI_HII_FONT_STYLE #align 2;
    FontFamily:       [1] CHAR16;
}

///
/// The fixed header consists of a standard record header,
/// then the character values in this section, the flags
/// (including the encoding method) and the offsets of the glyph
/// information, the glyph bitmaps and the character map.
///
EFI_HII_FONT_PACKAGE_HDR :: _EFI_HII_FONT_PACKAGE_HDR;

_EFI_HII_GLYPH_BLOCK :: struct {
    BlockType: u8;
}

EFI_HII_GLYPH_BLOCK :: _EFI_HII_GLYPH_BLOCK;

//
// Definition of different glyph info block types
//
_EFI_HII_GIBT_DEFAULTS_BLOCK :: struct {
    Header: EFI_HII_GLYPH_BLOCK;
    Cell:   EFI_HII_GLYPH_INFO #align 1;
}

//
// Definition of different glyph info block types
//
EFI_HII_GIBT_DEFAULTS_BLOCK :: _EFI_HII_GIBT_DEFAULTS_BLOCK;

_EFI_HII_GIBT_DUPLICATE_BLOCK :: struct {
    Header:    EFI_HII_GLYPH_BLOCK;
    CharValue: CHAR16 #align 1;
}

EFI_HII_GIBT_DUPLICATE_BLOCK :: _EFI_HII_GIBT_DUPLICATE_BLOCK;

_EFI_GLYPH_GIBT_END_BLOCK :: struct {
    Header: EFI_HII_GLYPH_BLOCK;
}

EFI_GLYPH_GIBT_END_BLOCK :: _EFI_GLYPH_GIBT_END_BLOCK;

_EFI_HII_GIBT_EXT1_BLOCK :: struct {
    Header:     EFI_HII_GLYPH_BLOCK;
    BlockType2: u8;
    Length:     u8;
}

EFI_HII_GIBT_EXT1_BLOCK :: _EFI_HII_GIBT_EXT1_BLOCK;

_EFI_HII_GIBT_EXT2_BLOCK :: struct {
    Header:     EFI_HII_GLYPH_BLOCK;
    BlockType2: u8;
    Length:     u16;
}

EFI_HII_GIBT_EXT2_BLOCK :: _EFI_HII_GIBT_EXT2_BLOCK;

_EFI_HII_GIBT_EXT4_BLOCK :: struct {
    Header:     EFI_HII_GLYPH_BLOCK;
    BlockType2: u8;
    Length:     u32 #align 2;
}

EFI_HII_GIBT_EXT4_BLOCK :: _EFI_HII_GIBT_EXT4_BLOCK;

_EFI_HII_GIBT_GLYPH_BLOCK :: struct {
    Header:     EFI_HII_GLYPH_BLOCK;
    Cell:       EFI_HII_GLYPH_INFO #align 1;
    BitmapData: [1] u8;
}

EFI_HII_GIBT_GLYPH_BLOCK :: _EFI_HII_GIBT_GLYPH_BLOCK;

_EFI_HII_GIBT_GLYPHS_BLOCK :: struct {
    Header:     EFI_HII_GLYPH_BLOCK;
    Cell:       EFI_HII_GLYPH_INFO #align 1;
    Count:      u16 #align 1;
    BitmapData: [1] u8;
}

EFI_HII_GIBT_GLYPHS_BLOCK :: _EFI_HII_GIBT_GLYPHS_BLOCK;

_EFI_HII_GIBT_GLYPH_DEFAULT_BLOCK :: struct {
    Header:     EFI_HII_GLYPH_BLOCK;
    BitmapData: [1] u8;
}

EFI_HII_GIBT_GLYPH_DEFAULT_BLOCK :: _EFI_HII_GIBT_GLYPH_DEFAULT_BLOCK;

_EFI_HII_GIBT_GLYPHS_DEFAULT_BLOCK :: struct {
    Header:     EFI_HII_GLYPH_BLOCK;
    Count:      u16 #align 1;
    BitmapData: [1] u8;
}

EFI_HII_GIBT_GLYPHS_DEFAULT_BLOCK :: _EFI_HII_GIBT_GLYPHS_DEFAULT_BLOCK;

_EFI_HII_GIBT_VARIABILITY_BLOCK :: struct {
    Header:          EFI_HII_GLYPH_BLOCK;
    Cell:            EFI_HII_GLYPH_INFO #align 1;
    GlyphPackInBits: u8;
    BitmapData:      [1] u8;
}

EFI_HII_GIBT_VARIABILITY_BLOCK :: _EFI_HII_GIBT_VARIABILITY_BLOCK;

_EFI_HII_GIBT_SKIP1_BLOCK :: struct {
    Header:    EFI_HII_GLYPH_BLOCK;
    SkipCount: u8;
}

EFI_HII_GIBT_SKIP1_BLOCK :: _EFI_HII_GIBT_SKIP1_BLOCK;

_EFI_HII_GIBT_SKIP2_BLOCK :: struct {
    Header:    EFI_HII_GLYPH_BLOCK;
    SkipCount: u16 #align 1;
}

EFI_HII_GIBT_SKIP2_BLOCK :: _EFI_HII_GIBT_SKIP2_BLOCK;

///
/// The device path package is used to carry a device path
/// associated with the package list.
///
_EFI_HII_DEVICE_PATH_PACKAGE_HDR :: struct {
    Header: EFI_HII_PACKAGE_HEADER;
}

///
/// The device path package is used to carry a device path
/// associated with the package list.
///
EFI_HII_DEVICE_PATH_PACKAGE_HDR :: _EFI_HII_DEVICE_PATH_PACKAGE_HDR;

///
/// The GUID package is used to carry data where the format is defined by a GUID.
///
_EFI_HII_GUID_PACKAGE_HDR :: struct {
    Header: EFI_HII_PACKAGE_HEADER;
    Guid:   EFI_GUID;
}

///
/// The GUID package is used to carry data where the format is defined by a GUID.
///
EFI_HII_GUID_PACKAGE_HDR :: _EFI_HII_GUID_PACKAGE_HDR;

///
/// The fixed header consists of a standard record header and then the string identifiers
/// contained in this section and the offsets of the string and language information.
///
_EFI_HII_STRING_PACKAGE_HDR :: struct {
    Header:           EFI_HII_PACKAGE_HEADER;
    HdrSize:          u32;
    StringInfoOffset: u32;
    LanguageWindow:   [16] CHAR16;
    LanguageName:     EFI_STRING_ID;
    Language:         [1] CHAR8;
}

///
/// The fixed header consists of a standard record header and then the string identifiers
/// contained in this section and the offsets of the string and language information.
///
EFI_HII_STRING_PACKAGE_HDR :: _EFI_HII_STRING_PACKAGE_HDR;

EFI_HII_STRING_BLOCK :: struct {
    BlockType: u8;
}

//
// Definition of different string information block types
//
_EFI_HII_SIBT_DUPLICATE_BLOCK :: struct {
    Header:   EFI_HII_STRING_BLOCK;
    StringId: EFI_STRING_ID #align 1;
}

//
// Definition of different string information block types
//
EFI_HII_SIBT_DUPLICATE_BLOCK :: _EFI_HII_SIBT_DUPLICATE_BLOCK;

_EFI_HII_SIBT_END_BLOCK :: struct {
    Header: EFI_HII_STRING_BLOCK;
}

EFI_HII_SIBT_END_BLOCK :: _EFI_HII_SIBT_END_BLOCK;

_EFI_HII_SIBT_EXT1_BLOCK :: struct {
    Header:     EFI_HII_STRING_BLOCK;
    BlockType2: u8;
    Length:     u8;
}

EFI_HII_SIBT_EXT1_BLOCK :: _EFI_HII_SIBT_EXT1_BLOCK;

_EFI_HII_SIBT_EXT2_BLOCK :: struct {
    Header:     EFI_HII_STRING_BLOCK;
    BlockType2: u8;
    Length:     u16;
}

EFI_HII_SIBT_EXT2_BLOCK :: _EFI_HII_SIBT_EXT2_BLOCK;

_EFI_HII_SIBT_EXT4_BLOCK :: struct {
    Header:     EFI_HII_STRING_BLOCK;
    BlockType2: u8;
    Length:     u32 #align 2;
}

EFI_HII_SIBT_EXT4_BLOCK :: _EFI_HII_SIBT_EXT4_BLOCK;

_EFI_HII_SIBT_FONT_BLOCK :: struct {
    Header:    EFI_HII_SIBT_EXT2_BLOCK;
    FontId:    u8;
    FontSize:  u16 #align 1;
    FontStyle: EFI_HII_FONT_STYLE #align 3;
    FontName:  [1] CHAR16 #align 1;
}

EFI_HII_SIBT_FONT_BLOCK :: _EFI_HII_SIBT_FONT_BLOCK;

_EFI_HII_SIBT_SKIP1_BLOCK :: struct {
    Header:    EFI_HII_STRING_BLOCK;
    SkipCount: u8;
}

EFI_HII_SIBT_SKIP1_BLOCK :: _EFI_HII_SIBT_SKIP1_BLOCK;

_EFI_HII_SIBT_SKIP2_BLOCK :: struct {
    Header:    EFI_HII_STRING_BLOCK;
    SkipCount: u16 #align 1;
}

EFI_HII_SIBT_SKIP2_BLOCK :: _EFI_HII_SIBT_SKIP2_BLOCK;

_EFI_HII_SIBT_STRING_SCSU_BLOCK :: struct {
    Header:     EFI_HII_STRING_BLOCK;
    StringText: [1] u8;
}

EFI_HII_SIBT_STRING_SCSU_BLOCK :: _EFI_HII_SIBT_STRING_SCSU_BLOCK;

_EFI_HII_SIBT_STRING_SCSU_FONT_BLOCK :: struct {
    Header:         EFI_HII_STRING_BLOCK;
    FontIdentifier: u8;
    StringText:     [1] u8;
}

EFI_HII_SIBT_STRING_SCSU_FONT_BLOCK :: _EFI_HII_SIBT_STRING_SCSU_FONT_BLOCK;

_EFI_HII_SIBT_STRINGS_SCSU_BLOCK :: struct {
    Header:      EFI_HII_STRING_BLOCK;
    StringCount: u16 #align 1;
    StringText:  [1] u8;
}

EFI_HII_SIBT_STRINGS_SCSU_BLOCK :: _EFI_HII_SIBT_STRINGS_SCSU_BLOCK;

_EFI_HII_SIBT_STRINGS_SCSU_FONT_BLOCK :: struct {
    Header:         EFI_HII_STRING_BLOCK;
    FontIdentifier: u8;
    StringCount:    u16;
    StringText:     [1] u8;
}

EFI_HII_SIBT_STRINGS_SCSU_FONT_BLOCK :: _EFI_HII_SIBT_STRINGS_SCSU_FONT_BLOCK;

_EFI_HII_SIBT_STRING_UCS2_BLOCK :: struct {
    Header:     EFI_HII_STRING_BLOCK;
    StringText: [1] CHAR16 #align 1;
}

EFI_HII_SIBT_STRING_UCS2_BLOCK :: _EFI_HII_SIBT_STRING_UCS2_BLOCK;

_EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK :: struct {
    Header:         EFI_HII_STRING_BLOCK;
    FontIdentifier: u8;
    StringText:     [1] CHAR16;
}

EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK :: _EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK;

_EFI_HII_SIBT_STRINGS_UCS2_BLOCK :: struct {
    Header:      EFI_HII_STRING_BLOCK;
    StringCount: u16 #align 1;
    StringText:  [1] CHAR16 #align 1;
}

EFI_HII_SIBT_STRINGS_UCS2_BLOCK :: _EFI_HII_SIBT_STRINGS_UCS2_BLOCK;

_EFI_HII_SIBT_STRINGS_UCS2_FONT_BLOCK :: struct {
    Header:         EFI_HII_STRING_BLOCK;
    FontIdentifier: u8;
    StringCount:    u16;
    StringText:     [1] CHAR16;
}

EFI_HII_SIBT_STRINGS_UCS2_FONT_BLOCK :: _EFI_HII_SIBT_STRINGS_UCS2_FONT_BLOCK;

//
// Definitions for Image Package
// Section 27.3.7
//
_EFI_HII_IMAGE_PACKAGE_HDR :: struct {
    Header:            EFI_HII_PACKAGE_HEADER;
    ImageInfoOffset:   u32;
    PaletteInfoOffset: u32;
}

//
// Definitions for Image Package
// Section 27.3.7
//
EFI_HII_IMAGE_PACKAGE_HDR :: _EFI_HII_IMAGE_PACKAGE_HDR;

_EFI_HII_IMAGE_BLOCK :: struct {
    BlockType: u8;
}

EFI_HII_IMAGE_BLOCK :: _EFI_HII_IMAGE_BLOCK;

//
// Definition of different image information block types
//
_EFI_HII_IIBT_END_BLOCK :: struct {
    Header: EFI_HII_IMAGE_BLOCK;
}

//
// Definition of different image information block types
//
EFI_HII_IIBT_END_BLOCK :: _EFI_HII_IIBT_END_BLOCK;

_EFI_HII_IIBT_EXT1_BLOCK :: struct {
    Header:     EFI_HII_IMAGE_BLOCK;
    BlockType2: u8;
    Length:     u8;
}

EFI_HII_IIBT_EXT1_BLOCK :: _EFI_HII_IIBT_EXT1_BLOCK;

_EFI_HII_IIBT_EXT2_BLOCK :: struct {
    Header:     EFI_HII_IMAGE_BLOCK;
    BlockType2: u8;
    Length:     u16;
}

EFI_HII_IIBT_EXT2_BLOCK :: _EFI_HII_IIBT_EXT2_BLOCK;

_EFI_HII_IIBT_EXT4_BLOCK :: struct {
    Header:     EFI_HII_IMAGE_BLOCK;
    BlockType2: u8;
    Length:     u32 #align 2;
}

EFI_HII_IIBT_EXT4_BLOCK :: _EFI_HII_IIBT_EXT4_BLOCK;

_EFI_HII_IIBT_IMAGE_1BIT_BASE :: struct {
    Width:  u16;
    Height: u16;
    Data:   [1] u8;
}

EFI_HII_IIBT_IMAGE_1BIT_BASE :: _EFI_HII_IIBT_IMAGE_1BIT_BASE;

_EFI_HII_IIBT_IMAGE_1BIT_BLOCK :: struct {
    Header:       EFI_HII_IMAGE_BLOCK;
    PaletteIndex: u8;
    Bitmap:       EFI_HII_IIBT_IMAGE_1BIT_BASE;
}

EFI_HII_IIBT_IMAGE_1BIT_BLOCK :: _EFI_HII_IIBT_IMAGE_1BIT_BLOCK;

_EFI_HII_IIBT_IMAGE_1BIT_TRANS_BLOCK :: struct {
    Header:       EFI_HII_IMAGE_BLOCK;
    PaletteIndex: u8;
    Bitmap:       EFI_HII_IIBT_IMAGE_1BIT_BASE;
}

EFI_HII_IIBT_IMAGE_1BIT_TRANS_BLOCK :: _EFI_HII_IIBT_IMAGE_1BIT_TRANS_BLOCK;

_EFI_HII_RGB_PIXEL :: struct {
    b: u8;
    g: u8;
    r: u8;
}

EFI_HII_RGB_PIXEL :: _EFI_HII_RGB_PIXEL;

_EFI_HII_IIBT_IMAGE_24BIT_BASE :: struct {
    Width:  u16;
    Height: u16;
    Bitmap: [1] EFI_HII_RGB_PIXEL;
}

EFI_HII_IIBT_IMAGE_24BIT_BASE :: _EFI_HII_IIBT_IMAGE_24BIT_BASE;

_EFI_HII_IIBT_IMAGE_24BIT_BLOCK :: struct {
    Header: EFI_HII_IMAGE_BLOCK;
    Bitmap: EFI_HII_IIBT_IMAGE_24BIT_BASE #align 1;
}

EFI_HII_IIBT_IMAGE_24BIT_BLOCK :: _EFI_HII_IIBT_IMAGE_24BIT_BLOCK;

_EFI_HII_IIBT_IMAGE_24BIT_TRANS_BLOCK :: struct {
    Header: EFI_HII_IMAGE_BLOCK;
    Bitmap: EFI_HII_IIBT_IMAGE_24BIT_BASE #align 1;
}

EFI_HII_IIBT_IMAGE_24BIT_TRANS_BLOCK :: _EFI_HII_IIBT_IMAGE_24BIT_TRANS_BLOCK;

_EFI_HII_IIBT_IMAGE_4BIT_BASE :: struct {
    Width:  u16;
    Height: u16;
    Data:   [1] u8;
}

EFI_HII_IIBT_IMAGE_4BIT_BASE :: _EFI_HII_IIBT_IMAGE_4BIT_BASE;

_EFI_HII_IIBT_IMAGE_4BIT_BLOCK :: struct {
    Header:       EFI_HII_IMAGE_BLOCK;
    PaletteIndex: u8;
    Bitmap:       EFI_HII_IIBT_IMAGE_4BIT_BASE;
}

EFI_HII_IIBT_IMAGE_4BIT_BLOCK :: _EFI_HII_IIBT_IMAGE_4BIT_BLOCK;

_EFI_HII_IIBT_IMAGE_4BIT_TRANS_BLOCK :: struct {
    Header:       EFI_HII_IMAGE_BLOCK;
    PaletteIndex: u8;
    Bitmap:       EFI_HII_IIBT_IMAGE_4BIT_BASE;
}

EFI_HII_IIBT_IMAGE_4BIT_TRANS_BLOCK :: _EFI_HII_IIBT_IMAGE_4BIT_TRANS_BLOCK;

_EFI_HII_IIBT_IMAGE_8BIT_BASE :: struct {
    Width:  u16;
    Height: u16;
    Data:   [1] u8;
}

EFI_HII_IIBT_IMAGE_8BIT_BASE :: _EFI_HII_IIBT_IMAGE_8BIT_BASE;

_EFI_HII_IIBT_IMAGE_8BIT_PALETTE_BLOCK :: struct {
    Header:       EFI_HII_IMAGE_BLOCK;
    PaletteIndex: u8;
    Bitmap:       EFI_HII_IIBT_IMAGE_8BIT_BASE;
}

EFI_HII_IIBT_IMAGE_8BIT_BLOCK :: _EFI_HII_IIBT_IMAGE_8BIT_PALETTE_BLOCK;

_EFI_HII_IIBT_IMAGE_8BIT_TRANS_BLOCK :: struct {
    Header:       EFI_HII_IMAGE_BLOCK;
    PaletteIndex: u8;
    Bitmap:       EFI_HII_IIBT_IMAGE_8BIT_BASE;
}

EFI_HII_IIBT_IMAGE_8BIT_TRAN_BLOCK :: _EFI_HII_IIBT_IMAGE_8BIT_TRANS_BLOCK;

_EFI_HII_IIBT_DUPLICATE_BLOCK :: struct {
    Header:  EFI_HII_IMAGE_BLOCK;
    ImageId: EFI_IMAGE_ID #align 1;
}

EFI_HII_IIBT_DUPLICATE_BLOCK :: _EFI_HII_IIBT_DUPLICATE_BLOCK;

_EFI_HII_IIBT_JPEG_BLOCK :: struct {
    Header: EFI_HII_IMAGE_BLOCK;
    Size:   u32 #align 1;
    Data:   [1] u8;
}

EFI_HII_IIBT_JPEG_BLOCK :: _EFI_HII_IIBT_JPEG_BLOCK;

_EFI_HII_IIBT_PNG_BLOCK :: struct {
    Header: EFI_HII_IMAGE_BLOCK;
    Size:   u32 #align 1;
    Data:   [1] u8;
}

EFI_HII_IIBT_PNG_BLOCK :: _EFI_HII_IIBT_PNG_BLOCK;

_EFI_HII_IIBT_SKIP1_BLOCK :: struct {
    Header:    EFI_HII_IMAGE_BLOCK;
    SkipCount: u8;
}

EFI_HII_IIBT_SKIP1_BLOCK :: _EFI_HII_IIBT_SKIP1_BLOCK;

_EFI_HII_IIBT_SKIP2_BLOCK :: struct {
    Header:    EFI_HII_IMAGE_BLOCK;
    SkipCount: u16 #align 1;
}

EFI_HII_IIBT_SKIP2_BLOCK :: _EFI_HII_IIBT_SKIP2_BLOCK;

//
// Definitions for Palette Information
//
_EFI_HII_IMAGE_PALETTE_INFO_HEADER :: struct {
    PaletteCount: u16;
}

//
// Definitions for Palette Information
//
EFI_HII_IMAGE_PALETTE_INFO_HEADER :: _EFI_HII_IMAGE_PALETTE_INFO_HEADER;

_EFI_HII_IMAGE_PALETTE_INFO :: struct {
    PaletteSize:  u16;
    PaletteValue: [1] EFI_HII_RGB_PIXEL;
}

EFI_HII_IMAGE_PALETTE_INFO :: _EFI_HII_IMAGE_PALETTE_INFO;

///
/// The Form package is used to carry form-based encoding data.
///
_EFI_HII_FORM_PACKAGE_HDR :: struct {
    Header: EFI_HII_PACKAGE_HEADER;
}

///
/// The Form package is used to carry form-based encoding data.
///
EFI_HII_FORM_PACKAGE_HDR :: _EFI_HII_FORM_PACKAGE_HDR;

EFI_HII_TIME :: struct {
    Hour:   u8;
    Minute: u8;
    Second: u8;
}

EFI_HII_DATE :: struct {
    Year:  u16;
    Month: u8;
    Day:   u8;
}

EFI_HII_REF :: struct {
    QuestionId:  EFI_QUESTION_ID;
    FormId:      EFI_FORM_ID;
    FormSetGuid: EFI_GUID;
    DevicePath:  EFI_STRING_ID;
}

EFI_IFR_TYPE_VALUE :: union {
    _u8:     u8;
    _u16:    u16;
    _u32:    u32;
    _u64:    u64;
    b:       BOOLEAN;
    time:    EFI_HII_TIME;
    date:    EFI_HII_DATE;
    _string: EFI_STRING_ID; ///< EFI_IFR_TYPE_STRING, EFI_IFR_TYPE_ACTION
    ref:     EFI_HII_REF; ///< EFI_IFR_TYPE_REF
}

//
// Definitions of IFR Standard Headers
// Section 27.3.8.2
//
_EFI_IFR_OP_HEADER :: struct {
    OpCode: u8;
    Length: u8;
    #place Length; /*bitfield 7*/ Scope:  u8;
}

//
// Definitions of IFR Standard Headers
// Section 27.3.8.2
//
EFI_IFR_OP_HEADER :: _EFI_IFR_OP_HEADER;

_EFI_IFR_STATEMENT_HEADER :: struct {
    Prompt: EFI_STRING_ID;
    Help:   EFI_STRING_ID;
}

EFI_IFR_STATEMENT_HEADER :: _EFI_IFR_STATEMENT_HEADER;

_EFI_IFR_QUESTION_HEADER :: struct {
    Header:       EFI_IFR_STATEMENT_HEADER;
    QuestionId:   EFI_QUESTION_ID;
    VarStoreId:   EFI_VARSTORE_ID;
    VarStoreInfo: union {
        VarName:   EFI_STRING_ID;
        VarOffset: u16;
    };

    Flags:        u8;
}

EFI_IFR_QUESTION_HEADER :: _EFI_IFR_QUESTION_HEADER;

//
// Definition for Opcode Reference
// Section 27.3.8.3
//
_EFI_IFR_DEFAULTSTORE :: struct {
    Header:      EFI_IFR_OP_HEADER;
    DefaultName: EFI_STRING_ID;
    DefaultId:   u16;
}

//
// Definition for Opcode Reference
// Section 27.3.8.3
//
EFI_IFR_DEFAULTSTORE :: _EFI_IFR_DEFAULTSTORE;

_EFI_IFR_VARSTORE :: struct {
    Header:     EFI_IFR_OP_HEADER;
    Guid:       EFI_GUID #align 2;
    VarStoreId: EFI_VARSTORE_ID;
    Size:       u16;
    Name:       [1] u8;
}

EFI_IFR_VARSTORE :: _EFI_IFR_VARSTORE;

_EFI_IFR_VARSTORE_EFI :: struct {
    Header:     EFI_IFR_OP_HEADER;
    VarStoreId: EFI_VARSTORE_ID;
    Guid:       EFI_GUID;
    Attributes: u32;
    Size:       u16;
    Name:       [1] u8;
}

EFI_IFR_VARSTORE_EFI :: _EFI_IFR_VARSTORE_EFI;

_EFI_IFR_VARSTORE_NAME_VALUE :: struct {
    Header:     EFI_IFR_OP_HEADER;
    VarStoreId: EFI_VARSTORE_ID;
    Guid:       EFI_GUID;
}

EFI_IFR_VARSTORE_NAME_VALUE :: _EFI_IFR_VARSTORE_NAME_VALUE;

_EFI_IFR_FORM_SET :: struct {
    Header:       EFI_IFR_OP_HEADER;
    Guid:         EFI_GUID #align 2;
    FormSetTitle: EFI_STRING_ID;
    Help:         EFI_STRING_ID;
    Flags:        u8;
}

EFI_IFR_FORM_SET :: _EFI_IFR_FORM_SET;

_EFI_IFR_END :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_END :: _EFI_IFR_END;

_EFI_IFR_FORM :: struct {
    Header:    EFI_IFR_OP_HEADER;
    FormId:    u16;
    FormTitle: EFI_STRING_ID;
}

EFI_IFR_FORM :: _EFI_IFR_FORM;

_EFI_IFR_IMAGE :: struct {
    Header: EFI_IFR_OP_HEADER;
    Id:     EFI_IMAGE_ID;
}

EFI_IFR_IMAGE :: _EFI_IFR_IMAGE;

_EFI_IFR_MODAL_TAG :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_MODAL_TAG :: _EFI_IFR_MODAL_TAG;

_EFI_IFR_LOCKED :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_LOCKED :: _EFI_IFR_LOCKED;

_EFI_IFR_RULE :: struct {
    Header: EFI_IFR_OP_HEADER;
    RuleId: u8;
}

EFI_IFR_RULE :: _EFI_IFR_RULE;

_EFI_IFR_DEFAULT :: struct {
    Header:    EFI_IFR_OP_HEADER;
    DefaultId: u16;
    Type:      u8;
    Value:     EFI_IFR_TYPE_VALUE #align 5;
}

EFI_IFR_DEFAULT :: _EFI_IFR_DEFAULT;

_EFI_IFR_DEFAULT_2 :: struct {
    Header:    EFI_IFR_OP_HEADER;
    DefaultId: u16;
    Type:      u8;
}

EFI_IFR_DEFAULT_2 :: _EFI_IFR_DEFAULT_2;

_EFI_IFR_VALUE :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_VALUE :: _EFI_IFR_VALUE;

_EFI_IFR_SUBTITLE :: struct {
    Header:    EFI_IFR_OP_HEADER;
    Statement: EFI_IFR_STATEMENT_HEADER;
    Flags:     u8;
}

EFI_IFR_SUBTITLE :: _EFI_IFR_SUBTITLE;

_EFI_IFR_CHECKBOX :: struct {
    Header:   EFI_IFR_OP_HEADER;
    Question: EFI_IFR_QUESTION_HEADER;
    Flags:    u8;
}

EFI_IFR_CHECKBOX :: _EFI_IFR_CHECKBOX;

_EFI_IFR_TEXT :: struct {
    Header:    EFI_IFR_OP_HEADER;
    Statement: EFI_IFR_STATEMENT_HEADER;
    TextTwo:   EFI_STRING_ID;
}

EFI_IFR_TEXT :: _EFI_IFR_TEXT;

_EFI_IFR_REF :: struct {
    Header:   EFI_IFR_OP_HEADER;
    Question: EFI_IFR_QUESTION_HEADER;
    FormId:   EFI_FORM_ID #align 1;
}

EFI_IFR_REF :: _EFI_IFR_REF;

_EFI_IFR_REF2 :: struct {
    Header:     EFI_IFR_OP_HEADER;
    Question:   EFI_IFR_QUESTION_HEADER;
    FormId:     EFI_FORM_ID #align 1;
    QuestionId: EFI_QUESTION_ID #align 1;
}

EFI_IFR_REF2 :: _EFI_IFR_REF2;

_EFI_IFR_REF3 :: struct {
    Header:     EFI_IFR_OP_HEADER;
    Question:   EFI_IFR_QUESTION_HEADER;
    FormId:     EFI_FORM_ID #align 1;
    QuestionId: EFI_QUESTION_ID #align 1;
    FormSetId:  EFI_GUID #align 1;
}

EFI_IFR_REF3 :: _EFI_IFR_REF3;

_EFI_IFR_REF4 :: struct {
    Header:     EFI_IFR_OP_HEADER;
    Question:   EFI_IFR_QUESTION_HEADER;
    FormId:     EFI_FORM_ID #align 1;
    QuestionId: EFI_QUESTION_ID #align 1;
    FormSetId:  EFI_GUID #align 1;
    DevicePath: EFI_STRING_ID #align 1;
}

EFI_IFR_REF4 :: _EFI_IFR_REF4;

_EFI_IFR_REF5 :: struct {
    Header:   EFI_IFR_OP_HEADER;
    Question: EFI_IFR_QUESTION_HEADER;
}

EFI_IFR_REF5 :: _EFI_IFR_REF5;

_EFI_IFR_RESET_BUTTON :: struct {
    Header:    EFI_IFR_OP_HEADER;
    Statement: EFI_IFR_STATEMENT_HEADER;
    DefaultId: EFI_DEFAULT_ID;
}

EFI_IFR_RESET_BUTTON :: _EFI_IFR_RESET_BUTTON;

_EFI_IFR_ACTION :: struct {
    Header:         EFI_IFR_OP_HEADER;
    Question:       EFI_IFR_QUESTION_HEADER;
    QuestionConfig: EFI_STRING_ID #align 1;
}

EFI_IFR_ACTION :: _EFI_IFR_ACTION;

_EFI_IFR_ACTION_1 :: struct {
    Header:   EFI_IFR_OP_HEADER;
    Question: EFI_IFR_QUESTION_HEADER;
}

EFI_IFR_ACTION_1 :: _EFI_IFR_ACTION_1;

_EFI_IFR_DATE :: struct {
    Header:   EFI_IFR_OP_HEADER;
    Question: EFI_IFR_QUESTION_HEADER;
    Flags:    u8;
}

EFI_IFR_DATE :: _EFI_IFR_DATE;

MINMAXSTEP_DATA :: union {
    _u8:  struct {
        MinValue: u8;
        MaxValue: u8;
        Step:     u8;
    };

    _u16: struct {
        MinValue: u16;
        MaxValue: u16;
        Step:     u16;
    };

    _u32: struct {
        MinValue: u32;
        MaxValue: u32;
        Step:     u32;
    };

    _u64: struct {
        MinValue: u64;
        MaxValue: u64;
        Step:     u64;
    };
}

_EFI_IFR_NUMERIC :: struct {
    Header:   EFI_IFR_OP_HEADER;
    Question: EFI_IFR_QUESTION_HEADER;
    Flags:    u8;
    data:     MINMAXSTEP_DATA #align 6;
}

EFI_IFR_NUMERIC :: _EFI_IFR_NUMERIC;

_EFI_IFR_ONE_OF :: struct {
    Header:   EFI_IFR_OP_HEADER;
    Question: EFI_IFR_QUESTION_HEADER;
    Flags:    u8;
    data:     MINMAXSTEP_DATA #align 6;
}

EFI_IFR_ONE_OF :: _EFI_IFR_ONE_OF;

_EFI_IFR_STRING :: struct {
    Header:   EFI_IFR_OP_HEADER;
    Question: EFI_IFR_QUESTION_HEADER;
    MinSize:  u8;
    MaxSize:  u8;
    Flags:    u8;
}

EFI_IFR_STRING :: _EFI_IFR_STRING;

_EFI_IFR_PASSWORD :: struct {
    Header:   EFI_IFR_OP_HEADER;
    Question: EFI_IFR_QUESTION_HEADER;
    MinSize:  u16 #align 1;
    MaxSize:  u16 #align 1;
}

EFI_IFR_PASSWORD :: _EFI_IFR_PASSWORD;

_EFI_IFR_ORDERED_LIST :: struct {
    Header:        EFI_IFR_OP_HEADER;
    Question:      EFI_IFR_QUESTION_HEADER;
    MaxContainers: u8;
    Flags:         u8;
}

EFI_IFR_ORDERED_LIST :: _EFI_IFR_ORDERED_LIST;

_EFI_IFR_TIME :: struct {
    Header:   EFI_IFR_OP_HEADER;
    Question: EFI_IFR_QUESTION_HEADER;
    Flags:    u8;
}

EFI_IFR_TIME :: _EFI_IFR_TIME;

_EFI_IFR_DISABLE_IF :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_DISABLE_IF :: _EFI_IFR_DISABLE_IF;

_EFI_IFR_SUPPRESS_IF :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_SUPPRESS_IF :: _EFI_IFR_SUPPRESS_IF;

_EFI_IFR_GRAY_OUT_IF :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_GRAY_OUT_IF :: _EFI_IFR_GRAY_OUT_IF;

_EFI_IFR_INCONSISTENT_IF :: struct {
    Header: EFI_IFR_OP_HEADER;
    Error:  EFI_STRING_ID;
}

EFI_IFR_INCONSISTENT_IF :: _EFI_IFR_INCONSISTENT_IF;

_EFI_IFR_NO_SUBMIT_IF :: struct {
    Header: EFI_IFR_OP_HEADER;
    Error:  EFI_STRING_ID;
}

EFI_IFR_NO_SUBMIT_IF :: _EFI_IFR_NO_SUBMIT_IF;

_EFI_IFR_WARNING_IF :: struct {
    Header:  EFI_IFR_OP_HEADER;
    Warning: EFI_STRING_ID;
    TimeOut: u8;
}

EFI_IFR_WARNING_IF :: _EFI_IFR_WARNING_IF;

_EFI_IFR_REFRESH :: struct {
    Header:          EFI_IFR_OP_HEADER;
    RefreshInterval: u8;
}

EFI_IFR_REFRESH :: _EFI_IFR_REFRESH;

_EFI_IFR_VARSTORE_DEVICE :: struct {
    Header:     EFI_IFR_OP_HEADER;
    DevicePath: EFI_STRING_ID;
}

EFI_IFR_VARSTORE_DEVICE :: _EFI_IFR_VARSTORE_DEVICE;

_EFI_IFR_ONE_OF_OPTION :: struct {
    Header: EFI_IFR_OP_HEADER;
    Option: EFI_STRING_ID;
    Flags:  u8;
    Type:   u8;
    Value:  EFI_IFR_TYPE_VALUE #align 6;
}

EFI_IFR_ONE_OF_OPTION :: _EFI_IFR_ONE_OF_OPTION;

_EFI_IFR_GUID :: struct {
    Header: EFI_IFR_OP_HEADER;
    Guid:   EFI_GUID #align 2;
}

EFI_IFR_GUID :: _EFI_IFR_GUID;

_EFI_IFR_REFRESH_ID :: struct {
    Header:              EFI_IFR_OP_HEADER;
    RefreshEventGroupId: EFI_GUID #align 2;
}

EFI_IFR_REFRESH_ID :: _EFI_IFR_REFRESH_ID;

_EFI_IFR_DUP :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_DUP :: _EFI_IFR_DUP;

_EFI_IFR_EQ_ID_ID :: struct {
    Header:      EFI_IFR_OP_HEADER;
    QuestionId1: EFI_QUESTION_ID;
    QuestionId2: EFI_QUESTION_ID;
}

EFI_IFR_EQ_ID_ID :: _EFI_IFR_EQ_ID_ID;

_EFI_IFR_EQ_ID_VAL :: struct {
    Header:     EFI_IFR_OP_HEADER;
    QuestionId: EFI_QUESTION_ID;
    Value:      u16;
}

EFI_IFR_EQ_ID_VAL :: _EFI_IFR_EQ_ID_VAL;

_EFI_IFR_EQ_ID_VAL_LIST :: struct {
    Header:     EFI_IFR_OP_HEADER;
    QuestionId: EFI_QUESTION_ID;
    ListLength: u16;
    ValueList:  [1] u16;
}

EFI_IFR_EQ_ID_VAL_LIST :: _EFI_IFR_EQ_ID_VAL_LIST;

_EFI_IFR_UINT8 :: struct {
    Header: EFI_IFR_OP_HEADER;
    Value:  u8;
}

EFI_IFR_UINT8 :: _EFI_IFR_UINT8;

_EFI_IFR_UINT16 :: struct {
    Header: EFI_IFR_OP_HEADER;
    Value:  u16;
}

EFI_IFR_UINT16 :: _EFI_IFR_UINT16;

_EFI_IFR_UINT32 :: struct {
    Header: EFI_IFR_OP_HEADER;
    Value:  u32 #align 2;
}

EFI_IFR_UINT32 :: _EFI_IFR_UINT32;

_EFI_IFR_UINT64 :: struct {
    Header: EFI_IFR_OP_HEADER;
    Value:  u64 #align 2;
}

EFI_IFR_UINT64 :: _EFI_IFR_UINT64;

_EFI_IFR_QUESTION_REF1 :: struct {
    Header:     EFI_IFR_OP_HEADER;
    QuestionId: EFI_QUESTION_ID;
}

EFI_IFR_QUESTION_REF1 :: _EFI_IFR_QUESTION_REF1;

_EFI_IFR_QUESTION_REF2 :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_QUESTION_REF2 :: _EFI_IFR_QUESTION_REF2;

_EFI_IFR_QUESTION_REF3 :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_QUESTION_REF3 :: _EFI_IFR_QUESTION_REF3;

_EFI_IFR_QUESTION_REF3_2 :: struct {
    Header:     EFI_IFR_OP_HEADER;
    DevicePath: EFI_STRING_ID;
}

EFI_IFR_QUESTION_REF3_2 :: _EFI_IFR_QUESTION_REF3_2;

_EFI_IFR_QUESTION_REF3_3 :: struct {
    Header:     EFI_IFR_OP_HEADER;
    DevicePath: EFI_STRING_ID;
    Guid:       EFI_GUID;
}

EFI_IFR_QUESTION_REF3_3 :: _EFI_IFR_QUESTION_REF3_3;

_EFI_IFR_RULE_REF :: struct {
    Header: EFI_IFR_OP_HEADER;
    RuleId: u8;
}

EFI_IFR_RULE_REF :: _EFI_IFR_RULE_REF;

_EFI_IFR_STRING_REF1 :: struct {
    Header:   EFI_IFR_OP_HEADER;
    StringId: EFI_STRING_ID;
}

EFI_IFR_STRING_REF1 :: _EFI_IFR_STRING_REF1;

_EFI_IFR_STRING_REF2 :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_STRING_REF2 :: _EFI_IFR_STRING_REF2;

_EFI_IFR_THIS :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_THIS :: _EFI_IFR_THIS;

_EFI_IFR_TRUE :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_TRUE :: _EFI_IFR_TRUE;

_EFI_IFR_FALSE :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_FALSE :: _EFI_IFR_FALSE;

_EFI_IFR_ONE :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_ONE :: _EFI_IFR_ONE;

_EFI_IFR_ONES :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_ONES :: _EFI_IFR_ONES;

_EFI_IFR_ZERO :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_ZERO :: _EFI_IFR_ZERO;

_EFI_IFR_UNDEFINED :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_UNDEFINED :: _EFI_IFR_UNDEFINED;

_EFI_IFR_VERSION :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_VERSION :: _EFI_IFR_VERSION;

_EFI_IFR_LENGTH :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_LENGTH :: _EFI_IFR_LENGTH;

_EFI_IFR_NOT :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_NOT :: _EFI_IFR_NOT;

_EFI_IFR_BITWISE_NOT :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_BITWISE_NOT :: _EFI_IFR_BITWISE_NOT;

_EFI_IFR_TO_BOOLEAN :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_TO_BOOLEAN :: _EFI_IFR_TO_BOOLEAN;

///@}
_EFI_IFR_TO_STRING :: struct {
    Header: EFI_IFR_OP_HEADER;
    Format: u8;
}

///@}
EFI_IFR_TO_STRING :: _EFI_IFR_TO_STRING;

_EFI_IFR_TO_UINT :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_TO_UINT :: _EFI_IFR_TO_UINT;

_EFI_IFR_TO_UPPER :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_TO_UPPER :: _EFI_IFR_TO_UPPER;

_EFI_IFR_TO_LOWER :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_TO_LOWER :: _EFI_IFR_TO_LOWER;

_EFI_IFR_ADD :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_ADD :: _EFI_IFR_ADD;

_EFI_IFR_AND :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_AND :: _EFI_IFR_AND;

_EFI_IFR_BITWISE_AND :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_BITWISE_AND :: _EFI_IFR_BITWISE_AND;

_EFI_IFR_BITWISE_OR :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_BITWISE_OR :: _EFI_IFR_BITWISE_OR;

_EFI_IFR_CATENATE :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_CATENATE :: _EFI_IFR_CATENATE;

_EFI_IFR_DIVIDE :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_DIVIDE :: _EFI_IFR_DIVIDE;

_EFI_IFR_EQUAL :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_EQUAL :: _EFI_IFR_EQUAL;

_EFI_IFR_GREATER_EQUAL :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_GREATER_EQUAL :: _EFI_IFR_GREATER_EQUAL;

_EFI_IFR_GREATER_THAN :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_GREATER_THAN :: _EFI_IFR_GREATER_THAN;

_EFI_IFR_LESS_EQUAL :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_LESS_EQUAL :: _EFI_IFR_LESS_EQUAL;

_EFI_IFR_LESS_THAN :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_LESS_THAN :: _EFI_IFR_LESS_THAN;

_EFI_IFR_MATCH :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_MATCH :: _EFI_IFR_MATCH;

_EFI_IFR_MATCH2 :: struct {
    Header:     EFI_IFR_OP_HEADER;
    SyntaxType: EFI_GUID #align 2;
}

EFI_IFR_MATCH2 :: _EFI_IFR_MATCH2;

_EFI_IFR_MULTIPLY :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_MULTIPLY :: _EFI_IFR_MULTIPLY;

_EFI_IFR_MODULO :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_MODULO :: _EFI_IFR_MODULO;

_EFI_IFR_NOT_EQUAL :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_NOT_EQUAL :: _EFI_IFR_NOT_EQUAL;

_EFI_IFR_OR :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_OR :: _EFI_IFR_OR;

_EFI_IFR_SHIFT_LEFT :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_SHIFT_LEFT :: _EFI_IFR_SHIFT_LEFT;

_EFI_IFR_SHIFT_RIGHT :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_SHIFT_RIGHT :: _EFI_IFR_SHIFT_RIGHT;

_EFI_IFR_SUBTRACT :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_SUBTRACT :: _EFI_IFR_SUBTRACT;

_EFI_IFR_CONDITIONAL :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_CONDITIONAL :: _EFI_IFR_CONDITIONAL;

_EFI_IFR_FIND :: struct {
    Header: EFI_IFR_OP_HEADER;
    Format: u8;
}

EFI_IFR_FIND :: _EFI_IFR_FIND;

_EFI_IFR_MID :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_MID :: _EFI_IFR_MID;

_EFI_IFR_TOKEN :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_TOKEN :: _EFI_IFR_TOKEN;

_EFI_IFR_SPAN :: struct {
    Header: EFI_IFR_OP_HEADER;
    Flags:  u8;
}

EFI_IFR_SPAN :: _EFI_IFR_SPAN;

_EFI_IFR_SECURITY :: struct {
    ///
    /// Standard opcode header, where Header.Op = EFI_IFR_SECURITY_OP.
    ///
    Header:      EFI_IFR_OP_HEADER;

    ///
    /// Security permission level.
    ///
    Permissions: EFI_GUID #align 2;
}

EFI_IFR_SECURITY :: _EFI_IFR_SECURITY;

_EFI_IFR_FORM_MAP_METHOD :: struct {
    ///
    /// The string identifier which provides the human-readable name of
    /// the configuration method for this standards map form.
    ///
    MethodTitle:      EFI_STRING_ID;

    ///
    /// Identifier which uniquely specifies the configuration methods
    /// associated with this standards map form.
    ///
    MethodIdentifier: EFI_GUID #align 2;
}

EFI_IFR_FORM_MAP_METHOD :: _EFI_IFR_FORM_MAP_METHOD;

_EFI_IFR_FORM_MAP :: struct {
    ///
    /// The sequence that defines the type of opcode as well as the length
    /// of the opcode being defined. Header.OpCode = EFI_IFR_FORM_MAP_OP.
    ///
    Header: EFI_IFR_OP_HEADER;

    ///
    /// The unique identifier for this particular form.
    ///
    FormId: EFI_FORM_ID;
}

EFI_IFR_FORM_MAP :: _EFI_IFR_FORM_MAP;

_EFI_IFR_SET :: struct {
    ///
    /// The sequence that defines the type of opcode as well as the length
    /// of the opcode being defined. Header.OpCode = EFI_IFR_SET_OP.
    ///
    Header:       EFI_IFR_OP_HEADER;

    ///
    /// Specifies the identifier of a previously declared variable store to
    /// use when storing the question's value.
    ///
    VarStoreId:   EFI_VARSTORE_ID;
    VarStoreInfo: union {
        ///
        /// A 16-bit Buffer Storage offset.
        ///
        VarName:   EFI_STRING_ID;

        ///
        /// A Name Value or EFI Variable name (VarName).
        ///
        VarOffset: u16;
    };

    ///
    /// Specifies the type used for storage.
    ///
    VarStoreType: u8;
}

EFI_IFR_SET :: _EFI_IFR_SET;

_EFI_IFR_GET :: struct {
    ///
    /// The sequence that defines the type of opcode as well as the length
    /// of the opcode being defined. Header.OpCode = EFI_IFR_GET_OP.
    ///
    Header:       EFI_IFR_OP_HEADER;

    ///
    /// Specifies the identifier of a previously declared variable store to
    /// use when retrieving the value.
    ///
    VarStoreId:   EFI_VARSTORE_ID;
    VarStoreInfo: union {
        ///
        /// A 16-bit Buffer Storage offset.
        ///
        VarName:   EFI_STRING_ID;

        ///
        /// A Name Value or EFI Variable name (VarName).
        ///
        VarOffset: u16;
    };

    ///
    /// Specifies the type used for storage.
    ///
    VarStoreType: u8;
}

EFI_IFR_GET :: _EFI_IFR_GET;

_EFI_IFR_READ :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_READ :: _EFI_IFR_READ;

_EFI_IFR_WRITE :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_WRITE :: _EFI_IFR_WRITE;

_EFI_IFR_MAP :: struct {
    Header: EFI_IFR_OP_HEADER;
}

EFI_IFR_MAP :: _EFI_IFR_MAP;

///
/// Each enumeration values maps a physical key on a keyboard.
///
EFI_KEY :: enum s32 {
    LCtrl      :: 0;
    A0         :: 1;
    LAlt       :: 2;
    SpaceBar   :: 3;
    A2         :: 4;
    A3         :: 5;
    A4         :: 6;
    RCtrl      :: 7;
    LeftArrow  :: 8;
    DownArrow  :: 9;
    RightArrow :: 10;
    Zero       :: 11;
    Period     :: 12;
    Enter      :: 13;
    LShift     :: 14;
    B0         :: 15;
    B1         :: 16;
    B2         :: 17;
    B3         :: 18;
    B4         :: 19;
    B5         :: 20;
    B6         :: 21;
    B7         :: 22;
    B8         :: 23;
    B9         :: 24;
    B10        :: 25;
    RShift     :: 26;
    UpArrow    :: 27;
    One        :: 28;
    Two        :: 29;
    Three      :: 30;
    CapsLock   :: 31;
    C1         :: 32;
    C2         :: 33;
    C3         :: 34;
    C4         :: 35;
    C5         :: 36;
    C6         :: 37;
    C7         :: 38;
    C8         :: 39;
    C9         :: 40;
    C10        :: 41;
    C11        :: 42;
    C12        :: 43;
    Four       :: 44;
    Five       :: 45;
    Six        :: 46;
    Plus       :: 47;
    Tab        :: 48;
    D1         :: 49;
    D2         :: 50;
    D3         :: 51;
    D4         :: 52;
    D5         :: 53;
    D6         :: 54;
    D7         :: 55;
    D8         :: 56;
    D9         :: 57;
    D10        :: 58;
    D11        :: 59;
    D12        :: 60;
    D13        :: 61;
    Del        :: 62;
    End        :: 63;
    PgDn       :: 64;
    Seven      :: 65;
    Eight      :: 66;
    Nine       :: 67;
    E0         :: 68;
    E1         :: 69;
    E2         :: 70;
    E3         :: 71;
    E4         :: 72;
    E5         :: 73;
    E6         :: 74;
    E7         :: 75;
    E8         :: 76;
    E9         :: 77;
    E10        :: 78;
    E11        :: 79;
    E12        :: 80;
    BackSpace  :: 81;
    Ins        :: 82;
    Home       :: 83;
    PgUp       :: 84;
    NLck       :: 85;
    Slash      :: 86;
    Asterisk   :: 87;
    Minus      :: 88;
    Esc        :: 89;
    F1         :: 90;
    F2         :: 91;
    F3         :: 92;
    F4         :: 93;
    F5         :: 94;
    F6         :: 95;
    F7         :: 96;
    F8         :: 97;
    F9         :: 98;
    F10        :: 99;
    F11        :: 100;
    F12        :: 101;
    Print      :: 102;
    SLck       :: 103;
    Pause      :: 104;

    EfiKeyLCtrl      :: LCtrl;
    EfiKeyA0         :: A0;
    EfiKeyLAlt       :: LAlt;
    EfiKeySpaceBar   :: SpaceBar;
    EfiKeyA2         :: A2;
    EfiKeyA3         :: A3;
    EfiKeyA4         :: A4;
    EfiKeyRCtrl      :: RCtrl;
    EfiKeyLeftArrow  :: LeftArrow;
    EfiKeyDownArrow  :: DownArrow;
    EfiKeyRightArrow :: RightArrow;
    EfiKeyZero       :: Zero;
    EfiKeyPeriod     :: Period;
    EfiKeyEnter      :: Enter;
    EfiKeyLShift     :: LShift;
    EfiKeyB0         :: B0;
    EfiKeyB1         :: B1;
    EfiKeyB2         :: B2;
    EfiKeyB3         :: B3;
    EfiKeyB4         :: B4;
    EfiKeyB5         :: B5;
    EfiKeyB6         :: B6;
    EfiKeyB7         :: B7;
    EfiKeyB8         :: B8;
    EfiKeyB9         :: B9;
    EfiKeyB10        :: B10;
    EfiKeyRShift     :: RShift;
    EfiKeyUpArrow    :: UpArrow;
    EfiKeyOne        :: One;
    EfiKeyTwo        :: Two;
    EfiKeyThree      :: Three;
    EfiKeyCapsLock   :: CapsLock;
    EfiKeyC1         :: C1;
    EfiKeyC2         :: C2;
    EfiKeyC3         :: C3;
    EfiKeyC4         :: C4;
    EfiKeyC5         :: C5;
    EfiKeyC6         :: C6;
    EfiKeyC7         :: C7;
    EfiKeyC8         :: C8;
    EfiKeyC9         :: C9;
    EfiKeyC10        :: C10;
    EfiKeyC11        :: C11;
    EfiKeyC12        :: C12;
    EfiKeyFour       :: Four;
    EfiKeyFive       :: Five;
    EfiKeySix        :: Six;
    EfiKeyPlus       :: Plus;
    EfiKeyTab        :: Tab;
    EfiKeyD1         :: D1;
    EfiKeyD2         :: D2;
    EfiKeyD3         :: D3;
    EfiKeyD4         :: D4;
    EfiKeyD5         :: D5;
    EfiKeyD6         :: D6;
    EfiKeyD7         :: D7;
    EfiKeyD8         :: D8;
    EfiKeyD9         :: D9;
    EfiKeyD10        :: D10;
    EfiKeyD11        :: D11;
    EfiKeyD12        :: D12;
    EfiKeyD13        :: D13;
    EfiKeyDel        :: Del;
    EfiKeyEnd        :: End;
    EfiKeyPgDn       :: PgDn;
    EfiKeySeven      :: Seven;
    EfiKeyEight      :: Eight;
    EfiKeyNine       :: Nine;
    EfiKeyE0         :: E0;
    EfiKeyE1         :: E1;
    EfiKeyE2         :: E2;
    EfiKeyE3         :: E3;
    EfiKeyE4         :: E4;
    EfiKeyE5         :: E5;
    EfiKeyE6         :: E6;
    EfiKeyE7         :: E7;
    EfiKeyE8         :: E8;
    EfiKeyE9         :: E9;
    EfiKeyE10        :: E10;
    EfiKeyE11        :: E11;
    EfiKeyE12        :: E12;
    EfiKeyBackSpace  :: BackSpace;
    EfiKeyIns        :: Ins;
    EfiKeyHome       :: Home;
    EfiKeyPgUp       :: PgUp;
    EfiKeyNLck       :: NLck;
    EfiKeySlash      :: Slash;
    EfiKeyAsterisk   :: Asterisk;
    EfiKeyMinus      :: Minus;
    EfiKeyEsc        :: Esc;
    EfiKeyF1         :: F1;
    EfiKeyF2         :: F2;
    EfiKeyF3         :: F3;
    EfiKeyF4         :: F4;
    EfiKeyF5         :: F5;
    EfiKeyF6         :: F6;
    EfiKeyF7         :: F7;
    EfiKeyF8         :: F8;
    EfiKeyF9         :: F9;
    EfiKeyF10        :: F10;
    EfiKeyF11        :: F11;
    EfiKeyF12        :: F12;
    EfiKeyPrint      :: Print;
    EfiKeySLck       :: SLck;
    EfiKeyPause      :: Pause;
}

EFI_KEY_DESCRIPTOR :: struct {
    ///
    /// Used to describe a physical key on a keyboard.
    ///
    Key:                 EFI_KEY;

    ///
    /// Unicode character code for the Key.
    ///
    Unicode:             CHAR16;

    ///
    /// Unicode character code for the key with the shift key being held down.
    ///
    ShiftedUnicode:      CHAR16;

    ///
    /// Unicode character code for the key with the Alt-GR being held down.
    ///
    AltGrUnicode:        CHAR16;

    ///
    /// Unicode character code for the key with the Alt-GR and shift keys being held down.
    ///
    ShiftedAltGrUnicode: CHAR16;

    ///
    /// Modifier keys are defined to allow for special functionality that is not necessarily
    /// accomplished by a printable character. Many of these modifier keys are flags to toggle
    /// certain state bits on and off inside of a keyboard driver.
    ///
    Modifier:            u16;
    AffectedAttribute:   u16;
}

EFI_HII_KEYBOARD_LAYOUT :: struct {
    LayoutLength:                 u16;
    Guid:                         EFI_GUID #align 2;
    LayoutDescriptorStringOffset: u32 #align 2;
    DescriptorCount:              u8;
}

EFI_HII_KEYBOARD_PACKAGE_HDR :: struct {
    Header:      EFI_HII_PACKAGE_HEADER;
    LayoutCount: u16;
}

///
/// Animation IFR opcode
///
_EFI_IFR_ANIMATION :: struct {
    ///
    /// Standard opcode header, where Header.OpCode is
    /// EFI_IFR_ANIMATION_OP.
    ///
    Header: EFI_IFR_OP_HEADER;

    ///
    /// Animation identifier in the HII database.
    ///
    Id:     EFI_ANIMATION_ID;
}

///
/// Animation IFR opcode
///
EFI_IFR_ANIMATION :: _EFI_IFR_ANIMATION;

///
/// HII animation package header.
///
_EFI_HII_ANIMATION_PACKAGE_HDR :: struct {
    ///
    /// Standard package header, where Header.Type = EFI_HII_PACKAGE_ANIMATIONS.
    ///
    Header:              EFI_HII_PACKAGE_HEADER;

    ///
    /// Offset, relative to this header, of the animation information. If
    /// this is zero, then there are no animation sequences in the package.
    ///
    AnimationInfoOffset: u32;
}

///
/// HII animation package header.
///
EFI_HII_ANIMATION_PACKAGE_HDR :: _EFI_HII_ANIMATION_PACKAGE_HDR;

///
/// Animation information is encoded as a series of blocks,
/// with each block prefixed by a single byte header EFI_HII_ANIMATION_BLOCK.
///
_EFI_HII_ANIMATION_BLOCK :: struct {
    BlockType: u8;
}

///
/// Animation information is encoded as a series of blocks,
/// with each block prefixed by a single byte header EFI_HII_ANIMATION_BLOCK.
///
EFI_HII_ANIMATION_BLOCK :: _EFI_HII_ANIMATION_BLOCK;

///
/// Extended block headers used for variable sized animation records
/// which need an explicit length.
///
_EFI_HII_AIBT_EXT1_BLOCK :: struct {
    ///
    /// Standard animation header, where Header.BlockType = EFI_HII_AIBT_EXT1.
    ///
    Header:     EFI_HII_ANIMATION_BLOCK;

    ///
    /// The block type.
    ///
    BlockType2: u8;

    ///
    /// Size of the animation block, in bytes, including the animation block header.
    ///
    Length:     u8;
}

///
/// Extended block headers used for variable sized animation records
/// which need an explicit length.
///
EFI_HII_AIBT_EXT1_BLOCK :: _EFI_HII_AIBT_EXT1_BLOCK;

_EFI_HII_AIBT_EXT2_BLOCK :: struct {
    ///
    /// Standard animation header, where Header.BlockType = EFI_HII_AIBT_EXT2.
    ///
    Header:     EFI_HII_ANIMATION_BLOCK;

    ///
    /// The block type
    ///
    BlockType2: u8;

    ///
    /// Size of the animation block, in bytes, including the animation block header.
    ///
    Length:     u16;
}

EFI_HII_AIBT_EXT2_BLOCK :: _EFI_HII_AIBT_EXT2_BLOCK;

_EFI_HII_AIBT_EXT4_BLOCK :: struct {
    ///
    /// Standard animation header, where Header.BlockType = EFI_HII_AIBT_EXT4.
    ///
    Header:     EFI_HII_ANIMATION_BLOCK;

    ///
    /// The block type
    ///
    BlockType2: u8;

    ///
    /// Size of the animation block, in bytes, including the animation block header.
    ///
    Length:     u32 #align 2;
}

EFI_HII_AIBT_EXT4_BLOCK :: _EFI_HII_AIBT_EXT4_BLOCK;

_EFI_HII_ANIMATION_CELL :: struct {
    ///
    /// The X offset from the upper left hand corner of the logical
    /// window to position the indexed image.
    ///
    OffsetX: u16;

    ///
    /// The Y offset from the upper left hand corner of the logical
    /// window to position the indexed image.
    ///
    OffsetY: u16;

    ///
    /// The image to display at the specified offset from the upper left
    /// hand corner of the logical window.
    ///
    ImageId: EFI_IMAGE_ID;

    ///
    /// The number of milliseconds to delay after displaying the indexed
    /// image and before continuing on to the next linked image.  If value
    /// is zero, no delay.
    ///
    Delay:   u16;
}

EFI_HII_ANIMATION_CELL :: _EFI_HII_ANIMATION_CELL;

///
/// An animation block to describe an animation sequence that does not cycle, and
/// where one image is simply displayed over the previous image.
///
_EFI_HII_AIBT_OVERLAY_IMAGES_BLOCK :: struct {
    ///
    /// This is image that is to be reference by the image protocols, if the
    /// animation function is not supported or disabled. This image can
    /// be one particular image from the animation sequence (if any one
    /// of the animation frames has a complete image) or an alternate
    /// image that can be displayed alone. If the value is zero, no image
    /// is displayed.
    ///
    DftImageId:    EFI_IMAGE_ID;

    ///
    /// The overall width of the set of images (logical window width).
    ///
    Width:         u16;

    ///
    /// The overall height of the set of images (logical window height).
    ///
    Height:        u16;

    ///
    /// The number of EFI_HII_ANIMATION_CELL contained in the
    /// animation sequence.
    ///
    CellCount:     u16;

    ///
    /// An array of CellCount animation cells.
    ///
    AnimationCell: [1] EFI_HII_ANIMATION_CELL;
}

///
/// An animation block to describe an animation sequence that does not cycle, and
/// where one image is simply displayed over the previous image.
///
EFI_HII_AIBT_OVERLAY_IMAGES_BLOCK :: _EFI_HII_AIBT_OVERLAY_IMAGES_BLOCK;

///
/// An animation block to describe an animation sequence that does not cycle,
/// and where the logical window is cleared to the specified color before
/// the next image is displayed.
///
_EFI_HII_AIBT_CLEAR_IMAGES_BLOCK :: struct {
    ///
    /// This is image that is to be reference by the image protocols, if the
    /// animation function is not supported or disabled. This image can
    /// be one particular image from the animation sequence (if any one
    /// of the animation frames has a complete image) or an alternate
    /// image that can be displayed alone. If the value is zero, no image
    /// is displayed.
    ///
    DftImageId:    EFI_IMAGE_ID;

    ///
    /// The overall width of the set of images (logical window width).
    ///
    Width:         u16;

    ///
    /// The overall height of the set of images (logical window height).
    ///
    Height:        u16;

    ///
    /// The number of EFI_HII_ANIMATION_CELL contained in the
    /// animation sequence.
    ///
    CellCount:     u16;

    ///
    /// The color to clear the logical window to before displaying the
    /// indexed image.
    ///
    BackgndColor:  EFI_HII_RGB_PIXEL;

    ///
    /// An array of CellCount animation cells.
    ///
    AnimationCell: [1] EFI_HII_ANIMATION_CELL #align 1;
}

///
/// An animation block to describe an animation sequence that does not cycle,
/// and where the logical window is cleared to the specified color before
/// the next image is displayed.
///
EFI_HII_AIBT_CLEAR_IMAGES_BLOCK :: _EFI_HII_AIBT_CLEAR_IMAGES_BLOCK;

///
/// An animation block to describe an animation sequence that does not cycle,
/// and where the screen is restored to the original state before the next
/// image is displayed.
///
_EFI_HII_AIBT_RESTORE_SCRN_BLOCK :: struct {
    ///
    /// This is image that is to be reference by the image protocols, if the
    /// animation function is not supported or disabled. This image can
    /// be one particular image from the animation sequence (if any one
    /// of the animation frames has a complete image) or an alternate
    /// image that can be displayed alone. If the value is zero, no image
    /// is displayed.
    ///
    DftImageId:    EFI_IMAGE_ID;

    ///
    /// The overall width of the set of images (logical window width).
    ///
    Width:         u16;

    ///
    /// The overall height of the set of images (logical window height).
    ///
    Height:        u16;

    ///
    /// The number of EFI_HII_ANIMATION_CELL contained in the
    /// animation sequence.
    ///
    CellCount:     u16;

    ///
    /// An array of CellCount animation cells.
    ///
    AnimationCell: [1] EFI_HII_ANIMATION_CELL;
}

///
/// An animation block to describe an animation sequence that does not cycle,
/// and where the screen is restored to the original state before the next
/// image is displayed.
///
EFI_HII_AIBT_RESTORE_SCRN_BLOCK :: _EFI_HII_AIBT_RESTORE_SCRN_BLOCK;

///
/// An animation block to describe an animation sequence that continuously cycles,
/// and where one image is simply displayed over the previous image.
///
EFI_HII_AIBT_OVERLAY_IMAGES_LOOP_BLOCK :: EFI_HII_AIBT_OVERLAY_IMAGES_BLOCK;

///
/// An animation block to describe an animation sequence that continuously cycles,
/// and where the logical window is cleared to the specified color before
/// the next image is displayed.
///
EFI_HII_AIBT_CLEAR_IMAGES_LOOP_BLOCK :: EFI_HII_AIBT_CLEAR_IMAGES_BLOCK;

///
/// An animation block to describe an animation sequence that continuously cycles,
/// and where the screen is restored to the original state before
/// the next image is displayed.
///
EFI_HII_AIBT_RESTORE_SCRN_LOOP_BLOCK :: EFI_HII_AIBT_RESTORE_SCRN_BLOCK;

///
/// Assigns a new character value to a previously defined animation sequence.
///
_EFI_HII_AIBT_DUPLICATE_BLOCK :: struct {
    ///
    /// The previously defined animation ID with the exact same
    /// animation information.
    ///
    AnimationId: EFI_ANIMATION_ID;
}

///
/// Assigns a new character value to a previously defined animation sequence.
///
EFI_HII_AIBT_DUPLICATE_BLOCK :: _EFI_HII_AIBT_DUPLICATE_BLOCK;

///
/// Skips animation IDs.
///
_EFI_HII_AIBT_SKIP1_BLOCK :: struct {
    ///
    /// The unsigned 8-bit value to add to AnimationIdCurrent.
    ///
    SkipCount: u8;
}

///
/// Skips animation IDs.
///
EFI_HII_AIBT_SKIP1_BLOCK :: _EFI_HII_AIBT_SKIP1_BLOCK;

///
/// Skips animation IDs.
///
_EFI_HII_AIBT_SKIP2_BLOCK :: struct {
    ///
    /// The unsigned 16-bit value to add to AnimationIdCurrent.
    ///
    SkipCount: u16;
}

///
/// Skips animation IDs.
///
EFI_HII_AIBT_SKIP2_BLOCK :: _EFI_HII_AIBT_SKIP2_BLOCK;

#scope_file

